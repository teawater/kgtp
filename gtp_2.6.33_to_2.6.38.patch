--- /dev/null
+++ b/Documentation/gtp/howto.txt
@@ -0,0 +1,1990 @@
+		Linux Kernel GDB tracepoint module (KGTP)
+		=========================================
+		By Hui Zhu <teawater@gmail.com>
+		https://code.google.com/p/kgtp/wiki/HOWTO
+
+Update in 2013-06-26
+
+What is KGTP
+Get help or report issues about KGTP
+Table of different between GDB debug normal program and KGTP
+Preparatory work before use KGTP
+Linux kernel
+If your system use the Linux kernel that is built by yourself
+If use with Linux kernel of Android
+If your system use the Linux kernel from distribution
+Ubuntu
+The standard method of install the Linux kernel debug image
+The second method of install the Linux kernel debug image
+Install the Linux kernel headers
+Install the Linux kernel source
+Fedora
+Install the Linux kernel debug image
+Install the Linux kernel devel package
+Others
+Make sure current Linux kernel debug image is right
+Where is the current Linux kernel debug image
+Use /proc/kallsyms
+Use linux_banner
+Handle the issue that Linux kernel debug image's address info is not same with Linux kernel when it running
+Get KGTP
+Get KGTP through http
+Get KGTP through svn
+Config KGTP
+Compile KGTP
+Normal compile
+Compile KGTP with some special config
+Install and uninstall KGTP
+Use KGTP with DKMS
+Use KGTP patch for Linux kernel
+Install GDB for KGTP
+How to let GDB connect to KGTP
+Normal Linux
+Insmod the KGTP module
+Handle the issue that cannot find "/sys/kernel/debug/gtp"
+Make GDB connect to gtp
+GDB on the current machine
+GDB on remote machine
+Android
+Insmod the KGTP module
+Handle the issue that cannot find "/sys/kernel/debug/gtp"
+GDB connect to the KGTP
+Add module symbols to GDB
+How to use getmod
+How to use getmod.py
+Howto use GDB control KGTP trace and debug Linux kernel
+Direct access the current value in normal mode
+The memory of Linux kernel
+the memory of the user space program
+the trace state variables
+GDB tracepoint
+set tracepoint
+Howto handle the function is there but set tracepoint on it got fail
+How to set tracepoint condition
+How to handle error "Unsupported operator (null) (52) in expression."
+actions [num]
+collect expr1, expr2, ...
+teval expr1, expr2, ...
+while-stepping n
+Start and stop the tracepoint
+Enable and disable the tracepoint
+Use tfind select the entry inside the trace frame info
+How to handle error "No such file or directory."
+Save the trace frame info to a file
+Show and save the tracepoint
+Delete tracepoint
+Use tracepoint get register info from a point of kernel
+Use tracepoint get the value of variable from a point of kernel
+Show all the traced data of current frame
+Get status of tracepoint
+Set the trace buffer into a circular buffer
+Do not stop tracepoint when the GDB disconnects
+kprobes-optimization and the execution speed of tracepoint
+How to use trace state variables
+Simple trace state variables
+Per_cpu trace state variables
+How to define
+Local CPU variables
+CPU id variables
+Example 1
+Example 2
+Special trace state variables $current_task, $current_task_pid, $current_thread_info, $cpu_id, $dump_stack, $printk_level, $printk_format, $printk_tmp ,$clock, $hardirq_count, $softirq_count and $irq_count
+Special trace state variable $self_trace
+Trace the function return with $kret
+Use $ignore_error and $last_errno to ignore the error of tstart
+Use $cooked_clock and $cooked_rdtsc the time without KGTP used
+Use $xtime_sec and $xtime_nsec get the timespec
+Howto backtrace (stack dump)
+Collect stack with $bt and use GDB command "backtrace"
+Collect stack of current function's caller with $_ret
+Use $dump_stack to output stack dump through printk
+Howto let tracepoint output value directly
+Switch collect to output the value directly
+Howto use watch tracepoint control hardware breakpoints to record memory access
+Trace state variables of watch tracepoint
+Static watch tracepoint
+Dynamic watch tracepoint
+Use while-stepping let Linux kernel do single step
+Howto use while-stepping
+Read the traceframe of while-stepping
+Howto show a variable whose value has been optimized away
+Update your GCC
+Get the way that access the variable that has been out through parse ASM code
+How to get the function pointer point to
+If the debug info of the function pointer is not optimized out
+If the debug info of the function pointer is optimized out
+/sys/kernel/debug/gtpframe and offline debug
+How to use /sys/kernel/debug/gtpframe_pipe
+Get the frame info with GDB
+Get the frame info with cat
+Get the frame info with getframe
+Use $pipe_trace
+Use KGTP with user space program
+Read memory of user space program directly
+collect stack (for backtrace) of user space program in tracepoint
+How to use add-ons/hotcode.py
+How to add plugin in C
+API
+Example
+How to use
+How to use performance counters
+Define a perf event trace state variable
+Define a per_cpu perf event trace state variable
+The perf event type and config
+Enable and disable all the perf event in a CPU with $p_pe_en
+GDB scripts to help with set and get the perf event trace state variables
+What is KGTP
+KGTP is a flexible, lightweight and realtime Linux (include Android) debugger and tracer.
+To use it, you don't need patch or rebuild the Linux kernel. Just build KGTP module and insmod it is OK.
+
+It makes Linux Kernel supply a GDB remote debug interface. Then GDB in current machine or remote machine can debug and trace Linux kernel and user space program through GDB tracepoint and some other functions without stopping the Linux Kernel.
+And even if the board doesn't have GDB on it and doesn't have interface for remote debug. It can debug the Linux Kernel using offline debug (See HOWTO#/sys/kernel/debug/gtpframe_and_offline_debug).
+KGTP supports X86-32, X86-64, MIPS and ARM.
+KGTP is tested on Linux kernel 2.6.18 to upstream.
+
+For new user of KGTP, please go to see Quickstart.
+
+Please go to UPDATE to get more info about KGTP update.
+
+Get help or report issues about KGTP
+You can post it to http://code.google.com/p/kgtp/issues/list, write Email to kgtp@freelists.org or write Email to teawater@gmail.com .
+The KGTP team will try our best to help you.
+
+Table of different between GDB debug normal program and KGTP
+This table is for the people that have experience using GDB debug normal program. It will help you understand and remember the function of KGTP.
+
+Function	GDB debug normal program	GDB control KGTP debug Linux kernel
+Preparatory work	 Have a GDB installed in your system.
+Program built with "-g".	 KGTP need GDB 7.6 or newer version because it use some new functions of GDB. If your system doesn't supply itï¼Œyou can get new version GDB in http://code.google.com/p/gdbt/ and you can get an introduce about howto built new GDB step by step in there.
+You alse need do some preparatory work with Linux kernel and KGTP. Please goto HOWTO#Preparatory_work_before_use_KGTP get howto do it.
+Attach	 Use command "gdb -p pid" or GDB command "attach pid" can attach a program that running in the system.	 Need insmod gtp.ko first, see #Exec_it.
+Then let GDB connect to KGTP, see #Make_GDB_connect_to_gtp.
+Please note that after GDB connect to KGTP, Linux kernel will not stop.
+Breakpoints	 GDB command "b place_will_stop", let program execute after this command. Then programe will stop in the place that setup a breakpoint.	 KGTP doesn't support breakpoints but it support tracepoints. Tracepoints can be considered as a special kind of breakpoints. It can be setup in some place of Linux kernel and define some commands that you want to do in its actions. When tracepoints start, they will execute these commands when Linux kernel execute to these place. When tracepoint stop, you can use some GDB commands parse the data that get by tracepoints like what you do when program stop by breakpoints. Difference is breakpoints will stop the program But the tracepoints of KGTP not. Please goto #GDB_tracepoint get howto use it.
+Memory read	 After GDB stop the program(maybe doesn't need), it can read memory of program with GDB command "print", "x" and so on.	 You can set special actions to collect memory to traceframe in tracepoints, and get the its value when tracepoint stop.#collect_expr1,_expr2,_... #Use_tfind_select_the_entry_inside_the_trace_frame_info 
+Or you can read memory directly when Linux kernel or program is running.#Direct_access_the_current_value_in_normal_mode
+Step and continue	 GDB can continue program execution with command "continue" and stop it with CTRL-C.	 KGTP never stop the Linux kernel. But tracepoint can be start and stop.#Start_and_stop_the_tracepoint 
+Or use while-stepping tracepoint record Linux kernel with some times single step and Let KGTP switch to replay mode. Then it support execution commands (continue, step) and reverse-execute commands (reverse-continue, reverse-step). #Use_while-stepping_let_Linux_kernel_do_single_step
+Backtrace	 GDB can print backtrace of all stack frames with command "backtrace".	 KGTP can do it too.#Howto_backtrace_(stack_dump)
+Watchpoint	 GDB can let programe stop when some memory access happen with watchpoint.	 KGTP can record the memory access with watch tracepoint. #Howto_use_watch_tracepoint_control_hardware_breakpoints_to_recor
+Call function	 GDB can call function of program with command "call function(xx,xx)".	 KGTP can call function of Linux kernel with plugin.#How_to_add_plugin_in_C
+Preparatory work before use KGTP
+Linux kernel
+If your system use the Linux kernel that is built by yourself
+To use KGTP, your Linux kernel need open following options:
+
+General setup  --->
+        [*] Kprobes
+
+[*] Enable loadable module support  --->
+
+Kernel hacking  --->
+        [*] Debug Filesystem
+        [*] Compile the kernel with debug info
+Please rebuild your Linux kernel if you change any options of the config.
+
+If use with Linux kernel of Android
+The default Linux kernel config of Android should not support KGTP. To use KGTP, Linux kernel of Android need open following options:
+
+[*] Enable loadable module support  --->
+General setup  ---> 
+        [*] Prompt for development and/or incomplete code/drivers
+        [*] Kprobes
+Kernel hacking  --->
+        [*] Debug Filesystem
+        [*] Compile the kernel with debug info
+Please rebuild your Linux kernel if you change any options of the Linux kernel config.
+
+If your system use the Linux kernel from distribution
+You need install some Linux kernel package.
+
+Ubuntu
+The standard method of install the Linux kernel debug image
+1) Add debug source to the sources list of Ubuntu.
+
+Create an /etc/apt/sources.list.d/ddebs.list by running the following line at a terminal:
+echo "deb http://ddebs.ubuntu.com $(lsb_release -cs) main restricted universe multiverse" | \
+sudo tee -a /etc/apt/sources.list.d/ddebs.list
+Stable releases (not alphas and betas) require three more lines adding to the same file, which is done by the following terminal command:
+echo "deb http://ddebs.ubuntu.com $(lsb_release -cs)-updates main restricted universe multiverse
+deb http://ddebs.ubuntu.com $(lsb_release -cs)-security main restricted universe multiverse
+deb http://ddebs.ubuntu.com $(lsb_release -cs)-proposed main restricted universe multiverse" | \
+sudo tee -a /etc/apt/sources.list.d/ddebs.list
+Import the debug symbol archive signing key:
+sudo apt-key adv --keyserver keyserver.ubuntu.com --recv-keys 428D7C01
+Then run:
+sudo apt-get update
+
+2) Get Linux kernel debug image
+
+sudo apt-get install linux-image-$(uname -r)-dbgsym
+Then you can find Linux kernel debug image in "/usr/lib/debug/boot/vmlinux-$(uname -r)".
+Please note that this step Get Linux kernel debug image need do again when Linux kernel update.
+
+The second method of install the Linux kernel debug image
+If you got some trouble with the standard method, please use following commands to install the Linux kernel debug image.
+
+wget http://ddebs.ubuntu.com/pool/main/l/linux/linux-image-$(uname -r)-dbgsym_$(dpkg -s linux-image-$(uname -r) | grep ^Version: | sed 's/Version: //')_$(uname -i | sed 's/x86_64/amd64/').ddeb
+sudo dpkg -i linux-image-$(uname -r)-dbgsym_$(dpkg -s linux-image-$(uname -r) | grep ^Version: | sed 's/Version: //')_$(uname -i | sed 's/x86_64/amd64/').ddeb
+Please note that this method need do again when Linux kernel update.
+
+Install the Linux kernel headers
+sudo apt-get install linux-headers-generic
+Install the Linux kernel source
+Install the source package:
+sudo apt-get install linux-source
+Uncompress the source package:
+sudo mkdir -p /build/buildd/
+sudo tar vxjf /usr/src/linux-source-$(uname -r | sed 's/-.*//').tar.bz2 -C /build/buildd/
+sudo rm -rf /build/buildd/linux-$(uname -r | sed 's/-.*//')
+sudo mv /build/buildd/linux-source-$(uname -r | sed 's/-.*//') /build/buildd/linux-$(uname -r | sed 's/-.*//')
+Please note that this step Install the Linux kernel source need do again when Linux kernel update.
+
+Fedora
+Install the Linux kernel debug image
+Use following command:
+
+sudo debuginfo-install kernel
+Or:
+
+sudo yum --enablerepo=fedora-debuginfo install kernel-debuginfo
+Then you can find Linux kernel debug image in "/usr/lib/debug/lib/modules/$(uname -r)/vmlinux".
+
+Install the Linux kernel devel package
+sudo yum install kernel-devel-$(uname -r)
+Please note that after update the Linux kernel package, you may need to call this command.
+
+Others
+You need install the Linux kernel debug image package and the Linux Kernel source.
+
+Make sure current Linux kernel debug image is right
+GDB open the right Linux kernel debug image is an very important because GDB will get the debug info and address info from it. So before you use KGTP, please do the check to make sure about it.
+There are 2 ways to do the check, what I suggest is do both of them to make sure Linux kernel debug image is right. 
+
+Please note that if you determine you use the right Linux kernel debug image, but cannot pass these ways. Please see HOWTO#Handle_the_issue_that_Linux_kernel_debug_image's_address_in.
+
+Where is the current Linux kernel debug image
+In UBUNTU, you can find it in "/usr/lib/debug/boot/vmlinux-$(uname -r)".
+In Fedora, you can find it in "/usr/lib/debug/lib/modules/$(uname -r)/vmlinux".
+If you build Linux kernel with yourself, you can find vmlinux file in the Linux kernel build directory.
+
+Use /proc/kallsyms
+In the system that its Linux kernel is what you want to trace, use following command to get the address of sys_read and sys_write:
+
+sudo cat /proc/kallsyms | grep sys_read
+ffffffff8117a520 T sys_read
+sudo cat /proc/kallsyms | grep sys_write
+ffffffff8117a5b0 T sys_write
+Then we can get that the address of sys_read is 0xffffffff8117a520 and the address of sys_write is 0xffffffff8117a5b0.
+After that use GDB get address of sys_read and sys_write from Linux kernel debug image:
+
+gdb ./vmlinux
+(gdb) p sys_read
+$1 = {long int (unsigned int, char *, size_t)} 0xffffffff8117a520 <sys_read>
+(gdb) p sys_write
+$2 = {long int (unsigned int, const char *, size_t)} 0xffffffff8117a5b0 <sys_write>
+The address of sys_read and sys_write is same, so the Linux kernel debug image is right.
+
+Use linux_banner
+sudo gdb ./vmlinux
+(gdb) p linux_banner
+$1 = "Linux version 3.4.0-rc4+ (teawater@teawater-Precision-M4600) (gcc version 4.6.3 (GCC) ) #3 SMP Tue Apr 24 13:29:05 CST 2012\n"
+This linux_banner is the kernel info inside the Linux kernel debug image.
+After that, connect to KGTP following the way in HOWTO#Make_GDB_connect_to_gtp connect to KGTP and print linux_banner again.
+
+(gdb) target remote /sys/kernel/debug/gtp
+Remote debugging using /sys/kernel/debug/gtp
+0x0000000000000000 in irq_stack_union ()
+(gdb) p linux_banner
+$2 = "Linux version 3.4.0-rc4+ (teawater@teawater-Precision-M4600) (gcc version 4.6.3 (GCC) ) #3 SMP Tue Apr 24 13:29:05 CST 2012\n"
+This linux_banner is the kernel info that Linux kernel that KGTP is tracing. If it is same with the prev kernel info, the Linux kernel debug image is right.
+
+Handle the issue that Linux kernel debug image's address info is not same with Linux kernel when it running
+In X86_32, you will found that the Linux kernel debug image's address info is not same with Linux kernel when it running through the ways in HOWTO#Make_sure_current_Linux_kernel_debug_image_is_right. And you determine the Linux kernel debug image is right.
+This issue is because:
+
+Processor type and features  --->
+        (0x1000000) Physical address where the kernel is loaded
+        (0x100000) Alignment value to which kernel should be aligned
+The values of these two options are different. Please note that the "Physical address where the kernel is loaded" is not showed in config sometimes. You can get its value through search "PHYSICAL_START".
+
+You can handle this issue through change "Alignment value to which kernel should be aligned" same with "Physical address where the kernel is loaded".
+This issue doesn't affect X86_64.
+
+Get KGTP
+Get KGTP through http
+Please goto http://code.google.com/p/kgtp/downloads/list OR UPDATE to download the package.
+
+Get KGTP through svn
+Following command will get the last release version of KGTP:
+
+svn checkout http://kgtp.googlecode.com/svn/tags/kgtp/
+
+Following command will get all the files about KGTP:
+
+svn checkout http://kgtp.googlecode.com/svn/ kgtp-read-only
+kgtp-read-only/tags/ Present for each release of KGTP.
+kgtp-read-only/trunk/ Present for the main trunk of KGTP.
+
+Config KGTP
+Following part is the default config of KGTP inside the Makefile. With this config, KGTP will build together with current kernel that running on this machine.
+
+KERNELDIR := /lib/modules/`uname -r`/build
+CROSS_COMPILE :=
+KERELDIR is set to the directory which holds the kernel you want to build for. By default, it is set to the kernel that you are running.
+Please note that this directory should be Linux kernel build directory or linux-headers directory but not the source directory but not the Linux kernel source directory. And the Linux kernel build directory should be used after build successful.
+CROSS_COMPILE is set to the prefix name of compiler that you want to build KGTP. Empty to compile with your default compiler.
+ARCH is the architecture.
+
+Or you can choose which kernel you want build with and which compiler you want use by change Makefile.
+For example:
+
+KERNELDIR := /home/teawater/kernel/bamd64
+CROSS_COMPILE :=x86_64-glibc_std-
+ARCH := x86_64
+KERNELDIR is set to /home/teawater/kernel/bamd64. Compiler will use x86_64-glibc_std-gcc.
+
+Compile KGTP
+Normal compile
+cd kgtp/
+make
+In some build environment (for example Android) will get some error with user space program getmod or getframe. Please ignore this error and use the gtp.ko in this directory.
+If you get error message "/usr/bin/ld: cannot find -lc" in Fedora, please use following command handle it.
+
+sudo yum install glibc-static
+Compile KGTP with some special config
+Most of time, KGTP can auto select right options to build with Various versions of Linux kernel.
+But if you want config special options with yourself, you can read following part:
+With this option, KGTP will not auto select any build options.
+
+make AUTO=0
+With this option, KGTP will use simple frame instead of KGTP ring buffer.
+The simple frame doesn't support gtpframe_pipe. It just for debug KGTP.
+
+make AUTO=0 FRAME_SIMPLE=1
+With this option, $clock will return rdtsc value instead of local_clock.
+
+make AUTO=0 CLOCK_CYCLE=1
+With this option, KGTP will use procfs instead of debugfs.
+
+make AUTO=0 USE_PROC=1
+The options can use together, for example:
+
+make AUTO=0 FRAME_SIMPLE=1 CLOCK_CYCLE=1
+Install and uninstall KGTP
+KGTP don't need to be install because it can insmod directly inside its directory (See HOWTO#Exec_it). But if you need, you can install it to your system.
+Install:
+
+cd kgtp/
+sudo make install
+Uninstall:
+
+cd kgtp/
+sudo make uninstall
+Use KGTP with DKMS
+You can use KGTP with DKMS if you want it.
+Following commands will copy the files of KGTP to the directory that DKMS need.
+
+cd kgtp/
+sudo make dkms
+Then you can use DKMS commands to control KGTP. Please goto http://linux.dell.com/dkms/manpage.html to see how to use DKMS.
+
+Use KGTP patch for Linux kernel
+Most of time, you don't need KGTP patch because KGTP can build as a LKM and very easy to use. But to help some people include KGTP to them special Linux Kernel tree, KGTP supply patches for Linux kernel.
+In the KGTP directory:
+gtp_3.7_to_upstream.patch is the patch for Linux kernel from 3.7 to upstream.
+gtp_3.0_to_3.6.patch is the patch for Linux kernel from 3.0 to 3.6.
+gtp_2.6.39.patch is the patch for Linux kernel 2.6.39.
+gtp_2.6.33_to_2.6.38.patch is the patch for Linux kernel from 2.6.33 to 2.6.38.
+gtp_2.6.20_to_2.6.32.patch is the patch for Linux kernel from 2.6.20 to 2.6.32.
+gtp_older_to_2.6.19.patch is the patch for Linux kernel 2.6.19 and older version.
+Install GDB for KGTP
+The GDB that older than 7.6 have some bugs of tracepoint. And some functions of GDB are not very well.
+So if your GDB is older than 7.6 please go to https://code.google.com/p/gdbt/ to get howto install GDB for KGTP. It supplies sources of UBUBTU, CentOS, Fedora, Mandriva, RHEL, SLE, openSUSE. Also have static binary for others.
+If you have issue about GDB please get help according to HOWTO#Report_issues_about_KGTP.
+
+How to let GDB connect to KGTP
+To use KGTP function need let GDB connect to KGTP first.
+
+Normal Linux
+Insmod the KGTP module
+If you have installed KGTP in your system, you can:
+
+sudo modprobe gtp
+Or you can use the kgtp module in the directory.
+
+cd kgtp/
+sudo insmod gtp.ko
+Handle the issue that cannot find "/sys/kernel/debug/gtp"
+If you got this issue, please make sure "Debug Filesystem" is opened in your kernel config first. If_your_system_use_the_Linux_kernel_that_is_built_by_yourself?
+If it is opened, please use following command mount sysfs.
+
+sudo mount -t sysfs none /sys/
+Maybe you will got some error for examle "sysfs is already mounted on /sys". Please ignore it. 
+please use following command mount debugfs.
+
+mount -t debugfs none /sys/kernel/debug/
+Then you can find "/sys/kernel/debug/gtp".
+
+Make GDB connect to gtp
+Please note that let GDB open a right vmlinux file is very important. Please goto #Make_sure_current_Linux_kernel_debug_image_is_right get how to do it.
+
+GDB on the current machine
+sudo gdb ./vmlinux
+(gdb) target remote /sys/kernel/debug/gtp
+Remote debugging using /sys/kernel/debug/gtp
+0x0000000000000000 in ?? ()
+After that, you can begin to use GDB command trace and debug the Linux Kernel.
+
+GDB on remote machine
+Use nc map the KGTP interface to port 1024.
+
+sudo su
+nc -l 1234 </sys/kernel/debug/gtp >/sys/kernel/debug/gtp
+#(nc -l -p 1234 </sys/kernel/debug/gtp >/sys/kernel/debug/gtp for old version netcat.)
+After that, nc will hang there to wait connection.
+Let gdb connect to the port 1234.
+
+gdb-release ./vmlinux
+(gdb) target remote xxx.xxx.xxx.xxx:1234
+After that, you can begin to use GDB command trace and debug the Linux Kernel.
+
+Android
+This video introduces use GDB connect to the KGTP in the Android, Please goto http://youtu.be/_UGN2j8Ctg0 or http://www.tudou.com/programs/view/FjkQ6HhPnfE/ to see it.
+
+Insmod the KGTP module
+First, make sure ADB has connected with Android.
+Second, copy KGTP module to Android.
+
+sudo adb push gtp.ko /
+Directory "/" may be read-only. You can choice other directory or use command "sudo adb shell mount -o rw,remount /" remount the directory to can write.
+Third, insmod the module.
+
+adb shell insmod /gtp.ko
+Handle the issue that cannot find "/sys/kernel/debug/gtp"
+If you got this issue, please make sure "Debug Filesystem" is opened in your kernel config first. If_your_system_use_the_Linux_kernel_that_is_built_by_yourself?
+If it is opened, please use following command mount sysfs.
+
+sudo adb shell mount -t sysfs none /sys/
+Maybe you will got some error for examle "Device or resource busy". Please ignore it. 
+please use following command mount debugfs.
+
+sudo adb shell mount -t debugfs none /sys/kernel/debug/
+Then you can find "/sys/kernel/debug/gtp".
+
+GDB connect to the KGTP
+Use nc map the KGTP interface to port 1024.
+
+adb forward tcp:1234 tcp:1234
+adb shell "nc -l -p 1234 </sys/kernel/debug/gtp >/sys/kernel/debug/gtp"
+#(adb shell "nc -l 1234 </sys/kernel/debug/gtp >/sys/kernel/debug/gtp" for new version netcat.)
+After that, nc will hang there to wait connection.
+Let gdb connect to the port 1234.
+
+gdb-release ./vmlinux
+(gdb) target remote :1234
+After that, you can begin to use GDB command trace and debug the Linux Kernel.
+
+Add module symbols to GDB
+Sometimes you need to add a Linux kernel module's symbols to GDB to debug it.
+Add symbols with hand is not very easy, so KGTP package include an GDB python script "getmod.py" and a program "getmod" can help you.
+
+How to use getmod
+"getmod" is written by C so you can use it anywhere even if in an embedded environment.
+For example:
+
+#Following command save Linux Kernel module info to the file /tmp/mi in GDB
+#command format.
+sudo getmod >/tmp/mi
+#in gdb part:
+(gdb) source /tmp/mi
+add symbol table from file "/lib/modules/2.6.39-rc5+/kernel/fs/nls/nls_iso8859-1.ko" at
+        .text_addr = 0xf80de000
+        .note.gnu.build-id_addr = 0xf80de088
+        .exit.text_addr = 0xf80de074
+        .init.text_addr = 0xf8118000
+        .rodata.str1.1_addr = 0xf80de0ac
+        .rodata_addr = 0xf80de0c0
+        __mcount_loc_addr = 0xf80de9c0
+        .data_addr = 0xf80de9e0
+        .gnu.linkonce.this_module_addr = 0xf80dea00
+#After this GDB command, all the Linux Kernel module info is loaded into GDB.
+If you use remote debug or offline debug, maybe you need change the base directory. Following example is for it.
+
+#/lib/modules/2.6.39-rc5+/kernel is replaced to sudo ./getmod -r /home/teawater/kernel/b26
+sudo ./getmod -r /home/teawater/kernel/b26 >~/tmp/mi
+How to use getmod.py
+Please note that static build GDB that download from https://code.google.com/p/gdbt/ cannot use getmod.py.
+Connect to KGTP before use the getmod.py.
+
+(gdb) source ~/kgtp/getmod.py
+Then this script will auto load the Linux kernel module's symbols to GDB.
+
+Howto use GDB control KGTP trace and debug Linux kernel
+Direct access the current value in normal mode
+After GDB connect to KGTP, if it doesn't select any a entry of trace frame bufffer with GDB command "tfind", GDB in the normal mode. Then you can direct access the current value of memory (Linux kernel or the user space program) and the trace state variables without stop anything.
+If you have selected a trace frame entry, use GDB command "tfind -1" to return to normal mode. Please goto #Use_tfind_select_the_entry_inside_the_trace_frame_info get more info about GDB command "tfind".
+
+The memory of Linux kernel
+For example, you can access to "jiffies_64" with following command:
+
+(gdb) p jiffies_64
+Or you can access to the first entry of "static LIST_HEAD(modules)" with following command:
+
+(gdb) p *((struct module *)((char *)modules->next - ((size_t) &(((struct module *)0)->list))))
+Or you can access to the CPU0 memory info of "DEFINE_PER_CPU(struct device *, mce_device);":`
+
+p *(struct device *)(__per_cpu_offset[0]+(uint64_t)(&mce_device))
+If you want show more than one variables with one GDB command, please use following example:
+
+(gdb) printf "%4d %4d %4d %4d %4d %4d %18d %lu\n", this_rq->cpu, this_rq->nr_running, this_rq->nr_uninterruptible, nr_active, calc_load_tasks->counter, this_rq->calc_load_active, delta, this_rq->calc_load_update
+2 1 0 0 0 0 673538312 717077240
+the memory of the user space program
+KGTP can read memory directly without stop this user space program. For example:
+
+#Connect to KGTP(it is different with the way that is introduced in before)
+(gdb) target extended-remote /sys/kernel/debug/gtp
+#Add a new inferior to parse info of the user space program.
+(gdb) add-inferior
+Added inferior 2
+#Switch to this inferior
+(gdb) inferior 2
+[Switching to inferior 2 [<null>] (<noexec>)]
+#Load the symbol of the program this you want to read
+(gdb) file ~/kernel/svn/bak/a.out
+Reading symbols from /home/teawater/kernel/svn/bak/a.out...done.
+#Attach to the program (it will not stop the program).
+(gdb) attach 10039
+Attaching to program: /home/teawater/kernel/svn/bak/a.out, Remote target
+Reading symbols from /lib/x86_64-linux-gnu/libc.so.6...(no debugging symbols found)...done.
+Loaded symbols for /lib/x86_64-linux-gnu/libc.so.6
+Reading symbols from /lib64/ld-linux-x86-64.so.2...(no debugging symbols found)...done.
+Loaded symbols for /lib64/ld-linux-x86-64.so.2
+0x0000000000000000 in ?? ()
+#Then you can read the value of this program.
+(gdb) p c
+$3 = -1222013392
+(gdb) p c
+$4 = -590910451
+In this example, I used some multiple Inferiors commands. Please goto http://sourceware.org/gdb/current/onlinedocs/gdb/Inferiors-and-Programs.html get more info about it.
+
+the trace state variables
+You can access value of TSV with the command that same with access memory.
+Please goto HOWTO#How_to_use_trace_state_variables get more info about TSV.
+
+GDB tracepoint
+Tracepoint is that GDB define some addresses and some actions and put them to the target (KGTP). After tracepoint start, , KGTP will do these actions (Some of them will collect data and save them to tracepoint frame buffer) when Linux kernel execution to there addresses. After that, Linux kernel will keep execution.
+KGTP supply some interfaces that GDB or other programe can take the data of tracepoint frame buffer out to parse.
+About these interfaces, this doc have introduced "/sys/kernel/debug/gtp". And will introduce "/sys/kernel/debug/gtpframe" and "/sys/kernel/debug/gtpframe_pipe" later.
+
+Doc of GDB tracepoint in http://sourceware.org/gdb/current/onlinedocs/gdb/Tracepoints.html.
+
+set tracepoint
+The trace command is very similar to the break command. Its argument location can be a source line, a function name, or an address in the target program. The trace command defines a tracepoint, which is a address or some addresses that KGTP do some actions in it.
+Here are some examples of using the trace command:
+
+(gdb) trace foo.c:121    // a source file and line number
+
+(gdb) trace +2           // 2 lines forward
+
+(gdb) trace my_function  // first source line of function
+
+(gdb) trace *my_function // EXACT start address of function
+
+(gdb) trace *0x2117c4    // an address
+Howto handle the function is there but set tracepoint on it got fail
+GCC will inline some static function to increase the performance. You cannot set tracepoint on the function name because object file doesn't have symbol of inline function.
+You can use "trace filename:line" to set tracepoint on it.
+
+How to set tracepoint condition
+http://sourceware.org/gdb/current/onlinedocs/gdb/Tracepoint-Conditions.html
+Like breakpoints, we can set conditions on tracepoints. The speed of tracepoints is faster than breakpoints because KGTP can do all the condition checks.
+For example:
+
+(gdb) trace handle_irq if (irq == 47)
+This action of tracepoint 1 will work only when irq number is 47.
+
+And you can use GDB command "condition" to specify the condition of a tracepoint. GDB command "condition N COND" will specify tracepoint number N to trace only if COND is true.
+For example:
+
+(gdb) trace handle_irq
+(gdb) condition 1 (irq == 47)
+GDB command "info tracepoint" will show the ID of the tracepoint.
+
+Value of $bpnum is the last ID of GDB tracepoint. Then you can use GDB command "condtion" set the condition of last tracepoint without get its ID. For example:
+
+(gdb) trace handle_irq
+(gdb) condition $bpnum (irq == 47)
+How to handle error "Unsupported operator (null) (52) in expression."
+If you use condition about string, you will got this error when you call "tstart".
+To handle it, you can convent the char to int to handle this issue, for example:
+
+(gdb) p/x 'A'
+$4 = 0x41
+(gdb) condition 1 (buf[0] == 0x41)
+actions [num]
+This command will prompt for a list of actions to be taken when the tracepoint is hit. If the tracepoint number num is not specified, this command sets the actions for the one that was most recently defined (so that you can define a tracepoint and then say actions without bothering about its number). You specify the actions themselves on the following lines, one action at a time, and terminate the actions list with a line containing just end. So far, the only defined actions are collect, teval, and while-stepping.
+
+collect expr1, expr2, ...
+Collect values of the given expressions when the tracepoint is hit. This command accepts a comma-separated list of any valid expressions. In addition to global, static, or local variables, the following special arguments are supported:
+
+$regs   Collect all registers. 
+$args   Collect all function arguments. 
+$locals Collect all local variables. 
+Please note that collect an pointer (collect ptr) will just collect the address of this pointer. Add a * before ptr will make action collect the data that pointer point to(collect *ptr).
+
+teval expr1, expr2, ...
+Evaluate the given expressions when the tracepoint is hit. This command accepts a comma-separated list of expressions. The results are discarded, so this is mainly useful for assigning values to trace state variables (see HOWTO#Simple_trace_state_variables) without adding those values to the trace buffer, as would be the case if the collect action were used.
+
+while-stepping n
+Please goto #Use_while-stepping_let_Linux_kernel_do_single_step see howto use it.
+
+Start and stop the tracepoint
+Tracepoint will exec actions only when it is starting use this GDB command:
+
+(gdb) tstart
+It will stop by this GDB command:
+
+(gdb) tstop
+Enable and disable the tracepoint
+Like breakpoint, tracepoint can be control by GDB commands "enable" and "disable". But please note that it only useful when tracepoint stop.
+
+Use tfind select the entry inside the trace frame info
+GDB command "tfind" is used to select a entry of trace frame bufffer when tracepoint stop.
+When GDB inside "tfind" mode, it will just show the values of this entry that the tracepoint action collect. So it will output some error when print some values that action doesn't collect for example the argument of function. That is not a bug, please don't worry about it.
+Use "tfind" again will select next entry. "tfind id" will select entry id.
+To return to normal mode(HOWTO#Direct_access_the_current_value_in_normal_mode), please use GDB command "tfind -1". Please goto http://sourceware.org/gdb/current/onlinedocs/gdb/tfind.html get more info about it.
+
+How to handle error "No such file or directory."
+When GDB cannot find the source code of Linux kernel, it will show this error message. For example:
+
+(gdb) tfind 
+Found trace frame 1, tracepoint 1
+#0  vfs_read (file=0xffff8801c36e6400, buf=0x7fff51a8f110 <Address 0x7fff51a8f110 out of bounds>, count=16, 
+    pos=0xffff8801761dff48) at /build/buildd/linux-3.2.0/fs/read_write.c:365
+365     /build/buildd/linux-3.2.0/fs/read_write.c: No such file or directory.
+You can use GDB command "set substitute-path" to handle it. The prev example, the Linux kernel source is in "/build/buildd/test/linux-3.2.0/". But vmlinux let GDB find Linux kernel source in "/build/buildd/linux-3.2.0/". You can handle it with:
+
+(gdb) set substitute-path /build/buildd/linux-3.2.0/ /build/buildd/test/linux-3.2.0/
+(gdb) tfind 
+Found trace frame 1, tracepoint 1
+#0  vfs_read (file=0xffff8801c36e6400, buf=0x7fff51a8f110 <Address 0x7fff51a8f110 out of bounds>, count=16, 
+    pos=0xffff8801761dff48) at /build/buildd/linux-3.2.0/fs/read_write.c:365
+365     {
+GDB have some other commands to handle the source code issue. Please goto http://sourceware.org/gdb/current/onlinedocs/gdb/Source-Path.html get the introduce about them.
+
+Save the trace frame info to a file
+/sys/kernel/debug/gtpframe supplies trace frame in tfile format (GDB can parse it) when KGTP is stop.
+Please note that some "cp" cannot handle it very well, please use "cat /sys/kernel/debug/gtpframe > ./gtpframe" to copy it.
+You can open file gtpframe when you want:
+
+(gdb) target tfile ./gtpframe
+Tracepoint 1 at 0xffffffff8114f3dc: file /home/teawater/kernel/linux-2.6/fs/readdir.c, line 24.
+Created tracepoint 1 for target's tracepoint 1 at 0xffffffff8114f3c0.
+(gdb) tfind 
+Found trace frame 0, tracepoint 1
+#0  vfs_readdir (file=0xffff880036e8f300, filler=0xffffffff8114f240 <filldir>, buf=0xffff880001e5bf38)
+    at /home/teawater/kernel/linux-2.6/fs/readdir.c:24
+24      {
+Show and save the tracepoint
+You can use GDB command "info tracepoints" to show all the tracepoints.
+You can use GDB command "save tracepoints filename" to save the commands that setup the tracepoints and actions into file filename. Then you use use GDB commands "source filename" to setup this tracepints again.
+
+Delete tracepoint
+GDB command "delete id" will delete tracepoint id. If "delete" without argument, it will delete all the tracepoint.
+
+Use tracepoint get register info from a point of kernel
+The following is an example that records the value of all registers when "vfs_readdir" is called.
+
+(gdb) target remote /sys/kernel/debug/gtp
+(gdb) trace vfs_readdir
+Tracepoint 1 at 0xc01a1ac0: file
+/home/teawater/kernel/linux-2.6/fs/readdir.c, line 23.
+(gdb) actions
+Enter actions for tracepoint 1, one per line.
+End with a line saying just "end".
+>collect $reg
+>end
+(gdb) tstart
+(gdb) shell ls
+(gdb) tstop
+(gdb) tfind
+Found trace frame 0, tracepoint 1
+#0  0xc01a1ac1 in vfs_readdir (file=0xc5528d00, filler=0xc01a1900 <filldir64>,
+   buf=0xc0d09f90) at /home/teawater/kernel/linux-2.6/fs/readdir.c:23
+23      /home/teawater/kernel/linux-2.6/fs/readdir.c: No such file or directory.
+       in /home/teawater/kernel/linux-2.6/fs/readdir.c
+(gdb) info reg
+eax            0xc5528d00       -984445696
+ecx            0xc0d09f90       -1060069488
+edx            0xc01a1900       -1072031488
+ebx            0xfffffff7       -9
+esp            0xc0d09f8c       0xc0d09f8c
+ebp            0x0      0x0
+esi            0x8061480        134616192
+edi            0xc5528d00       -984445696
+eip            0xc01a1ac1       0xc01a1ac1 <vfs_readdir+1>
+eflags         0x286    [ PF SF IF ]
+cs             0x60     96
+ss             0x8061480        134616192
+ds             0x7b     123
+es             0x7b     123
+fs             0x0      0
+gs             0x0      0
+(gdb) tfind
+Found trace frame 1, tracepoint 1
+0xc01a1ac1      23      in /home/teawater/kernel/linux-2.6/fs/readdir.c
+(gdb) info reg
+eax            0xc5528d00       -984445696
+ecx            0xc0d09f90       -1060069488
+edx            0xc01a1900       -1072031488
+ebx            0xfffffff7       -9
+esp            0xc0d09f8c       0xc0d09f8c
+ebp            0x0      0x0
+esi            0x8061480        134616192
+edi            0xc5528d00       -984445696
+eip            0xc01a1ac1       0xc01a1ac1 <vfs_readdir+1>
+eflags         0x286    [ PF SF IF ]
+cs             0x60     96
+ss             0x8061480        134616192
+ds             0x7b     123
+es             0x7b     123
+fs             0x0      0
+gs             0x0      0
+Use tracepoint get the value of variable from a point of kernel
+The following is an example that records the value of "jiffies_64" when the function "vfs_readdir" is called:
+
+(gdb) target remote /sys/kernel/debug/gtp
+(gdb) trace vfs_readdir 
+Tracepoint 1 at 0xc01ed740: file /home/teawater/kernel/linux-2.6/fs/readdir.c, line 24.
+(gdb) actions 
+Enter actions for tracepoint 1, one per line.
+End with a line saying just "end".
+>collect jiffies_64
+>collect file->f_path.dentry->d_iname
+>end
+(gdb) tstart 
+(gdb) shell ls
+arch    drivers   include  kernel    mm               Module.symvers  security  System.map  virt
+block   firmware  init     lib       modules.builtin  net             sound     t           vmlinux
+crypto  fs        ipc      Makefile  modules.order    scripts         source    usr         vmlinux.o
+(gdb) tstop 
+(gdb) tfind 
+Found trace frame 0, tracepoint 1
+#0  0xc01ed741 in vfs_readdir (file=0xf4063000, filler=0xc01ed580 <filldir64>, buf=0xd6dfdf90)
+    at /home/teawater/kernel/linux-2.6/fs/readdir.c:24
+24      {
+(gdb) p jiffies_64
+$1 = 4297248706
+(gdb) p file->f_path.dentry->d_iname
+$1 = "b26", '\000' <repeats 28 times>
+Show all the traced data of current frame
+After use "tfind" select an entry, you can use "tdump" to do it.
+
+(gdb) tdump 
+Data collected at tracepoint 1, trace frame 0:
+$cr = void
+file->f_path.dentry->d_iname = "gtp\000.google.chrome.g05ZYO\000\235\337\000\000\000\000\200\067k\364\200\067", <incomplete sequence \364>
+jiffies_64 = 4319751455
+Get status of tracepoint
+Please use GDB command "tstatus".
+
+Set the trace buffer into a circular buffer
+http://sourceware.org/gdb/current/onlinedocs/gdb/Starting-and-Stopping-Trace-Experiments.html
+The frame buffer is not a circular buffer by default. When the buffer is full, the tracepoint will stop.
+Following command will set frame buffer to a circular buffer. When the buffer is full, it will auto discard traceframes (oldest first) and keep trace.
+
+(gdb) set circular-trace-buffer on
+Do not stop tracepoint when the GDB disconnects
+http://sourceware.org/gdb/current/onlinedocs/gdb/Starting-and-Stopping-Trace-Experiments.html
+KGTP will stop tracepoint and delete the trace frame when GDB disconnects with it by default.
+Following command will open the KGTP disconnect-trace. After that, when GDB disconnects with KGTP, KGTP will not stop tracepoint. And after GDB reconnects to KGTP, it can keep control of KGTP like nothing happened.
+
+(gdb) set disconnected-tracing on
+kprobes-optimization and the execution speed of tracepoint
+The tracepoint is execution together with Linux kernel. So it speed will affect the speed the system.
+The KGTP tracepoint base on Linux kernel kprobe. Because the normal kprobe base on breakpoint instruction, so it is not very fast.
+
+But if arch of kernel is X86_64 or X86_32 and kernel config didn't open "Preemptible Kernel" (PREEMPT), the kprobe is speed up by kprobes-optimization (CONFIG_OPTPROBES) that make kprobe very fast.
+To make sure about that, you can use following command in terminal:
+
+sysctl -A | grep kprobe
+debug.kprobes-optimization = 1
+That means that your kernel support kprobes-optimization.
+Please note that some KGTP functions will make this tracepoint use simple kprobe even if this Kernel support kprobes-optimization. This doc will add note when introduce these functions. Please avoid using them when you really care about the tracepoint speed.
+
+How to use trace state variables
+http://sourceware.org/gdb/current/onlinedocs/gdb/Trace-State-Variables.html
+Trace state variable is referred to as the TSV.
+TSV can be accessed in tracepoint action and condition or direct access by GDB command.
+Please note that just GDB 7.2.1 and later versions support use trace state variables directly, the old version of GDB can show the value of trace state variables through command "info tvariables".
+
+Simple trace state variables
+Define a trace state variable $c.
+
+(gdb) tvariable $c
+Trace state variable $c is created with initial value 0. The following action uses $c to count how many irqs happened in the kernel.
+
+(gdb) target remote /sys/kernel/debug/gtp
+(gdb) trace handle_irq
+(gdb) actions 
+Enter actions for tracepoint 3, one per line.
+End with a line saying just "end".
+>collect $c     #Save current value of $c to the trace frame buffer.
+>teval $c=$c+1  #Increase the $c.
+>end
+Also, you can set a value of variable to trace state variable, but don't forget covert variable to "uint64_t".
+
+>teval $c=(uint64_t)a
+You can get the current value of $c while the trace is running or stopped.
+
+(gdb) tstart
+(gdb) info tvariables
+$c              0           31554
+(gdb) p $c
+$5 = 33652
+(gdb) tstop
+(gdb) p $c
+$9 = 105559
+When using tfind, you can parse the trace frame buffer. If the value of a trace state variable is collected, you can parse it out.
+
+(gdb) tstop 
+(gdb) tfind 
+(gdb) info tvariables
+$c              0           0
+(gdb) p $c
+$6 = 0
+(gdb) tfind 100
+(gdb) p $c
+$7 = 100
+If need, the tracepoint action that access the simple trace state variables will auto lock a spin lock for trace state variables. So it can handle race condition issue about trace state variables.
+The following example is OK even if it running a machine that have more than one CPU.
+
+>teval $c=$c+1
+Per_cpu trace state variables
+Per_cpu trace state variables are special simple trace state variables.
+When tracepoint action access to it, it will access to this CPU special trace state variables.
+It have 2 advantages:
+1. The tracepoint actions that access to per_cpu trace state variables don't have the race conditon issue. So it don't need lock the spin lock for trace state variables. It is faster than simple trace state variables on multi-core machine. 
+2. Write the action that count some CPU special thing with it is easier than simple trace state variables.
+
+How to define
+Per_cpu trace state variables have two types:
+
+Local CPU variables
+"per_cpu_"+string
+or
+
+"p_"+string
+For example:
+
+(gdb) tvariable $p_count
+When access this trace state variable in tracepoint actions, it will return the variable's value of CPU that this tracepoint actions running on.
+
+CPU id variables
+"per_cpu_"+string+CPU_id
+or
+
+"p_"+string+CPU_id
+For example:
+
+(gdb) tvariable $p_count0
+(gdb) tvariable $p_count1
+(gdb) tvariable $p_count2
+(gdb) tvariable $p_count3
+When access this trace state variable in tracepoint actions or GDB command line, it will return the variable's value of CPU CPU_id. 
+Follow example can auto define a CPU id variables for each CPU of this machine. (Please note that need let GDB connect to KGTP before use these commands.)
+
+(gdb) set $tmp=0
+(gdb) while $tmp<$cpu_number
+ >eval "tvariable $p_count%d",$tmp
+ >set $tmp=$tmp+1
+ >end
+Example 1
+This example define a tracepoint that count the times that call vfs_read of each CPU.
+
+tvariable $p_count
+set $tmp=0
+while $tmp<$cpu_number
+  eval "tvariable $p_count%d",$tmp
+  set $tmp=$tmp+1
+  end
+trace vfs_read
+actions
+  teval $p_count=$p_count+1
+  end
+Then you can show how many vfs_read in each CPU after "tstart":
+
+(gdb) p $p_count0
+$3 = 44802
+(gdb) p $p_count1
+$4 = 55272
+(gdb) p $p_count2
+$5 = 102085
+(gdb) p $p_count3
+Example 2
+This example record stack dump of the function that close IRQ longest time of each CPU.
+
+set pagination off
+
+tvariable $bt=1024
+tvariable $p_count
+tvariable $p_cc
+set $tmp=0
+while $tmp<$cpu_number
+eval "tvariable $p_cc%d",$tmp
+set $tmp=$tmp+1
+end
+
+tvariable $ignore_error=1
+
+trace arch_local_irq_disable
+  commands
+    teval $p_count=$clock
+  end
+trace arch_local_irq_enable if ($p_count && $p_cc < $clock - $p_count)
+  commands
+    teval $p_cc = $clock - $p_count
+    collect $bt
+    collect $p_cc
+    teval $p_count=0
+  end
+
+enable
+set pagination on
+Special trace state variables $current_task, $current_task_pid, $current_thread_info, $cpu_id, $dump_stack, $printk_level, $printk_format, $printk_tmp ,$clock, $hardirq_count, $softirq_count and $irq_count
+KGTP special trace state variables $current_task, $current_thread_info, $cpu_id and $clock can very easy to access to some special value. You can see them when GDB connects to the KGTP. You can use them in tracepoint conditions or actions. 
+Access $current_task in tracepoint condition and action will get that returns of get_current().
+Access $current_task_pid in tracepoint condition and action will get that returns of get_current()->pid.
+Access $current_thread_info in tracepoint condition and action will get that returns of current_thread_info().
+Access $cpu_id in tracepoint condition and action will get that returns of smp_processor_id().
+Access $clock in tracepoint condition and action will get that returns of local_clock() that return the timestamp in nanoseconds.
+$rdtsc is only available on X86 and X86_64 architecture. Access it in anytime will get current value of TSC with instruction RDTSC.
+Access $hardirq_count in tracepoint condition and action will get that returns of hardirq_count().
+Access $softirq_count in tracepoint condition and action will get that returns of softirq_count().
+Access $irq_count in tracepoint condition and action will get that returns of irq_count().
+And KGTP has other special trace state variables $dump_stack, $printk_level, $printk_format and $printk_tmp. All of them output their values directly, as can be seen in HOWTO#Howto_let_tracepoint_output_value_directly.
+The following example counts in $c how many vfs_read calls that process 16663 does and collects the struct thread_info of current task:
+
+(gdb) target remote /sys/kernel/debug/gtp
+(gdb) trace vfs_read if (((struct task_struct *)$current_task)->pid == 16663)
+(gdb) tvariable $c
+(gdb) actions
+Enter actions for tracepoint 4, one per line.
+End with a line saying just "end".
+>teval $c=$c+1
+>collect (*(struct thread_info *)$current_thread_info)
+>end
+(gdb) tstart 
+(gdb) info tvariables 
+Name            Initial     Current     
+$c              0           184         
+$current_task   0           <unknown>   
+$current_thread_info 0           <unknown>   
+$cpu_id         0           <unknown>   
+(gdb) tstop
+(gdb) tfind
+(gdb) p *(struct thread_info *)$current_thread_info
+$10 = {task = 0xf0ac6580, exec_domain = 0xc07b1400, flags = 0, status = 0, cpu = 1, preempt_count = 2, addr_limit = {
+    seg = 4294967295}, restart_block = {fn = 0xc0159fb0 <do_no_restart_syscall>, {{arg0 = 138300720, arg1 = 11, 
+        arg2 = 1, arg3 = 78}, futex = {uaddr = 0x83e4d30, val = 11, flags = 1, bitset = 78, time = 977063750, 
+        uaddr2 = 0x0}, nanosleep = {index = 138300720, rmtp = 0xb, expires = 335007449089}, poll = {
+        ufds = 0x83e4d30, nfds = 11, has_timeout = 1, tv_sec = 78, tv_nsec = 977063750}}}, 
+  sysenter_return = 0xb77ce424, previous_esp = 0, supervisor_stack = 0xef340044 "", uaccess_err = 0}
+Another example shows how much sys_read() executes in each CPU.
+
+(gdb) tvariable $c0
+(gdb) tvariable $c1
+(gdb) trace sys_read 
+(gdb) condition $bpnum ($cpu_id == 0)
+(gdb) actions
+>teval $c0=$c0+1
+>end
+(gdb) trace sys_read 
+(gdb) condition $bpnum ($cpu_id == 1)
+(gdb) actions
+>teval $c1=$c1+1
+>end
+(gdb) info tvariables 
+Name            Initial     Current     
+$current_task   0           <unknown>   
+$cpu_id         0           <unknown>   
+$c0             0           3255        
+$c1             0           1904     
+sys_read() execute 3255 times in cpu0 and 1904 times in cpu1. Please note that this example just to howto use $cpu_id. Actially, this example use per_cpu trace state variables is better.
+
+Special trace state variable $self_trace
+$self_trace is different with the special trace state variables in the previous section. It is used to control the behavior of tracepoint.
+In default, when tracepoint is triggered, the actions will not execute if the current_task is the a KGTP self process (GDB, netcat, getframe or some others process that access to the interface of KGTP).
+If you want tracepoint actions execute with any task, please include a command access to the $self_trace in the actions i.e. add following command to the actions:
+
+>teval $self_trace=0
+Trace the function return with $kret
+Sometime, set the tracepoint to the end of function is hard because the Kernel is compiled with optimization. At this time, you can get help from $kret.
+$kret is a special trace state variable like $self_trace. When you set value of it inside the action of tracepoint, this tracepoint be set with kretprobe instead of kprobe. Then it can trace the end of this function.
+Please note that this tracepoint must set in the first address of the function in format "function_name".
+
+Following part is an example:
+
+#"*(function_name)" format can make certain that GDB send the first address of function to KGTP.
+(gdb) trace *vfs_read
+(gdb) actions
+>teval $kret=0
+#Following part you can set commands that you want.
+Use $ignore_error and $last_errno to ignore the error of tstart
+If KGTP got any error of tstart, this command will get fail.
+But sometime we need ignore this error and let KGTP keep work. For example: If you set tracepoint on the inline function spin_lock. This tracepoint will be set to a lot of addresses that some of them cannot be set kprobe. It will make tstart get fail. You can use "$ignore_error" ignore this error.
+And the last error number will available in "$last_errno".
+
+(gdb) tvariable $ignore_error=1
+This command will open ignore.
+
+(gdb) tvariable $ignore_error=0
+This command will close ignore.
+
+Use $cooked_clock and $cooked_rdtsc the time without KGTP used
+Access these two trace state variables can get the time without KGTP used. Then we can get more close to really time that a part of code used even if the actions of tracepoint is very complex. They will be introduce in Cookbook (coming soon).
+
+Use $xtime_sec and $xtime_nsec get the timespec
+Access these two trace state variables will return the time of day in a timespec that use getnstimeofday.
+$xtime_sec will access to the second part of a timespec.
+$xtime_nsec will access to the nanosecond part of a timespec.
+
+Howto backtrace (stack dump)
+Each time your program performs a function call, information about the call is generated. That information includes the location of the call in your program, the arguments of the call, and the local variables of the function being called. The information is saved in a block of data called a stack frame. The stack frames are allocated in a region of memory called the call stack.
+
+Collect stack with $bt and use GDB command "backtrace"
+Because this way is faster (just collect the stack when trace) and parse out most of info inside the call stack (it can show all the stack info that I introduce). So I suggest you use this way to do the stack dump.
+First we need add the collect the stack command to the tracepoint action.
+The general collect the stack command in GDB tracepoint is: In x86_32, following command will collect 512 bytes of stack.
+>collect *(unsigned char *)$esp@512
+In x86_64, following command will collect 512 bytes of stack.
+>collect *(unsigned char *)$rsp@512
+In MIPS or ARM, following command will collect 512 bytes of stack.
+>collect *(unsigned char *)$sp@512
+These commands is so hard to remember, and the different arch need different command.
+KGTP have an special tracepoint trace state variable $bt. If tracepoint action access it, KGTP will auto collect the $bt size (default value is 512) stack. For example, this command will collect 512 bytes stack memory:
+
+>collect $bt
+If you want to change size of $bt, you can use following GDB command before "tstart":
+
+(gdb) tvariable $bt=1024
+Following part is an example about howto collect stack and howto use GDB parse it:
+
+(gdb) target remote /sys/kernel/debug/gtp
+(gdb) trace vfs_readdir
+Tracepoint 1 at 0xffffffff8118c300: file /home/teawater/kernel2/linux/fs/readdir.c, line 24.
+(gdb) actions 
+Enter actions for tracepoint 1, one per line.
+End with a line saying just "end".
+>collect $bt
+>end
+(gdb) tstart 
+(gdb) shell ls
+1      crypto    fs             include  kernel    mm               Module.symvers  security  System.map  vmlinux
+arch   drivers   hotcode.html   init     lib       modules.builtin  net             sound     usr         vmlinux.o
+block  firmware  hotcode.html~  ipc      Makefile  modules.order    scripts         source    virt
+(gdb) tstop 
+(gdb) tfind 
+Found trace frame 0, tracepoint 1
+#0  vfs_readdir (file=0xffff8800c5556d00, filler=0xffffffff8118c4b0 <filldir>, buf=0xffff880108709f40)
+    at /home/teawater/kernel2/linux/fs/readdir.c:24
+24      {
+(gdb) bt
+#0  vfs_readdir (file=0xffff8800c5556d00, filler=0xffffffff8118c4b0 <filldir>, buf=0xffff880108709f40)
+    at /home/teawater/kernel2/linux/fs/readdir.c:24
+#1  0xffffffff8118c689 in sys_getdents (fd=<optimized out>, dirent=0x1398c58, count=32768) at /home/teawater/kernel2/linux/fs/readdir.c:214
+#2  <signal handler called>
+#3  0x00007f00253848a5 in ?? ()
+#4  0x00003efd32cddfc9 in ?? ()
+#5  0x00002c15b7d04101 in ?? ()
+#6  0x000019c0c5704bf1 in ?? ()
+#7  0x0000000900000000 in ?? ()
+#8  0x000009988cc8d269 in ?? ()
+#9  0x000009988cc9b8d1 in ?? ()
+#10 0x0000000000000000 in ?? ()
+(gdb) up
+#1  0xffffffff8118c689 in sys_getdents (fd=<optimized out>, dirent=0x1398c58, count=32768) at /home/teawater/kernel2/linux/fs/readdir.c:214
+214             error = vfs_readdir(file, filldir, &buf);
+(gdb) p buf
+$1 = {current_dir = 0x1398c58, previous = 0x0, count = 32768, error = 0}
+(gdb) p error
+$3 = -9
+(gdb) frame 0
+#0  vfs_readdir (file=0xffff8800c5556d00, filler=0xffffffff8118c4b0 <filldir>, buf=0xffff880108709f40)
+    at /home/teawater/kernel2/linux/fs/readdir.c:24
+24      {
+From this example, we can see some GDB commands that parse the the call stack:
+bt is the alias of GDB commands backtrace that print a backtrace of the entire stack: one line per frame for all frames in the stack.
+up n is move n frames up the stack. For positive numbers n, this advances toward the outermost frame, to higher frame numbers, to frames that have existed longer. n defaults to one.
+down n is move n frames down the stack. For positive numbers n, this advances toward the innermost frame, to lower frame numbers, to frames that were created more recently. n defaults to one. You may abbreviate down as do. 
+frame n is select frame number n. Recall that frame zero is the innermost (currently executing) frame, frame one is the frame that called the innermost one, and so on. The highest-numbered frame is the one for main. 
+You can see that when you use up, down or frame to the different calll stack frame, you can output the value of the arguments and local variables of different call stack frame.
+To get the more info about howto use GDB parse the call stack, please see http://sourceware.org/gdb/current/onlinedocs/gdb/Stack.html
+Collect stack of current function's caller with $_ret
+If you just want to collect stack of current function's caller, please use $_ret.
+Please note that set the tracepoint that collect $_ret cannot in the first address of function.
+For example:
+
+(gdb) list vfs_read
+360     }
+361     
+362     EXPORT_SYMBOL(do_sync_read);
+363     
+364     ssize_t vfs_read(struct file *file, char __user *buf, size_t count, loff_t *pos)
+365     {
+366             ssize_t ret;
+367     
+368             if (!(file->f_mode & FMODE_READ))
+369                     return -EBADF;
+(gdb) trace 368
+Tracepoint 2 at 0xffffffff8117a244: file /home/teawater/kernel2/linux/fs/read_write.c, line 368.
+(gdb) actions 
+Enter actions for tracepoint 2, one per line.
+End with a line saying just "end".
+>collect $_ret
+>end
+(gdb) tstart 
+(gdb) tstop 
+(gdb) tfind 
+Found trace frame 0, tracepoint 2
+#0  vfs_read (file=0xffff880141c46000, buf=0x359bda0 <Address 0x359bda0 out of bounds>, count=8192, pos=0xffff88012fa49f48)
+    at /home/teawater/kernel2/linux/fs/read_write.c:368
+368             if (!(file->f_mode & FMODE_READ))
+(gdb) bt
+#0  vfs_read (file=0xffff880141c46000, buf=0x359bda0 <Address 0x359bda0 out of bounds>, count=8192, pos=0xffff88012fa49f48)
+    at /home/teawater/kernel2/linux/fs/read_write.c:368
+#1  0xffffffff8117a3ea in sys_read (fd=<optimized out>, buf=<unavailable>, count=<unavailable>)
+    at /home/teawater/kernel2/linux/fs/read_write.c:469
+Backtrace stopped: not enough registers or memory available to unwind further
+(gdb) up
+#1  0xffffffff8117a3ea in sys_read (fd=<optimized out>, buf=<unavailable>, count=<unavailable>)
+    at /home/teawater/kernel2/linux/fs/read_write.c:469
+469                     ret = vfs_read(file, buf, count, &pos);
+(gdb) p ret
+$2 = -9
+You see that the caller of function vfs_read is sys_read. And the local variable ret of sys_read is -9.
+
+Use $dump_stack to output stack dump through printk
+Because this way need parse the stack when tracing and call printk inside, so it will be slow, unsafe, unclear and cannot access a lot of info of call stack. So I suggest you use the prev way to do stack dump.
+KGTP has special trace state variable $dump_stack, "collect" it will let Linux Kernel output stack dump through printk.
+Following example lets Linux Kernel show the stack dump of vfs_readdir:
+
+target remote /sys/kernel/debug/gtp
+trace vfs_readdir
+  commands
+    collect $dump_stack
+  end
+Then your kernel will printk like:
+
+[22779.208064] gtp 1:Pid: 441, comm: python Not tainted 2.6.39-rc3+ #46
+[22779.208068] Call Trace:
+[22779.208072]  [<fe653cca>] gtp_get_var+0x4a/0xa0 [gtp]
+[22779.208076]  [<fe653d79>] gtp_collect_var+0x59/0xa0 [gtp]
+[22779.208080]  [<fe655974>] gtp_action_x+0x1bb4/0x1dc0 [gtp]
+[22779.208084]  [<c05b6408>] ? _raw_spin_unlock+0x18/0x40
+[22779.208088]  [<c023f152>] ? __find_get_block_slow+0xd2/0x160
+[22779.208091]  [<c01a8c56>] ? delayacct_end+0x96/0xb0
+[22779.208100]  [<c023f404>] ? __find_get_block+0x84/0x1d0
+[22779.208103]  [<c05b6408>] ? _raw_spin_unlock+0x18/0x40
+[22779.208106]  [<c02e0838>] ? find_revoke_record+0xa8/0xc0
+[22779.208109]  [<c02e0c45>] ? jbd2_journal_cancel_revoke+0xd5/0xe0
+[22779.208112]  [<c02db51f>] ? __jbd2_journal_temp_unlink_buffer+0x2f/0x110
+[22779.208115]  [<fe655c4c>] gtp_kp_pre_handler+0xcc/0x1c0 [gtp]
+[22779.208118]  [<c05b8a88>] kprobe_exceptions_notify+0x3d8/0x440
+[22779.208121]  [<c05b7d54>] ? hw_breakpoint_exceptions_notify+0x14/0x180
+[22779.208124]  [<c05b95eb>] ? sub_preempt_count+0x7b/0xb0
+[22779.208126]  [<c0227ac5>] ? vfs_readdir+0x15/0xb0
+[22779.208128]  [<c0227ac4>] ? vfs_readdir+0x14/0xb0
+[22779.208131]  [<c05b9743>] notifier_call_chain+0x43/0x60
+[22779.208134]  [<c05b9798>] __atomic_notifier_call_chain+0x38/0x50
+[22779.208137]  [<c05b97cf>] atomic_notifier_call_chain+0x1f/0x30
+[22779.208140]  [<c05b980d>] notify_die+0x2d/0x30
+[22779.208142]  [<c05b71c5>] do_int3+0x35/0xa0
+Howto let tracepoint output value directly
+In the previous parts, you may understand that to get a value from Linux kernel, you need to use a tracepoint "collect" action to save the value to the tracepoint frame and use the GDB command "tfind" to parse the value from the frame data.
+But we want get the value directly sometimes, so KGTP supports two ways to output values directly.
+
+Switch collect to output the value directly
+KGTP has special trace state variables $printk_level, $printk_format and $printk_tmp to support this function.
+$printk_level: if its value is 8 (this is the default value), "collect" action will save value to the tracepoint frame in the simple behavior.
+If its value is 0-7, "collect" will output the value through "printk" directly, and value will be the level of printk. The level is:
+
+0       KERN_EMERG      system is unusable
+1       KERN_ALERT      action must be taken immediately
+2       KERN_CRIT       critical conditions
+3       KERN_ERR        error conditions
+4       KERN_WARNING    warning conditions
+5       KERN_NOTICE     normal but significant condition
+6       KERN_INFO       informational
+7       KERN_DEBUG      debug-level messages
+$printk_format, collect printk will output value in the format that is set by it. The format is:
+
+0       This is the default value.
+        If the size of collect value is 1, 2, 4 or 8, it will be output as an unsigned decimal.
+        If not, it will be output as a hexadecimal string.
+1       Output value in signed decimal.
+2       Output value in unsigned decimal.
+3       Output value in unsigned hexadecimal.
+4       Output value as a string.
+5       Output value as a hexadecimal string.
+$printk_tmp, to output the value of global variable need set to it first.
+
+Following example shows a count number, pid, jiffies_64 and the file name that call vfs_readdir:
+
+(gdb) target remote /sys/kernel/debug/gtp
+(gdb) tvariable $c
+(gdb) trace vfs_readdir
+(gdb) actions
+>teval $printk_level=0
+>collect $c=$c+1
+>collect ((struct task_struct *)$current_task)->pid
+>collect $printk_tmp=jiffies_64
+>teval $printk_format=4
+>collect file->f_path.dentry->d_iname
+>end
+Then your kernel will printk like:
+
+gtp 1:$c=$c+1=41
+gtp 1:((struct task_struct *)$current_task)->pid=12085
+gtp 1:$printk_tmp=jiffies_64=4322021438
+gtp 1:file->f_path.dentry->d_iname=b26
+gtp 1:$c=$c+1=42
+gtp 1:((struct task_struct *)$current_task)->pid=12085
+gtp 1:$printk_tmp=jiffies_64=4322021438
+gtp 1:file->f_path.dentry->d_iname=b26
+"gtp 1" means that it was output by tracepoint 1.
+
+Howto use watch tracepoint control hardware breakpoints to record memory access
+Watch tracepoint can control hardware breakpoints to record the memory access through set some special trace state variables in its action.
+Please note that watch tracepoint is just support by X86 and X86_64 now. And dynamic watch tracepoint just can work OK in Linux 2.6.27 and newer version because Linux 2.6.26 and older version have some IPI issues on smp support.
+
+Trace state variables of watch tracepoint
+Name	Written by normal tracepoint	Read by normal tracepoint	Written by static watch tracepoint	Read by static watch tracepoint	Written by dynamic watch tracepoint	Read by dynamic watch tracepoint
+$watch_static	 Not support	 Not support	 If "teval $watch_static=1", then this tracepoint is static watch tracepoint.	 Not support	 If "teval $watch_static=1", then this tracepoint is static watch tracepoint.	 Not support
+$watch_set_id	 When this tracepoint want to setup a dynamic watch tracepoint, set a id of a dynamic watch tracepoint to $watch_set_id to point out which dynamic watch tracepoint you wan to setup.	 Not support	 Not support	 Not support	 Not support	 Not support
+$watch_set_addr	 When this tracepoint want to setup a dynamic watch tracepoint, set the address of a dynamic watch tracepoint to $watch_set_addr to point out which dynamic watch tracepoint you wan to setup.	 Not support	 Not support	 Not support	 Not support	 Not support
+$watch_type	 When this tracepoint want to setup a dynamic watch tracepoint, set the watch type of this dynamic watch tracepoint to $watch_type.
+0 is exec. 1 is write. 2 is read or write.	 Get the value that this tracepoint set to $watch_type.	 Set the type of this watch tracepoint.	 Get the type of this watch tracepoint.	 Set the default type of this watch tracepoint.	 Get the type of this watch tracepoint when it really exec.
+$watch_size	 When this tracepoint want to setup a dynamic watch tracepoint, set the watch size of this dynamic watch tracepoint to $watch_size.
+The size should be 1, 2, 4, 8.	 Get the value that this tracepoint set to $watch_size.	 Set the size of this watch tracepoint.	 Get the size of this watch tracepoint.	 Set the default size of this watch tracepoint.	 Get the size of this watch tracepoint when it really exec.
+$watch_start	 Set the address to a dynamic watch tracepoint(set by $watch_set_addr or $watch_set_id) and let it try to start work.	 Get the result of this start. (It will fail becasue X86 just have 4 hardware breakpoints.)
+Get 0 if success. If < 0 is the error id.	 Not support	 Not support	 Not support	 Not support
+$watch_stop	 Set a address to $watch_stop will let a dynamic watch tracepoint that watch in this address stop.	 Get the result of this stop.	 Not support	 Not support	 Not support	 Not support
+$watch_trace_num	 Not support	 Not support	 Not support	 Not support	 Not support	 The tracepoint number that setup this dynamic watch tracepoint.
+$watch_trace_addr	 Not support	 Not support	 Not support	 Not support	 Not support	 The tracepoint address that setup this dynamic watch tracepoint.
+$watch_addr	 Not support	 Not support	 Not support	 The address that this watch tracepoint is watching.	 Not support	 The address that this watch tracepoint is watching.
+$watch_val	 Not support	 Not support	 Not support	 The current value of the memory that this watch tracepoint is watching.	 Not support	 The current value of the memory that this watch tracepoint is watching.
+$watch_prev_val	 Not support	 Not support	 Not support	 The previous value of the memory that this watch tracepoint is watching.	 Not support	 The previous value of the memory that this watch tracepoint is watching.
+$watch_count	 Not support	 Not support	 Not support	 Not support	 Not support	 A special count for this watch tracepoint session.
+Static watch tracepoint
+You can use static watch tracepoint when you want watch value of a global variable or some memory that you can get its address directly. Following example is watch jiffies_64's write:
+
+#Static watch tracepoint get watch address from tracepoint address.
+trace *&jiffies_64
+  actions
+    #Set this watch tracepoint to static
+    teval $watch_static=1
+    #Watch memory write
+    teval $watch_type=1
+    teval $watch_size=8
+    collect $watch_val
+    collect $watch_prev_val
+    collect $bt
+  end
+Dynamic watch tracepoint
+If you want to watch value of a local variable or some memory that you just get get its address inside the function, you can use dynamic watch tracepoint. Following example is watch write of f->f_pos and f->f_op inside function get_empty_filp:
+
+trace *1
+  commands
+    teval $watch_static=0
+    teval $watch_type=1
+    teval $watch_size=8
+    collect $bt
+    collect $watch_addr
+    collect $watch_val
+    collect $watch_prev_val
+  end
+Define a dynamic watch tracepoint. The address "1" of it is not the address of memory that it will watch. It just help tracepoint that setup this dynamic watch tracepoint can find it.
+
+list get_empty_filp
+trace 133
+  commands
+    teval $watch_set_addr=1
+    teval $watch_size=4
+    teval $watch_start=&(f->f_pos)
+    teval $watch_size=8
+    teval $watch_start=&(f->f_op)
+  end
+Define a normal tracepoint that start to watch f->f_pos and f->f_op inside function get_empty_filp.
+
+trace file_sb_list_del
+  commands
+    teval $watch_stop=&(file->f_pos)
+    teval $watch_stop=&(file->f_op)
+  end
+Define a normal tracepoint that stop the tracepoint that watch file->f_pos and file->f_op.
+
+Use while-stepping let Linux kernel do single step
+Please note that while-stepping is just support by X86 and X86_64 now.
+Video about howto use while-stepping http://www.codepark.us/a/13.
+
+Howto use while-stepping
+while-stepping is a special tracepoint action that include some actions with it.
+When tracepoints that its actions include "while-stepping n" execute, it will do n times single steps and executes the actions of while-stepping. For example:
+
+trace vfs_read
+#Because single step will make system slow, so use passcount or condition to limit the execution times of tracepoint is better.
+passcount 1
+  commands
+    collect $bt
+    collect $step_count
+    #do 2000 times single steps.
+    while-stepping 2000
+      #Following part is actions of "while-stepping 2000".
+      #Because step maybe execute to other functions, so does not access local variables is better.
+      collect $bt
+      collect $step_count
+    end
+  end
+Please note that tracepoint will disable the interrupt of current CPU when it do single step. Access $step_count in actions will get the count of this step that begin with 1.
+
+Read the traceframe of while-stepping
+The data of different step that is recorded by while-stepping actions will be saved in different traceframe that you can use tfind (#Use_tfind_select_the_entry_inside_the_trace_frame_info) to select them.
+Or you can switch KGTP to replay mode to select all the traceframe of a while-stepping tracepoint with GDB execution and reverse-execution commands. For example:
+Use tfind select one the traceframe of a while-stepping tracepoint.
+
+(gdb) tfind 
+Found trace frame 0, tracepoint 1
+#0  vfs_read (file=0xffff8801f7bd4c00, buf=0x7fff74e4edb0 <Address 0x7fff74e4edb0 out of bounds>, count=16, 
+    pos=0xffff8801f4b45f48) at /build/buildd/linux-3.2.0/fs/read_write.c:365
+365     {
+Following commands will swith KGTP to replay mode.
+
+(gdb) monitor replay
+(gdb) tfind -1
+No longer looking at any trace frame
+#0  vfs_read (file=0xffff8801f7bd4c00, buf=0x7fff74e4edb0 <Address 0x7fff74e4edb0 out of bounds>, count=16, 
+    pos=0xffff8801f4b45f48) at /build/buildd/linux-3.2.0/fs/read_write.c:365
+365     {
+Then you can use execution commands.
+
+(gdb) n
+368             if (!(file->f_mode & FMODE_READ))
+(gdb) p file->f_mode
+$5 = 3
+Set breakpoints (Just valid in replay mode, will not affect Linux kernel execution).
+
+(gdb) b 375
+Breakpoint 2 at 0xffffffff81179b75: file /build/buildd/linux-3.2.0/fs/read_write.c, line 375.
+(gdb) c
+Continuing.
+
+Breakpoint 2, vfs_read (file=0xffff8801f7bd4c00, buf=0x7fff74e4edb0 <Address 0x7fff74e4edb0 out of bounds>, count=16, 
+    pos=0xffff8801f4b45f48) at /build/buildd/linux-3.2.0/fs/read_write.c:375
+375             ret = rw_verify_area(READ, file, pos, count);
+(gdb) s
+rw_verify_area (read_write=0, file=0xffff8801f7bd4c00, ppos=0xffff8801f4b45f48, count=16)
+    at /build/buildd/linux-3.2.0/fs/read_write.c:300
+300             inode = file->f_path.dentry->d_inode;
+Use reverse-execution commands.
+
+(gdb) rs
+
+Breakpoint 2, vfs_read (file=0xffff8801f7bd4c00, buf=0x7fff74e4edb0 <Address 0x7fff74e4edb0 out of bounds>, count=16, 
+    pos=0xffff8801f4b45f48) at /build/buildd/linux-3.2.0/fs/read_write.c:375
+375             ret = rw_verify_area(READ, file, pos, count);
+(gdb) rn
+372             if (unlikely(!access_ok(VERIFY_WRITE, buf, count)))
+GDB commands tstart, tfind or quit can auto close the replay mode.
+
+Howto show a variable whose value has been optimized away
+Sometimes, GDB will output some value like:
+
+inode has been optimized out of existence.
+res has been optimized out of existence.
+That is because value of inode and res is optimized. Linux Kernel is built with -O2 so you will get this trouble sometimes.
+There are 2 ways to handle it:
+
+Update your GCC
+The VTA branch http://gcc.gnu.org/wiki/Var_Tracking_Assignments was merged for GCC 4.5. This helps a lot with generating dwarf for previously "optimized out" values.
+
+Get the way that access the variable that has been out through parse ASM code
+Even if update the GCC to the newer version, you will still meet the issue. The main reason is the data is inside the registers but GCC doesn't put it to debug info. Then GDB just can output this variable has been optimized away.
+But you can get where is the variable from ASM code and access it inside the tracepoint actions.
+Following is a example that find variable "f" of function get_empty_filp and use it in tracepoint actions:
+We want collect the value of "f" but looks it has been optimized away.
+
+(gdb) list get_empty_filp
+...
+...
+...
+137             INIT_LIST_HEAD(&f->f_u.fu_list);
+138             atomic_long_set(&f->f_count, 1);
+139             rwlock_init(&f->f_owner.lock);
+140             spin_lock_init(&f->f_lock);
+141             eventpoll_init_file(f);
+(gdb) 
+142             /* f->f_version: 0 */
+143             return f;
+(gdb) trace 143
+Tracepoint 1 at 0xffffffff8119b30e: file fs/file_table.c, line 143.
+(gdb) actions 
+Enter actions for tracepoint 1, one per line.
+End with a line saying just "end".
+>collect f
+`f' is optimized away and cannot be collected.
+Now use "disassemble /m" command get the ASM code and source line that have relation with "f" and parse them.
+
+(gdb) disassemble /m get_empty_filp
+...
+...
+...
+125             f = kmem_cache_zalloc(filp_cachep, GFP_KERNEL);
+126             if (unlikely(!f))
+   0xffffffff8119b28c <+92>:    test   %rax,%rax
+   0xffffffff8119b292 <+98>:    je     0xffffffff8119b362 <get_empty_filp+306>
+
+127                     return ERR_PTR(-ENOMEM);
+   0xffffffff8119b362 <+306>:   mov    $0xfffffffffffffff4,%rax
+   0xffffffff8119b369 <+313>:   jmp    0xffffffff8119b311 <get_empty_filp+225>
+Code from "+98" to "+132" is not show in this part because they belong to other inline function. But you can get them with GDB command "disassemble get_empty_filp".
+
+   0xffffffff8119b287 <+87>:    callq  0xffffffff81181cb0 <kmem_cache_alloc>
+   0xffffffff8119b28c <+92>:    test   %rax,%rax
+   0xffffffff8119b28f <+95>:    mov    %rax,%rbx
+   0xffffffff8119b292 <+98>:    je     0xffffffff8119b362 <get_empty_filp+306>
+   0xffffffff8119b298 <+104>:   mov    0xb4d406(%rip),%edx        # 0xffffffff81ce86a4 <percpu_counter_batch>
+   0xffffffff8119b29e <+110>:   mov    $0x1,%esi
+   0xffffffff8119b2a3 <+115>:   mov    $0xffffffff81c05340,%rdi
+---Type <return> to continue, or q <return> to quit---
+   0xffffffff8119b2aa <+122>:   callq  0xffffffff8130dd20 <__percpu_counter_add>
+According to the ASM code you can see that return value of kmem_cache_alloc is inside $rax and its value is set to $rbx.
+Looks $rbx has the value of "f". Let's check other ASM code.
+
+128     
+129             percpu_counter_inc(&nr_files);
+130             f->f_cred = get_cred(cred);
+   0xffffffff8119b2b4 <+132>:   mov    %r12,0x70(%rbx)
+Set a value to element of f, the ASM code is set value of $r12 to a address that base address is $rbx. It also looks like $rbx is "f".
+
+131             error = security_file_alloc(f);
+   0xffffffff8119b2b8 <+136>:   mov    %rbx,%rdi
+   0xffffffff8119b2bb <+139>:   callq  0xffffffff8128ee30 <security_file_alloc>
+
+132             if (unlikely(error)) {
+   0xffffffff8119b2c0 <+144>:   test   %eax,%eax
+   0xffffffff8119b2c2 <+146>:   jne    0xffffffff8119b36b <get_empty_filp+315>
+---Type <return> to continue, or q <return> to quit---
+
+133                     file_free(f);
+134                     return ERR_PTR(error);
+   0xffffffff8119b393 <+355>:   movslq -0x14(%rbp),%rax
+   0xffffffff8119b397 <+359>:   jmpq   0xffffffff8119b311 <get_empty_filp+225>
+
+135             }
+136     
+137             INIT_LIST_HEAD(&f->f_u.fu_list);
+138             atomic_long_set(&f->f_count, 1);
+139             rwlock_init(&f->f_owner.lock);
+   0xffffffff8119b2e4 <+180>:   movl   $0x100000,0x50(%rbx)
+
+140             spin_lock_init(&f->f_lock);
+   0xffffffff8119b2c8 <+152>:   xor    %eax,%eax
+   0xffffffff8119b2d1 <+161>:   mov    %ax,0x30(%rbx)
+
+141             eventpoll_init_file(f);
+142             /* f->f_version: 0 */
+143             return f;
+   0xffffffff8119b30e <+222>:   mov    %rbx,%rax
+And after check other ASM code. You can make sure that $rbx is "f".
+Then you can access "f" through access $rbx in tracepoint actions, for example:
+
+(gdb) trace 143
+Tracepoint 1 at 0xffffffff8119b30e: file fs/file_table.c, line 143.
+(gdb) actions 
+Enter actions for tracepoint 1, one per line.
+End with a line saying just "end".
+#collect f
+>collect $rbx
+#collect *f
+>collect *((struct file *)$rbx)
+#collect f->f_op
+>collect ((struct file *)$rbx)->f_op
+>end
+How to get the function pointer point to
+If the debug info of the function pointer is not optimized out
+You can collect it directly and print what it point to. For example:
+
+377                     count = ret;
+378                     if (file->f_op->read)
+379                             ret = file->f_op->read(file, buf, count, pos);
+(gdb) 
+(gdb) trace 379
+Tracepoint 1 at 0xffffffff81173ba5: file /home/teawater/kernel/linux/fs/read_write.c, line 379.
+(gdb) actions 
+Enter actions for tracepoint 1, one per line.
+End with a line saying just "end".
+>collect file->f_op->read
+>end
+(gdb) tstart
+(gdb) tstop
+(gdb) tfind
+(gdb) p file->f_op->read
+$5 = (ssize_t (*)(struct file *, char *, size_t, loff_t *)) 0xffffffff81173190 <do_sync_read>
+#Then you know file->f_op->read point to do_sync_read.
+If the debug info of the function pointer is optimized out
+You can use tracepoint step to handle it. For example:
+
+#Find out which instrunction that it is called.
+(gdb) disassemble /rm vfs_read
+379                             ret = file->f_op->read(file, buf, count, pos);
+   0xffffffff81173ba5 <+181>:   48 89 da        mov    %rbx,%rdx
+   0xffffffff81173ba8 <+184>:   4c 89 e9        mov    %r13,%rcx
+   0xffffffff81173bab <+187>:   4c 89 e6        mov    %r12,%rsi
+   0xffffffff81173bae <+190>:   4c 89 f7        mov    %r14,%rdi
+   0xffffffff81173bb1 <+193>:   ff d0   callq  *%rax
+   0xffffffff81173bb3 <+195>:   48 89 c3        mov    %rax,%rbx
+(gdb) trace *0xffffffff81173bb1
+Tracepoint 1 at 0xffffffff81173bb1: file /home/teawater/kernel/linux/fs/read_write.c, line 379.
+(gdb) actions 
+Enter actions for tracepoint 1, one per line.
+End with a line saying just "end".
+>while-stepping 1
+ >collect $reg
+ >end
+>end
+(gdb) tstart 
+(gdb) tstop 
+(gdb) tfind 
+#0  tty_read (file=0xffff88006ca74900, buf=0xb6b7dc <Address 0xb6b7dc out of bounds>, count=8176, 
+    ppos=0xffff88006e197f48) at /home/teawater/kernel/linux/drivers/tty/tty_io.c:960
+960     {
+#Then you know file->f_op->read point to tty_read.
+Please note that while-stepping will make tracepoint cannot use kprobes-optimization.
+
+/sys/kernel/debug/gtpframe and offline debug
+/sys/kernel/debug/gtpframe supplies trace frame in tfile format (GDB can parse it) when KGTP is stop.
+In the PC that can run the GDB:
+Change the "target remote XXXX" to
+
+(gdb) target remote | perl ./getgtprsp.pl
+After that, set tracepoint and start it as usual:
+
+(gdb) trace vfs_readdir
+Tracepoint 1 at 0xffffffff8114f3c0: file /home/teawater/kernel/linux-2.6/fs/readdir.c, line 24.
+(gdb) actions 
+Enter actions for tracepoint 1, one per line.
+End with a line saying just "end".
+#If your GDB support tracepoint "printf" (see "Howto use tracepoint printf"), use it to show the value directly is better.
+>collect $reg
+>end
+(gdb) tstart 
+(gdb) stop 
+(gdb) quit
+Then you can find files gtpstart and gtpstop in current directory. Copy it to the machine that you want to debug.
+
+In the debugged machine, copy the program "putgtprsp" and "gtp.ko" in the KGTP directory to this machine first. After insmod the gtp.ko:
+Start the tracepoint:
+
+./putgtprsp ./gtpstart
+Stop the tracepoint:
+
+./putgtprsp ./gtpstop
+You can let Linux Kernel show the value directly, please see HOWTO#Howto_let_tracepoint_output_value_directly.
+
+If you want to save the value to the trace frame and parse later, you can use file "/sys/kernel/debug/gtpframe" that has the trace frame. Copy it to the PC that has GDB. 
+Please note that some "cp" cannot handle it very well, please use "cat /sys/kernel/debug/gtpframe > ./gtpframe" to copy it.
+In the PC that can run the GDB:
+(gdb) target tfile ./gtpframe
+Tracepoint 1 at 0xffffffff8114f3dc: file /home/teawater/kernel/linux-2.6/fs/readdir.c, line 24.
+Created tracepoint 1 for target's tracepoint 1 at 0xffffffff8114f3c0.
+(gdb) tfind 
+Found trace frame 0, tracepoint 1
+#0  vfs_readdir (file=0xffff880036e8f300, filler=0xffffffff8114f240 <filldir>, buf=0xffff880001e5bf38)
+    at /home/teawater/kernel/linux-2.6/fs/readdir.c:24
+24      {
+Please note that if you want connect KGTP from GDB in remote machine after use offline debug, you need "rmmod gtp" and "insmod gtp.ko" before call "nc".
+
+How to use /sys/kernel/debug/gtpframe_pipe
+This interface supplies same format trace frame with "gtpframe". But it can work when KGTP is running. After data is read, it will auto deleted from trace frame like "trace_pipe" of ftrace.
+
+Get the frame info with GDB
+#connect to the interface
+(gdb) target tfile /sys/kernel/debug/gtpframe_pipe
+#Get one trace frame entry
+(gdb) tfind 0
+Found trace frame 0, tracepoint 1
+#Get the next one
+(gdb) tfind 
+Target failed to find requested trace frame.
+(gdb) tfind 0
+Found trace frame 0, tracepoint 1
+This way is better to work with python to parse Kernel. add-ons/hotcode.py is an example of python script.
+
+Get the frame info with cat
+sudo cat /sys/kernel/debug/gtpframe_pipe > g
+Then all the trace frame will be saved in file "g".
+
+Get the frame info with getframe
+KGTP package include a program "getframe" can help you save the trace frame to files.
+Following part is the help of it:
+
+getframe -h
+Get the trace frame of KGTP and save them in current 
+directory with tfile format.
+Usage: ./getframe [option]
+
+  -g n    Set the minimum free size limit to n G.
+          When free size of current disk is smaller than n G,
+          ./getframe will exit (-q) or wait some seconds (-w).
+          The default value of it is 2 G.
+
+  -q      Quit when current disk is smaller than
+          minimum free size limit (-g).
+
+  -w n    Wait n seconds when current disk is smaller
+          than minimum free size limit (-g).
+
+  -e n    Set the entry number of each tfile to n.
+          The default value of it is 1000.
+
+  -h      Display this information.
+Use $pipe_trace
+For the lock safe, KGTP will ignore the task that read the /sys/kernel/debug/gtpframe_pipe in default.
+If you really need trace this task, and be sure that is safe. You can use following command before call "tstart":
+
+(gdb) tvariable $pipe_trace=1
+Then KGTP will not ignore the task that read /sys/kernel/debug/gtpframe_pipe.
+
+Use KGTP with user space program
+Read memory of user space program directly
+KGTP can read memory directly without stop this user space program. Please goto HOWTO#the_memory_of_the_user_space_program get how to do it.
+
+collect stack (for backtrace) of user space program in tracepoint
+$current is a special trace state variable that if the action of an tracepoint access it, this tracepint will access the values of the registers and the memory of current task instead of Linux kernel.
+In general, the tracepoint will get the registers value of current task from task_pt_regs. Then collect $current in tracepoint actions will let this tracepoint access values of current task. For example:
+
+(gdb) actions 
+Enter actions for tracepoint 1, one per line.
+End with a line saying just "end".
+>collect $current
+>collect $bt
+>end
+In addition, for some special function that its arguments include the pointer to the registers(for example: do_IRQ function of X86), tracepoint need get the registers from the arguments of fuction. Then set the pointer to $current will let this tracepoint get it. For example:
+
+(gdb) actions 
+Enter actions for tracepoint 1, one per line.
+End with a line saying just "end".
+>teval $current=(uint64_t)regs
+>collect $bt
+>end
+$current_task_user is a special trace state variable that it is value will be true when current task is in user mode.
+With these two trace state variables, you can use KGTP collect the stack(backtrace) of current task.
+Following example show how we do backtrace(stack dump) from user space to Linux kernel:
+
+#Connect to KGTP(same with prev section)
+(gdb) target extended-remote /sys/kernel/debug/gtp
+#Setup an tracepoint that collect the user space stack of task 18776.
+(gdb) trace vfs_read
+Tracepoint 1 at 0xffffffff8117a3d0: file /home/teawater/kernel/linux/fs/read_write.c, line 365.
+(gdb) condition 1 ($current_task_user && $current_task_pid == 18776)
+(gdb) actions 
+Enter actions for tracepoint 1, one per line.
+End with a line saying just "end".
+>collect $current
+>collect $bt
+>end
+#Setup a tracepoint that collect kernel space stack of task 18776.
+(gdb) trace vfs_read
+Note: breakpoint 1 also set at pc 0xffffffff8117a3d0.
+Tracepoint 2 at 0xffffffff8117a3d0: file /home/teawater/kernel/linux/fs/read_write.c, line 365.
+(gdb) condition 2 ($current_task_user && $current_task_pid == 18776)
+(gdb) actions 
+Enter actions for tracepoint 2, one per line.
+End with a line saying just "end".
+>collect $bt
+>end
+(gdb) tstart
+(gdb) tstop
+#Following part is same with prev section, add a new inferior to parse info of the user space program.
+(gdb) add-inferior
+Added inferior 2
+(gdb) inferior 2
+[Switching to inferior 2 [<null>] (<noexec>)]
+(gdb) file gdb
+Reading symbols from /usr/local/bin/gdb...done.
+(gdb) attach 18776
+#tracepoint 1 collect the user space stack. 
+(gdb) tfind
+Found trace frame 0, tracepoint 1
+#0  0x00007f77331d7d0f in __read_nocancel () from /lib/x86_64-linux-gnu/libpthread.so.0
+#This is the user space backtrace of task 18776.
+(gdb) bt
+#0  0x00007f77331d7d0f in __read_nocancel () from /lib/x86_64-linux-gnu/libpthread.so.0
+#1  0x000000000078e145 in rl_callback_read_char () at ../../src/readline/callback.c:201
+#2  0x000000000069de79 in rl_callback_read_char_wrapper (client_data=<optimized out>) at ../../src/gdb/event-top.c:169
+#3  0x000000000069ccf8 in process_event () at ../../src/gdb/event-loop.c:401
+#4  process_event () at ../../src/gdb/event-loop.c:351
+#5  0x000000000069d448 in gdb_do_one_event () at ../../src/gdb/event-loop.c:465
+#6  0x000000000069d5d5 in start_event_loop () at ../../src/gdb/event-loop.c:490
+#7  0x0000000000697083 in captured_command_loop (data=<optimized out>) at ../../src/gdb/main.c:226
+#8  0x0000000000695d8b in catch_errors (func=0x697070 <captured_command_loop>, func_args=0x0, errstring=0x14df99e "", 
+    mask=6) at ../../src/gdb/exceptions.c:546
+#9  0x00000000006979e6 in captured_main (data=<optimized out>) at ../../src/gdb/main.c:1001
+#10 0x0000000000695d8b in catch_errors (func=0x697360 <captured_main>, 
+    func@entry=<error reading variable: PC not available>, func_args=0x7fff08afd5b0, 
+    func_args@entry=<error reading variable: PC not available>, errstring=<unavailable>, 
+    errstring@entry=<error reading variable: PC not available>, mask=<unavailable>, 
+    mask@entry=<error reading variable: PC not available>) at ../../src/gdb/exceptions.c:546
+#11 <unavailable> in ?? ()
+Backtrace stopped: not enough registers or memory available to unwind further
+#The tracepoint 2 collect the kernel space stack.  So swith to inferior 1 that load the kernel debug info.
+(gdb) tfind
+Found trace frame 1, tracepoint 2
+#0  0xffffffff8117a3d0 in ?? ()
+(gdb) inferior 1
+[Switching to inferior 1 [Remote target] (/home/teawater/kernel/b/vmlinux)]
+[Switching to thread 1 (Remote target)] 
+#0  vfs_read (file=0xffff88021a559500, buf=0x7fff08afd31f <Address 0x7fff08afd31f out of bounds>, count=1, 
+    pos=0xffff8800c47e1f48) at /home/teawater/kernel/linux/fs/read_write.c:365
+365     {
+#This is the backtrace of kernel stack.
+(gdb) bt
+#0  vfs_read (file=0xffff88021a559500, buf=0x7fff08afd31f <Address 0x7fff08afd31f out of bounds>, count=1, 
+    pos=0xffff8800c47e1f48) at /home/teawater/kernel/linux/fs/read_write.c:365
+#1  0xffffffff8117a59a in sys_read (fd=<optimized out>, buf=0x7fff08afd31f <Address 0x7fff08afd31f out of bounds>, 
+    count=1) at /home/teawater/kernel/linux/fs/read_write.c:469
+#2  <signal handler called>
+#3  0x00007f77331d7d10 in ?? ()
+#4  0x0000000000000000 in ?? ()
+How to use add-ons/hotcode.py
+This script can show the hottest code line in the Linux kernel or user space program through parse and record the pc address in the interrupt handler.
+Please goto http://code.google.com/p/kgtp/wiki/hotcode see howto use it.
+
+How to add plugin in C
+KGTP support plugin that write in C. The plugin will be built as LKM
+
+API
+#include "gtp.h"
+This header file include the API that plugin need. 
+
+extern int gtp_plugin_mod_register(struct module *mod);
+extern int gtp_plugin_mod_unregister(struct module *mod);
+These two functions register and unregister the plugin module. Then when KGTP will add module usage count when it access the resource of the plugin module. 
+
+extern struct gtp_var *gtp_plugin_var_add(char *name, int64_t val,
+                                          struct gtp_var_hooks *hooks);
+This function add special trace state variable to the KGTP.
+
+name is the name of special trace state variable.
+val is initialization value of special trace state variable.
+hooks is the function pointers. The function pointers can be set to NULL if this function doesn't support.
+Return the gtp_var pointer if success. Get error will return error code that IS_ERR and PTR_ERR can handle.
+
+
+struct gtp_var_hooks {
+        int     (*gdb_set_val)(struct gtp_trace_s *unused, struct gtp_var *var,
+                               int64_t val);
+        int     (*gdb_get_val)(struct gtp_trace_s *unused, struct gtp_var *var,
+                               int64_t *val);
+        int     (*agent_set_val)(struct gtp_trace_s *gts, struct gtp_var *var,
+                                 int64_t val);
+        int     (*agent_get_val)(struct gtp_trace_s *gts, struct gtp_var *var,
+                                 int64_t *val);
+};
+gdb_set_val will be called when GDB set the value of TSV. Please note that TSV just can be set by GDB command "tvariable $xxx=1" and the value just be sent to KGTP when GDB command "tstart".
+unused is unused. Just to make this pointer can share function with agent_set_val.
+var is the pointer that point to the gtp_var pointer. Then function of plugin can use it to figure out which TSV is accessed when TSVs share the function.
+val is the value that GDB set.
+Return return -1 if error. return 0 if success.
+gdb_get_val will be called when GDB get the value of TSV. Please note that TSV get is different with TSV set. It can be gotten from KGTP anytime. And get its value just like get the value of GDB internal value. For example: "p $xxx".
+unused is same with gdb_set_val.
+var is same with gdb_set_val.
+val is the pointer that use to return value.
+Return is same with gdb_set_val.
+agent_set_val will be called when tracepoint action(HOWTO#teval_expr1,_expr2,_...) set the value of TSV.
+gts is pointer to the tracepoint session struct.
+var is same with gdb_set_val.
+val is the value the action set.
+Return is same with gdb_set_val.
+agent_get_val will be called when tracepoint action(HOWTO#collect_expr1,_expr2,_... or HOWTO#teval_expr1,_expr2,_...) get the value of TSV.
+gts is same with agent_set_val.
+var is same with gdb_set_val.
+val is same with gdb_get_val.
+Return is same with gdb_set_val.
+
+
+extern int gtp_plugin_var_del(struct gtp_var *var);
+When rmmod the plugin module, use this function remove the TSV that gtp_plugin_var_add add. 
+
+Example
+plugin_example.c that in the KGTP directory is the example for KGTP plugin. You can use "make P=1" build it. It add 4 TSV to KGTP.
+
+$test1 support nothing.
+$test2 support be get and set by GDB or tracepoint action.
+$test3 just support tracepoint action set. When set a value to it, it will look up a kernel symbol of this value and print it. For example "teval $test3=(int64_t)$rip".
+$test4 just support tracepoint action set. When set a value to it, it will look up a kernel symbol of current tracepoint address and print it.
+How to use
+insmod KGTP module according to HOWTO#Exec_it.
+insmod plugin_example.ko
+Use GDB connect to KGTP and use it.
+Disconnect GDB. If option in HOWTO#Do_not_stop_tracepoint_when_the_GDB_disconnects set to on, set it to off.
+rmmod plugin_example.ko
+Please note that KGTP support add more than one plugin.
+
+How to use performance counters
+Performance counters are special hardware registers available on most modern CPUs. These registers count the number of certain types of hw events: such as instructions executed, cachemisses suffered, or branches mis-predicted - without slowing down the kernel or applications. These registers can also trigger interrupts when a threshold number of events have passed - and can thus be used to profile the code that runs on that CPU.
+The Linux Performance Counter subsystem called perf event can get the value of performance counter. You can access it through KGTP perf event trace state variables.
+Please goto read the file tools/perf/design.txt in Linux Kernel to get more info about perf event.
+
+Define a perf event trace state variable
+Access an performance counter need define following trace state variable:
+
+"pe_cpu_"+tv_name       Define the the CPU id of the performance counter.
+"pe_type_"+tv_name      Define the the type of the performance counter.
+"pe_config_"+tv_name    Define the the config of the performance counter.
+"pe_en_"+tv_name        This the switch to enable or disable the performance counter.
+                        The performance counter is disable in default.
+"pe_val_"+tv_name       Access this variable can get the value of the performance counter.
+Define a per_cpu perf event trace state variable
+Define a per_cpu perf event trace state variable is same with define HOWTO#Per_cpu_trace_state_variables.
+
+"p_pe_"+perf_event type+string+CPU_id
+Please note that if you define a per_cpu perf event trace state variable, you will not need define the cpu id("pe_cpu") because KGTP already get it.
+
+The perf event type and config
+The type of perf event can be:
+
+0       PERF_TYPE_HARDWARE
+1       PERF_TYPE_SOFTWARE
+2       PERF_TYPE_TRACEPOINT
+3       PERF_TYPE_HW_CACHE
+4       PERF_TYPE_RAW
+5       PERF_TYPE_BREAKPOINT
+If the type is 0(PERF_TYPE_HARDWARE), the config can be:
+
+0       PERF_COUNT_HW_CPU_CYCLES
+1       PERF_COUNT_HW_INSTRUCTIONS
+2       PERF_COUNT_HW_CACHE_REFERENCES
+3       PERF_COUNT_HW_CACHE_MISSES
+4       PERF_COUNT_HW_BRANCH_INSTRUCTIONS
+5       PERF_COUNT_HW_BRANCH_MISSES
+6       PERF_COUNT_HW_BUS_CYCLES
+7       PERF_COUNT_HW_STALLED_CYCLES_FRONTEND
+8       PERF_COUNT_HW_STALLED_CYCLES_BACKEND
+
+If the type is 3(PERF_TYPE_HW_CACHE), the config need to divide to 3 parts: First one is cache id, it need be << 0 before set to config:
+
+0       PERF_COUNT_HW_CACHE_L1D
+1       PERF_COUNT_HW_CACHE_L1I
+2       PERF_COUNT_HW_CACHE_LL
+3       PERF_COUNT_HW_CACHE_DTLB
+4       PERF_COUNT_HW_CACHE_ITLB
+5       PERF_COUNT_HW_CACHE_BPU
+Second one is cache op id, it need be << 8 before set to config:
+
+0       PERF_COUNT_HW_CACHE_OP_READ
+1       PERF_COUNT_HW_CACHE_OP_WRITE
+2       PERF_COUNT_HW_CACHE_OP_PREFETCH
+Last one is cache op result id, it need be << 16 before set to config:
+
+0       PERF_COUNT_HW_CACHE_RESULT_ACCESS
+1       PERF_COUNT_HW_CACHE_RESULT_MISS
+If you want get the perf count of PERF_COUNT_HW_CACHE_L1I(1), PERF_COUNT_HW_CACHE_OP_WRITE(1) and PERF_COUNT_HW_CACHE_RESULT_MISS(1), you can use:
+
+(gdb) tvariable $pe_config_cache=1 | (1 << 8) | (1 << 16)
+tools/perf/design.txt in Linux Kernel have more info about type and config of perf event.
+
+Enable and disable all the perf event in a CPU with $p_pe_en
+I think the best way that count a part of code with performance counters is enable all the count in the begin of the code and disable all of them in the end. You can do it with "pe_en". But if you have a lot of perf event trace state variables. That will make the tracepoint action very big. $p_pe_en is for this issue. You can enable all the perf event trace state variables in current CPU with following action:
+
+>teval $p_pe_en=1
+Disable them with set $p_pe_en to 0.
+
+>teval $p_pe_en=0
+GDB scripts to help with set and get the perf event trace state variables
+Following is a GDB script define two commands dpe and spe to help define and show the perf event trace state variables.
+You can put it to the ~/.gdbinit or your tracepoint script. Then you can use this two commands in GDB directly.
+
+define dpe
+  if ($argc < 2)
+    printf "Usage: dpe pe_type pe_config [enable]\n"
+  end
+  if ($argc >= 2)
+    eval "tvariable $p_pe_val_%d%d_c",$arg0, $arg1
+    eval "tvariable $p_pe_en_%d%d_c",$arg0, $arg1
+    set $tmp=0
+    while $tmp<$cpu_number
+      eval "tvariable $p_pe_type_%d%d_c%d=%d",$arg0, $arg1, $tmp, $arg0
+      eval "tvariable $p_pe_config_%d%d_c%d=%d",$arg0, $arg1, $tmp, $arg1
+      eval "tvariable $p_pe_val_%d%d_c%d=0",$arg0, $arg1, $tmp
+      if ($argc >= 3)
+        eval "tvariable $p_pe_en_%d%d_c%d=%d",$arg0, $arg1, $tmp, $arg2
+      end
+      set $tmp=$tmp+1
+    end
+  end
+end
+
+document dpe
+Usage: dpe pe_type pe_config [enable]
+end
+
+define spe
+  if ($argc != 2 && $argc != 3)
+    printf "Usage: spe pe_type pe_config [cpu_id]\n"
+  end
+  if ($argc == 2)
+    set $tmp=0
+    while $tmp<$cpu_number
+      eval "printf \"$p_pe_val_%%d%%d_c%%d=%%ld\\n\",$arg0, $arg1, $tmp, $p_pe_val_%d%d_c%d", $arg0, $arg1, $tmp
+      set $tmp=$tmp+1
+    end
+  end
+  if ($argc == 3)
+    eval "printf \"$p_pe_val_%%d%%d_c%%d=%%ld\\n\",$arg0, $arg1, $tmp, $p_pe_val_%d%d_c%d", $arg0, $arg1, $arg2
+  end
+end
+
+document spe
+Usage: spe pe_type pe_config [cpu_id]
+end
+Following is an example to use it get the performance counters of function tcp_v4_rcv:
+
+#Connect to KGTP
+(gdb) target remote /sys/kernel/debug/gtp
+#Define 3 pe tvs for PERF_COUNT_HW_CPU_CYCLES, PERF_COUNT_HW_CACHE_MISSES and PERF_COUNT_HW_BRANCH_MISSES.
+(gdb) dpe 0 0
+(gdb) dpe 0 3
+(gdb) dpe 0 5
+#enable the performance counters of this CPU in the begin of this function.
+(gdb) trace tcp_v4_rcv
+(gdb) action
+>teval $p_pe_en=1
+>end
+#$kret make this hanler the end of function tcp_v4_rcv.
+(gdb) trace *(tcp_v4_rcv)
+(gdb) action
+>teval $kret=0
+#disable all performance counters of this CPU
+>teval $p_pe_en=0
+#Access the per cpu perf event tv will access to the current cpu pe tv.
+>collect $p_pe_val_00_0
+>collect $p_pe_val_03_0
+>collect $p_pe_val_05_0
+#Set all the pe tv to 0
+>teval $p_pe_val_00_0=0
+>teval $p_pe_val_03_0=0
+>teval $p_pe_val_05_0=0
+>end
+tstart
+#Wait some time that current pc receive some tcp package.
+(gdb) tstop
+(gdb) tfind
+(gdb) spe 0 0 $cpu_id
+$p_pe_val_00_2=12676
+(gdb) spe 0 3 $cpu_id
+$p_pe_val_03_2=7
+(gdb) spe 0 5 $cpu_id
+$p_pe_val_05_2=97
--- /dev/null
+++ b/Documentation/gtp/howtocn.txt
@@ -0,0 +1,1988 @@
+		Linux Kernel GDB tracepoint module (KGTP)
+		=========================================
+		By Hui Zhu <teawater@gmail.com>
+		https://code.google.com/p/kgtp/wiki/HOWTOCN
+
+Update in 2013-06-26
+
+ä»€ä¹ˆæ˜¯KGTP
+éœ€è¦å¸®åŠ©æˆ–è€…æ±‡æŠ¥é—®é¢˜
+GDBè°ƒè¯•æ™®é€šç¨‹åºå’ŒKGTPçš„åŒºåˆ«è¡¨
+ä½¿ç”¨KGTPå‰çš„å‡†å¤‡å·¥ä½œ
+Linuxå†…æ ¸
+å¦‚æžœä½ çš„ç³»ç»Ÿå†…æ ¸æ˜¯è‡ªå·±ç¼–è¯‘çš„
+å¦‚æžœæ˜¯Androidå†…æ ¸
+å¦‚æžœä½ çš„ç³»ç»Ÿå†…æ ¸æ˜¯å‘è¡Œç‰ˆè‡ªå¸¦çš„
+Ubuntu
+å®‰è£…Linuxå†…æ ¸è°ƒè¯•é•œåƒçš„æ ‡å‡†æ–¹æ³•
+å®‰è£…Linuxå†…æ ¸è°ƒè¯•é•œåƒçš„ç¬¬äºŒæ–¹æ³•
+å®‰è£…å†…æ ¸å¤´æ–‡ä»¶åŒ…
+å®‰è£…å†…æ ¸æºç 
+Fedora
+å®‰è£…Linuxå†…æ ¸è°ƒè¯•é•œåƒ
+å®‰è£…Linuxå†…æ ¸å¼€å‘åŒ…
+å…¶ä»–ç³»ç»Ÿ
+ç¡®å®šLinuxå†…æ ¸è°ƒè¯•é•œåƒæ˜¯æ­£ç¡®çš„
+å½“å‰Linuxå†…æ ¸è°ƒè¯•é•œåƒåœ¨å“ª
+ä½¿ç”¨/proc/kallsyms
+ä½¿ç”¨linux_banner
+å¤„ç†Linuxå†…æ ¸è°ƒè¯•é•œåƒåœ°å€ä¿¡æ¯å’ŒLinuxå†…æ ¸æ‰§è¡Œæ—¶ä¸åŒçš„é—®é¢˜
+å–å¾—KGTP
+é€šè¿‡httpä¸‹è½½KGTP
+é€šè¿‡svnä¸‹è½½KGTP
+é…ç½®KGTP
+ç¼–è¯‘KGTP
+æ™®é€šç¼–è¯‘
+ç”¨ä¸€äº›ç‰¹æ®Šé€‰é¡¹ç¼–è¯‘KGTP
+å®‰è£…å’Œå¸è½½ KGTP
+å’ŒDKMSä¸€èµ·ä½¿ç”¨KGTP
+ä½¿ç”¨KGTP Linuxå†…æ ¸patch
+å®‰è£…å¯ä»¥å’ŒKGTPä¸€èµ·ä½¿ç”¨çš„GDB
+å¦‚ä½•è®©GDBè¿žæŽ¥KGTP
+æ™®é€šLinux
+å®‰è£…KGTPæ¨¡å—
+å¤„ç†æ‰¾ä¸åˆ°"/sys/kernel/debug/gtp"çš„é—®é¢˜
+è®©GDBè¿žæŽ¥åˆ°KGTP
+GDBåœ¨æœ¬åœ°ä¸»æœºä¸Š
+å¦‚æžœGDBåœ¨è¿œç¨‹ä¸»æœºä¸Š
+Android
+å®‰è£…KGTPæ¨¡å—
+å¤„ç†æ‰¾ä¸åˆ°"/sys/kernel/debug/gtp"çš„é—®é¢˜
+GDBè¿žæŽ¥KGTP
+å¢žåŠ æ¨¡å—çš„ç¬¦å·ä¿¡æ¯åˆ°GDB
+å¦‚ä½•ä½¿ç”¨getmod
+å¦‚ä½•ä½¿ç”¨getmod.py
+å¦‚ä½•ä½¿ç”¨GDBæŽ§åˆ¶KGTPè·Ÿè¸ªå’Œè°ƒè¯•Linuxå†…æ ¸
+åœ¨æ™®é€šæ¨¡å¼ç›´æŽ¥è®¿é—®å½“å‰å€¼
+Linuxå†…æ ¸çš„å†…å­˜
+ç”¨æˆ·ç¨‹åºçš„å†…å­˜
+traceçŠ¶æ€å˜é‡
+GDB tracepoint
+è®¾ç½®tracepint
+è¿™ä¸ªå‡½æ•°ç¡®å®žå­˜åœ¨ä½†æ˜¯è®¾ç½®tracepointåˆ°ä¸Šé¢ä¼šå¤±è´¥å¦‚ä½•å¤„ç†
+å¦‚ä½•è®¾ç½®æ¡ä»¶tracepoint
+å¦‚ä½•å¤„ç†é”™è¯¯ "Unsupported operator (null) (52) in expression."
+actions [num]
+collect expr1, expr2, ...
+teval expr1, expr2, ...
+while-stepping n
+å¯åŠ¨å’Œåœæ­¢ tracepoint
+Enable å’Œ disable tracepoint
+ç”¨tfindé€‰æ‹©traceå¸§ç¼“å­˜é‡Œé¢çš„æ¡ç›®
+å¦‚ä½•å¤„ç†é”™è¯¯ "No such file or directory." æˆ–è€… "æ²¡æœ‰é‚£ä¸ªæ–‡ä»¶æˆ–ç›®å½•."
+ä¿å­˜traceå¸§ä¿¡æ¯åˆ°ä¸€ä¸ªæ–‡ä»¶ä¸­
+æ˜¾ç¤ºå’Œå­˜å‚¨tracepoint
+åˆ é™¤tracepoint
+ç”¨tracepointä»Žå†…æ ¸ä¸­æŸç‚¹å–å¾—å¯„å­˜å™¨ä¿¡æ¯
+ç”¨tracepointä»Žå†…æ ¸ä¸­æŸç‚¹å–å¾—å˜é‡çš„å€¼
+æ˜¾ç¤ºå½“å‰è¿™ä¸€æ¡traceç¼“å­˜é‡Œå­˜å‚¨çš„æ‰€æœ‰ä¿¡æ¯
+å–å¾— tracepoint çš„çŠ¶æ€
+è®¾ç½®traceç¼“å­˜ä¸ºå¾ªçŽ¯ç¼“å­˜
+GDBæ–­å¼€çš„æ—¶å€™ä¸è¦åœæ­¢tracepoint
+kprobes-optimizationå’Œtracepointçš„æ‰§è¡Œé€Ÿåº¦
+å¦‚æžœä½¿ç”¨traceçŠ¶æ€å˜é‡
+æ™®é€štraceçŠ¶æ€å˜é‡
+Per_cpu traceçŠ¶æ€å˜é‡
+å¦‚ä½•å®šä¹‰
+æœ¬åœ°CPUå˜é‡
+CPU idå˜é‡
+ä¾‹å­1
+ä¾‹å­2
+ç‰¹æ®ŠtraceçŠ¶æ€å˜é‡ $current_taskï¼Œ$current_task_pidï¼Œ$current_thread_infoï¼Œ$cpu_idï¼Œ$dump_stackï¼Œ$printk_levelï¼Œ$printk_formatï¼Œ$printk_tmpï¼Œ$clockï¼Œ$hardirq_countï¼Œ$softirq_count å’Œ $irq_count
+ç‰¹æ®ŠtraceçŠ¶æ€å˜é‡ $self_trace
+ç”¨$kret traceå‡½æ•°çš„ç»“å°¾
+ç”¨ $ignore_error å’Œ $last_errno å¿½ç•¥tstartçš„é”™è¯¯
+ä½¿ç”¨ $cooked_clock å’Œ $cooked_rdtsc å–å¾—ä¸åŒ…å«KGTPè¿è¡Œæ—¶é—´çš„æ—¶é—´ä¿¡æ¯
+ä½¿ç”¨ $xtime_sec å’Œ $xtime_nsec å–å¾— timespec
+å¦‚ä½• backtrace (stack dump)
+é€šè¿‡$btæ”¶é›†æ ˆå¹¶ç”¨GDBå‘½ä»¤backtraceè¿›è¡Œåˆ†æž
+ç”¨ $_ret æ¥å–å¾—å½“å‰å‡½æ•°çš„è°ƒç”¨å‡½æ•°çš„æ ˆ
+ç”¨ $dump_stack è¾“å‡ºæ ˆåˆ†æžåˆ°printké‡Œ
+å¦‚ä½•è®©tracepointç›´æŽ¥è¾“å‡ºä¿¡æ¯
+åˆ‡æ¢collectä¸ºç›´æŽ¥è¾“å‡ºæ•°æ®
+å¦‚ä½•ç”¨watch tracepointæŽ§åˆ¶ç¡¬ä»¶æ–­ç‚¹è®°å½•å†…å­˜è®¿é—®
+watch tracepointçš„traceçŠ¶æ€å˜é‡
+é™æ€watch tracepoint
+åŠ¨æ€watch tracepoint
+ä½¿ç”¨while-steppingè®©Linuxå†…æ ¸åšå•æ­¥
+å¦‚ä½•ä½¿ç”¨ while-stepping
+è¯»while-steppingçš„traceframe
+å¦‚ä½•æ˜¾ç¤ºè¢«ä¼˜åŒ–æŽ‰çš„å˜é‡å€¼
+å‡çº§ä½ çš„GCC
+é€šè¿‡åˆ†æžæ±‡ç¼–ä»£ç å–å¾—è®¿é—®è¢«ä¼˜åŒ–æŽ‰å˜é‡çš„æ–¹æ³•
+å¦‚ä½•å–å¾—å‡½æ•°æŒ‡é’ˆæŒ‡å‘çš„å‡½æ•°
+å¦‚æžœå‡½æ•°æŒ‡é’ˆæ²¡æœ‰è¢«ä¼˜åŒ–æŽ‰
+å¦‚æžœå‡½æ•°æŒ‡é’ˆè¢«ä¼˜åŒ–æŽ‰äº†
+/sys/kernel/debug/gtpframeå’Œç¦»çº¿è°ƒè¯•
+å¦‚ä½•ä½¿ç”¨ /sys/kernel/debug/gtpframe_pipe
+ç”¨GDBè¯»å¸§ä¿¡æ¯
+ç”¨catè¯»å¸§ä¿¡æ¯
+ç”¨getframeè¯»å¸§ä¿¡æ¯
+ä½¿ç”¨ $pipe_trace
+å’Œç”¨æˆ·å±‚ç¨‹åºä¸€èµ·ä½¿ç”¨KGTP
+ç›´æŽ¥è¯»ç”¨æˆ·å±‚ç¨‹åºçš„å†…å­˜
+åœ¨tracepointæ”¶é›†ç”¨æˆ·å±‚ç¨‹åºçš„æ ˆä¿¡æ¯(å¯ç”¨æ¥åšbacktrace)
+å¦‚ä½•ä½¿ç”¨ add-ons/hotcode.py
+å¦‚ä½•å¢žåŠ ç”¨Cå†™çš„æ’ä»¶
+API
+ä¾‹å­
+å¦‚ä½•ä½¿ç”¨
+å¦‚ä½•ä½¿ç”¨æ€§èƒ½è®¡æ•°å™¨
+å®šä¹‰ä¸€ä¸ªperf event traceçŠ¶æ€å˜é‡
+å®šä¹‰ä¸€ä¸ªper_cpu perf event traceçŠ¶æ€å˜é‡
+perf eventçš„ç±»åž‹å’Œé…ç½®
+ç”¨$p_pe_enæ‰“å¼€å’Œå…³é—­ä¸€ä¸ªCPUä¸Šæ‰€æœ‰çš„perf event
+ç”¨æ¥å¸®åŠ©è®¾ç½®å’Œå–å¾—perf event traceçŠ¶æ€å˜é‡çš„GDBè„šæœ¬
+ä»€ä¹ˆæ˜¯KGTP
+KGTP æ˜¯ä¸€ä¸ª çµæ´»ï¼Œè½»é‡çº§ï¼Œå®žæ—¶ Linux (åŒ…æ‹¬ Android) è°ƒè¯•å™¨ å’Œ è·Ÿè¸ªå™¨ ã€‚
+ä½¿ç”¨KGTP ä¸éœ€è¦ åœ¨Linuxå†…æ ¸ä¸Šæ‰“PATCHæˆ–è€…é‡æ–°ç¼–è¯‘ï¼Œåªè¦ç¼–è¯‘KGTPæ¨¡å—å¹¶insmodå°±å¯ä»¥ã€‚
+
+å…¶è®©Linuxå†…æ ¸æä¾›ä¸€ä¸ªè¿œç¨‹GDBè°ƒè¯•æŽ¥å£ï¼ŒäºŽæ˜¯åœ¨æœ¬åœ°æˆ–è€…è¿œç¨‹çš„ä¸»æœºä¸Šçš„GDBå¯ä»¥åœ¨ä¸éœ€è¦åœæ­¢å†…æ ¸çš„æƒ…å†µä¸‹ç”¨GDB tracepointå’Œå…¶ä»–ä¸€äº›åŠŸèƒ½ è°ƒè¯• å’Œ è·Ÿè¸ª Linuxå†…æ ¸å’Œåº”ç”¨ç¨‹åºã€‚
+å³ä½¿æ¿å­ä¸Šæ²¡æœ‰GDBè€Œä¸”å…¶æ²¡æœ‰å¯ç”¨çš„è¿œç¨‹æŽ¥å£ï¼ŒKGTPä¹Ÿå¯ä»¥ç”¨ç¦»çº¿è°ƒè¯•çš„åŠŸèƒ½è°ƒè¯•å†…æ ¸ï¼ˆè§http://code.google.com/p/kgtp/wiki/HOWTOCN#/sys/kernel/debug/gtpframeå’Œç¦»çº¿è°ƒè¯•ï¼‰ã€‚
+
+KGTPæ”¯æŒ X86-32 ï¼Œ X86-64 ï¼Œ MIPS å’Œ ARM ã€‚
+KGTPåœ¨Linuxå†…æ ¸ 2.6.18åˆ°upstream ä¸Šéƒ½è¢«æµ‹è¯•è¿‡ã€‚
+
+KGTPæ–°ç”¨æˆ·å¯ä»¥åŽ»çœ‹ä¸€ä¸‹ Quickstart ã€‚
+
+è¯·åˆ° UPDATE åŽ»çœ‹KGTPçš„æ›´æ–°ä¿¡æ¯ã€‚
+
+éœ€è¦å¸®åŠ©æˆ–è€…æ±‡æŠ¥é—®é¢˜
+ä½ å¯ä»¥æŠŠé—®é¢˜å‘åˆ° http://code.google.com/p/kgtp/issues/list æˆ–è€…å†™ä¿¡åˆ° kgtp@freelists.org æˆ–è€…å†™ä¿¡åˆ° teawater@gmail.com ã€‚
+KGTPå°ç»„å°†å°½å…¨åŠ›å¸®åŠ©ä½ ã€‚
+
+GDBè°ƒè¯•æ™®é€šç¨‹åºå’ŒKGTPçš„åŒºåˆ«è¡¨
+è¿™ä¸ªè¡¨æ˜¯ç»™åœ¨ä½¿ç”¨è¿‡GDBè°ƒè¯•ç¨‹åºçš„äººå‡†å¤‡çš„ï¼Œä»–å¯ä»¥å¸®åŠ©ä½ ç†è§£å’Œè®°ä½KGTPçš„åŠŸèƒ½ã€‚
+
+åŠŸèƒ½	GDBè°ƒè¯•æ™®é€šç¨‹åº	GDBæŽ§åˆ¶KGTPè°ƒè¯•Linuxå†…æ ¸
+å‡†å¤‡å·¥ä½œ	 ç³»ç»Ÿé‡Œå®‰è£…äº†GDBã€‚
+ç¨‹åºç”¨ "-g"é€‰é¡¹ç¼–è¯‘ã€‚	 å› ä¸ºä½¿ç”¨äº†ä¸€äº›GDBä¸­çš„æ–°åŠŸèƒ½ï¼Œæ‰€ä»¥KGTPéœ€è¦å’ŒGDB 7.6æˆ–è€…æ›´æ–°çš„ç‰ˆæœ¬ã€‚å¦‚æžœä½ çš„ç³»ç»Ÿä¸æä¾›è¿™ä¹ˆæ–°ç‰ˆæœ¬çš„GDBï¼Œä½ å¯ä»¥åˆ°http://code.google.com/p/gdbt/å–å¾—æ–°ç‰ˆæœ¬GDBã€‚åŒæ—¶ä½ å¯ä»¥åœ¨è¿™é‡Œå–å¾—ä¸€æ­¥ä¸€æ­¥ç¼–è¯‘æ–°ç‰ˆæœ¬GDBçš„ä»‹ç»ã€‚
+ä½ è¿˜éœ€è¦åšä¸€äº›Linuxå†…æ ¸å’ŒKGTPçš„å‡†å¤‡å·¥ä½œï¼Œè¯·åˆ° http://code.google.com/p/kgtp/wiki/HOWTOCN#ä½¿ç”¨KGTPå‰çš„å‡†å¤‡å·¥ä½œ å–å¾—å¦‚æžœåšçš„ä»‹ç»ã€‚
+Attach	 ä½¿ç”¨å‘½ä»¤"gdb -p pid"æˆ–è€…GDBå‘½ä»¤"attach pid"å¯ä»¥attachç³»ç»Ÿä¸­çš„æŸä¸ªç¨‹åº.	 éœ€è¦å…ˆinsmod gtp.koï¼Œè¯·çœ‹ https://code.google.com/p/kgtp/wiki/HOWTOCN#æ‰§è¡Œã€‚
+ç„¶åŽè®©GDBè¿žæŽ¥KGTP,è¯·çœ‹https://code.google.com/p/kgtp/wiki/HOWTOCN#è®©GDBè¿žæŽ¥åˆ°KGTPã€‚
+è¯· æ³¨æ„ GDBè¿žæŽ¥åˆ°KGTPä»¥åŽï¼ŒLinuxå†…æ ¸ä¸ä¼šåœæ­¢ã€‚
+Breakpoints	 GDBå‘½ä»¤"b place_will_stop"ï¼Œè®©ç¨‹åºåœ¨æ‰§è¡Œè¿™ä¸ªå‘½ä»¤åŽæ‰§è¡Œï¼Œåˆ™ç¨‹åºå°†åœæ­¢åœ¨è®¾ç½®è¿™ä¸ªæ–­ç‚¹çš„åœ°æ–¹ã€‚	 KGTPä¸æ”¯æŒæ–­ç‚¹ä½†æ˜¯æ”¯æŒtracepointã€‚Tracepointså¯ä»¥è¢«çœ‹ä½œä¸€ç§ç‰¹æ®Šçš„æ–­ç‚¹ã€‚å…¶å¯ä»¥è®¾ç½®åœ¨Linux kernelä¸­çš„ä¸€äº›åœ°æ–¹ç„¶åŽå®šä¹‰ä¸€äº›å‘½ä»¤åˆ°å®ƒçš„actionä¸­ã€‚å½“tracepointå¼€å§‹çš„æ—¶å€™ï¼Œä»–ä»¬å°†ä¼šåœ¨å†…æ ¸æ‰§è¡Œåˆ°è¿™äº›åœ°æ–¹çš„æ—¶å€™æ‰§è¡Œè¿™äº›å‘½ä»¤ã€‚å½“tracepointåœæ­¢çš„æ—¶å€™ï¼Œä½ å¯ä»¥åƒæ–­ç‚¹åœæ­¢ç¨‹åºåŽä½ åšçš„é‚£æ ·ç”¨GDBå‘½ä»¤åˆ†æžtracepointå¾—åˆ°çš„æ•°æ®ã€‚ åŒºåˆ« æ˜¯æ–­ç‚¹ä¼šåœæ­¢ç¨‹åºä½†æ˜¯KGTPä¸­çš„tracepointä¸ä¼šã€‚ è¯·åˆ° https://code.google.com/p/kgtp/wiki/HOWTOCN#GDB_tracepoint çœ‹å¦‚ä½•ä½¿ç”¨å®ƒã€‚
+è¯»Memory	 GDBåœæ­¢ç¨‹åºåŽ(ä¹Ÿè®¸ä¸éœ€è¦)ï¼Œå®ƒå¯ä»¥ç”¨GDBå‘½ä»¤"print"æˆ–è€…"x"ç­‰åº”ç”¨ç¨‹åºçš„å†…å­˜ã€‚	 ä½ å¯ä»¥åœ¨tracepointä¸­è®¾ç½®ç‰¹æ®Šçš„actionæ”¶é›†å†…å­˜åˆ°traceframeä¸­ï¼Œåœ¨tracepointåœæ­¢åŽå–å¾—ä»–ä»¬çš„å€¼ã€‚https://code.google.com/p/kgtp/wiki/HOWTOCN#collect_expr1,_expr2,_... http://code.google.com/p/kgtp/wiki/HOWTOCN#ç”¨tfindé€‰æ‹©traceå¸§ç¼“å­˜é‡Œé¢çš„æ¡ç›® 
+æˆ–è€…ä½ å¯ä»¥åœ¨å†…æ ¸æˆ–è€…åº”ç”¨ç¨‹åºæ‰§è¡Œçš„æ—¶å€™ç›´æŽ¥è¯»ä»–ä»¬çš„å†…å­˜ã€‚https://code.google.com/p/kgtp/wiki/HOWTOCN#åœ¨æ™®é€šæ¨¡å¼ç›´æŽ¥è®¿é—®å½“å‰å€¼
+Step å’Œ continue	 GDBå¯ä»¥ç”¨å‘½ä»¤"continue"ç»§ç»­ç¨‹åºçš„æ‰§è¡Œï¼Œç”¨CTRL-Cåœæ­¢å…¶ã€‚	 KGTPä¸ä¼šåœæ­¢Linuxå†…æ ¸ï¼Œä½†æ˜¯tracepointå¯ä»¥å¼€å§‹å’Œåœæ­¢ã€‚https://code.google.com/p/kgtp/wiki/HOWTOCN#å¯åŠ¨å’Œåœæ­¢_tracepoint 
+æˆ–è€…ç”¨ while-stepping tracepointè®°å½•ä¸€å®šæ¬¡æ•°çš„single-steppingç„¶åŽè®©KGTPåˆ‡æ¢åˆ°å›žæ”¾æ¨¡å¼ã€‚è¿™æ ·å…¶å°±æ”¯æŒæ‰§è¡Œå’Œæ–¹å‘æ‰§è¡Œå‘½ä»¤äº†ã€‚ https://code.google.com/p/kgtp/wiki/HOWTOCN#ä½¿ç”¨while-steppingè®©Linuxå†…æ ¸åšå•æ­¥
+Backtrace	 GDBå¯ä»¥ç”¨å‘½ä»¤"backtrace"æ‰“å°å…¨éƒ¨è°ƒç”¨æ ˆã€‚	 KGTPä¹Ÿå¯ä»¥ã€‚https://code.google.com/p/kgtp/wiki/HOWTOCN#å¦‚ä½•_backtrace_(stack_dump)
+Watchpoint	 GDBå¯ä»¥ç”¨watchpointè®©ç¨‹åºåœ¨æŸäº›å†…å­˜è®¿é—®å‘ç”Ÿçš„æ—¶å€™åœæ­¢ã€‚	 KGTPå¯ä»¥ç”¨watch tracepointè®°å½•å†…å­˜è®¿é—®ã€‚ https://code.google.com/p/kgtp/wiki/HOWTOCN#å¦‚ä½•ç”¨watch_tracepointæŽ§åˆ¶ç¡¬ä»¶æ–­ç‚¹è®°å½•å†…å­˜è®¿é—®
+è°ƒç”¨å‡½æ•°	 GDBå¯ä»¥ç”¨å‘½ä»¤"call function(xx,xx)"è°ƒç”¨ç¨‹åºä¸­çš„å‡½æ•°ã€‚	 KGTPå¯ä»¥ç”¨æ’ä»¶è°ƒç”¨å†…æ ¸ä¸­çš„å‡½æ•°ã€‚https://code.google.com/p/kgtp/wiki/HOWTOCN#å¦‚ä½•å¢žåŠ ç”¨Cå†™çš„æ’ä»¶
+ä½¿ç”¨KGTPå‰çš„å‡†å¤‡å·¥ä½œ
+Linuxå†…æ ¸
+å¦‚æžœä½ çš„ç³»ç»Ÿå†…æ ¸æ˜¯è‡ªå·±ç¼–è¯‘çš„
+è¦ä½¿ç”¨KGTPï¼Œä½ éœ€è¦æ‰“å¼€ä¸‹é¢è¿™äº›å†…æ ¸é€‰é¡¹ï¼š
+
+General setup  --->
+        [*] Kprobes
+
+[*] Enable loadable module support  --->
+
+Kernel hacking  --->
+        [*] Debug Filesystem
+        [*] Compile the kernel with debug info
+å¦‚æžœä½ æ”¹äº†Linuxå†…æ ¸configçš„ä»»ä½•é¡¹ç›®ï¼Œè¯·é‡æ–°ç¼–è¯‘ä½ çš„å†…æ ¸ã€‚
+
+å¦‚æžœæ˜¯Androidå†…æ ¸
+é»˜è®¤çš„Android Linuxå†…æ ¸configåº”è¯¥ä¸æ”¯æŒKGTPã€‚è¦ä½¿ç”¨KGTPï¼Œä½ éœ€è¦æ‰“å¼€ä¸‹é¢è¿™äº›å†…æ ¸é€‰é¡¹ï¼š
+
+[*] Enable loadable module support  --->
+General setup  ---> 
+        [*] Prompt for development and/or incomplete code/drivers
+        [*] Kprobes
+Kernel hacking  --->
+        [*] Debug Filesystem
+        [*] Compile the kernel with debug info
+å¦‚æžœä½ æ”¹äº†Linuxå†…æ ¸configçš„ä»»ä½•é¡¹ç›®ï¼Œè¯·é‡æ–°ç¼–è¯‘ä½ çš„å†…æ ¸ã€‚
+
+å¦‚æžœä½ çš„ç³»ç»Ÿå†…æ ¸æ˜¯å‘è¡Œç‰ˆè‡ªå¸¦çš„
+ä½ éœ€è¦å®‰è£…ä¸€äº›Linuxå†…æ ¸è½¯ä»¶åŒ…ã€‚
+
+Ubuntu
+å®‰è£…Linuxå†…æ ¸è°ƒè¯•é•œåƒçš„æ ‡å‡†æ–¹æ³•
+1) å¢žåŠ è°ƒè¯•æºåˆ°Ubuntuæºåˆ—è¡¨ã€‚
+
+åœ¨å‘½ä»¤è¡ŒæŒ‰ç…§ä¸‹é¢çš„å‘½ä»¤åˆ›å»ºæ–‡ä»¶ /etc/apt/sources.list.d/ddebs.listï¼š
+echo "deb http://ddebs.ubuntu.com $(lsb_release -cs) main restricted universe multiverse" | \
+sudo tee -a /etc/apt/sources.list.d/ddebs.list
+ç¨³å®šç‰ˆæœ¬ï¼ˆä¸èƒ½æ˜¯alphaæˆ–è€…betasï¼‰éœ€è¦ç”¨å‘½ä»¤è¡Œå¢žåŠ ä¸‹é¢å‡ è¡Œï¼š
+echo "deb http://ddebs.ubuntu.com $(lsb_release -cs)-updates main restricted universe multiverse
+deb http://ddebs.ubuntu.com $(lsb_release -cs)-security main restricted universe multiverse
+deb http://ddebs.ubuntu.com $(lsb_release -cs)-proposed main restricted universe multiverse" | \
+sudo tee -a /etc/apt/sources.list.d/ddebs.list
+å¯¼å…¥è°ƒè¯•ç¬¦å·ç­¾åkeyï¼š
+sudo apt-key adv --keyserver keyserver.ubuntu.com --recv-keys 428D7C01
+è¿è¡Œï¼š
+sudo apt-get update
+
+2) å®‰è£…Linuxå†…æ ¸è°ƒè¯•é•œåƒ
+
+sudo apt-get install linux-image-$(uname -r)-dbgsym
+äºŽæ˜¯ä½ å¯ä»¥åœ¨"/usr/lib/debug/boot/vmlinux-$(uname -r)"æ‰¾åˆ°å†…æ ¸è°ƒè¯•é•œåƒã€‚
+è¯· æ³¨æ„ å½“å†…æ ¸æ›´æ–°çš„æ—¶å€™è¿™ä¸€æ­¥ å®‰è£…Linuxå†…æ ¸è°ƒè¯•é•œåƒ éœ€è¦å†åšä¸€æ¬¡ã€‚
+
+å®‰è£…Linuxå†…æ ¸è°ƒè¯•é•œåƒçš„ç¬¬äºŒæ–¹æ³•
+å¦‚æžœç”¨æ ‡å‡†æ–¹æ³•å‡ºçŽ°é—®é¢˜ï¼Œè¯·ç”¨ä¸‹é¢è¿™äº›å‘½ä»¤å®‰è£…Linuxå†…æ ¸è°ƒè¯•é•œåƒã€‚
+
+wget http://ddebs.ubuntu.com/pool/main/l/linux/linux-image-$(uname -r)-dbgsym_$(dpkg -s linux-image-$(uname -r) | grep ^Version: | sed 's/Version: //')_$(uname -i | sed 's/x86_64/amd64/').ddeb
+sudo dpkg -i linux-image-$(uname -r)-dbgsym_$(dpkg -s linux-image-$(uname -r) | grep ^Version: | sed 's/Version: //')_$(uname -i | sed 's/x86_64/amd64/').ddeb
+è¯· æ³¨æ„ å½“å†…æ ¸æ›´æ–°çš„æ—¶å€™è¿™ä¸ªæ–¹æ³•éœ€è¦é‡æ–°åšä¸€æ¬¡ã€‚
+
+å®‰è£…å†…æ ¸å¤´æ–‡ä»¶åŒ…
+sudo apt-get install linux-headers-generic
+å®‰è£…å†…æ ¸æºç 
+å®‰è£…æºç åŒ…ï¼š
+sudo apt-get install linux-source
+è§£åŽ‹ç¼©æºç ï¼š
+sudo mkdir -p /build/buildd/
+sudo tar vxjf /usr/src/linux-source-$(uname -r | sed 's/-.*//').tar.bz2 -C /build/buildd/
+sudo rm -rf /build/buildd/linux-$(uname -r | sed 's/-.*//')
+sudo mv /build/buildd/linux-source-$(uname -r | sed 's/-.*//') /build/buildd/linux-$(uname -r | sed 's/-.*//')
+è¯· æ³¨æ„ å½“å†…æ ¸æ›´æ–°çš„æ—¶å€™è¿™ä¸€æ­¥ å®‰è£…å†…æ ¸æºç  éœ€è¦å†åšä¸€æ¬¡ã€‚
+
+Fedora
+å®‰è£…Linuxå†…æ ¸è°ƒè¯•é•œåƒ
+ä½¿ç”¨ä¸‹é¢çš„å‘½ä»¤ï¼š
+
+sudo debuginfo-install kernel
+æˆ–è€…ï¼š
+
+sudo yum --enablerepo=fedora-debuginfo install kernel-debuginfo
+äºŽæ˜¯ä½ å¯ä»¥åœ¨"/usr/lib/debug/lib/modules/$(uname -r)/vmlinux"æ‰¾åˆ°å†…æ ¸è°ƒè¯•é•œåƒã€‚
+
+å®‰è£…Linuxå†…æ ¸å¼€å‘åŒ…
+sudo yum install kernel-devel-$(uname -r)
+è¯· æ³¨æ„ åœ¨å‡çº§è¿‡å†…æ ¸åŒ…ä¹‹åŽï¼Œä½ å¯èƒ½éœ€è¦é‡æ–°è°ƒç”¨è¿™ä¸ªå‘½ä»¤ã€‚
+
+å…¶ä»–ç³»ç»Ÿ
+éœ€è¦å®‰è£…Linuxå†…æ ¸è°ƒè¯•é•œåƒå’ŒLinuxå†…æ ¸æºç åŒ…ã€‚
+
+ç¡®å®šLinuxå†…æ ¸è°ƒè¯•é•œåƒæ˜¯æ­£ç¡®çš„
+å› ä¸ºGDBä»ŽLinuxå†…æ ¸è°ƒè¯•é•œåƒé‡Œå–å¾—åœ°å€ä¿¡æ¯å’Œè°ƒè¯•ä¿¡æ¯ï¼Œæ‰€ä»¥ä½¿ç”¨æ­£ç¡®çš„Linuxå†…æ ¸è°ƒè¯•é•œåƒæ˜¯éžå¸¸é‡è¦çš„ã€‚æ‰€ä»¥åœ¨ä½¿ç”¨KGTPå‰ï¼Œè¯·å…ˆåšæ£€æŸ¥ã€‚
+æœ‰2ä¸ªæ–¹æ³•è¿›è¡Œæ£€æŸ¥ï¼Œæˆ‘å»ºè®®2ä¸ªæ–¹æ³•éƒ½åšä¸€æ¬¡æ¥ç¡®ä¿Linuxå†…æ ¸è°ƒè¯•é•œåƒæ˜¯æ­£ç¡®çš„ã€‚ 
+
+è¯· æ³¨æ„ å¦‚æžœä½ ç¡®å®šä½¿ç”¨äº†æ­£ç¡®çš„Linuxå†…æ ¸è°ƒè¯•é•œåƒä½†æ˜¯ä¸èƒ½é€šè¿‡è¿™ä¸ªä¸¤ä¸ªæ–¹æ³•ã€‚è¯·çœ‹ http://code.google.com/p/kgtp/wiki/HOWTOCN#å¤„ç†Linuxå†…æ ¸è°ƒè¯•é•œåƒåœ°å€ä¿¡æ¯å’ŒLinuxå†…æ ¸æ‰§è¡Œæ—¶ ã€‚
+
+å½“å‰Linuxå†…æ ¸è°ƒè¯•é•œåƒåœ¨å“ª
+åœ¨UBUNTUä¸­ï¼Œä½ å¯ä»¥åœ¨"/usr/lib/debug/boot/vmlinux-$(uname -r)"æ‰¾åˆ°å®ƒã€‚
+åœ¨Fedoraä¸­ï¼Œä½ å¯ä»¥åœ¨"/usr/lib/debug/lib/modules/$(uname -r)/vmlinux"æ‰¾åˆ°å®ƒã€‚
+å¦‚æžœä½ è‡ªå·±ç¼–è¯‘çš„å†…æ ¸ï¼Œä½ å¯ä»¥åœ¨å†…æ ¸ç¼–è¯‘ç›®å½•æ‰¾åˆ°vmlinuxæ–‡ä»¶ã€‚
+
+ä½¿ç”¨/proc/kallsyms
+åœ¨è¿è¡Œç€è¦traceçš„å†…æ ¸çš„ç³»ç»Ÿä¸Šï¼Œç”¨ä¸‹é¢çš„å‘½ä»¤å–å¾—sys_readå’Œsys_writeçš„åœ°å€ï¼š
+
+sudo cat /proc/kallsyms | grep sys_read
+ffffffff8117a520 T sys_read
+sudo cat /proc/kallsyms | grep sys_write
+ffffffff8117a5b0 T sys_write
+äºŽæ˜¯æˆ‘ä»¬å°±å¯ä»¥å¾—åˆ°sys_readçš„åœ°å€æ˜¯0xffffffff8117a520ï¼Œsys_writeçš„åœ°å€æ˜¯0xffffffff8117a5b0ã€‚
+ä¹‹åŽæˆ‘ä»¬ç”¨GDBä»ŽLinuxå†…æ ¸è°ƒè¯•é•œåƒä¸­å–å¾—sys_readå’Œsys_writeçš„åœ°å€ï¼š
+
+gdb ./vmlinux
+(gdb) p sys_read
+$1 = {long int (unsigned int, char *, size_t)} 0xffffffff8117a520 <sys_read>
+(gdb) p sys_write
+$2 = {long int (unsigned int, const char *, size_t)} 0xffffffff8117a5b0 <sys_write>
+sys_readå’Œsys_writeçš„åœ°å€ä¸€æ ·ï¼Œæ‰€ä»¥Linuxå†…æ ¸è°ƒè¯•é•œåƒæ˜¯æ­£ç¡®çš„ã€‚
+
+ä½¿ç”¨linux_banner
+sudo gdb ./vmlinux
+(gdb) p linux_banner
+$1 = "Linux version 3.4.0-rc4+ (teawater@teawater-Precision-M4600) (gcc version 4.6.3 (GCC) ) #3 SMP Tue Apr 24 13:29:05 CST 2012\n"
+linux_banneræ˜¯Linuxå†…æ ¸è°ƒè¯•é•œåƒé‡Œçš„å†…æ ¸ä¿¡æ¯ã€‚
+ä¹‹åŽï¼Œæ ¹æ® http://code.google.com/p/kgtp/wiki/HOWTOCN#è®©GDBè¿žæŽ¥åˆ°KGTP é‡Œçš„æ–¹æ³•è¿žæŽ¥åˆ°KGTPä¸Šå¹¶å†æ¬¡æ‰“å°linux_bannerã€‚
+
+(gdb) target remote /sys/kernel/debug/gtp
+Remote debugging using /sys/kernel/debug/gtp
+0x0000000000000000 in irq_stack_union ()
+(gdb) p linux_banner
+$2 = "Linux version 3.4.0-rc4+ (teawater@teawater-Precision-M4600) (gcc version 4.6.3 (GCC) ) #3 SMP Tue Apr 24 13:29:05 CST 2012\n"
+è¿™ä¸ªlinux_banneræ˜¯KGTPæ­£åœ¨traceçš„å†…æ ¸çš„å†…æ ¸ä¿¡æ¯ï¼Œå¦‚æžœç›¸åŒï¼Œåˆ™Linuxå†…æ ¸è°ƒè¯•é•œåƒæ˜¯æ­£ç¡®çš„ã€‚
+
+å¤„ç†Linuxå†…æ ¸è°ƒè¯•é•œåƒåœ°å€ä¿¡æ¯å’ŒLinuxå†…æ ¸æ‰§è¡Œæ—¶ä¸åŒçš„é—®é¢˜
+åœ¨X86_32ä¸Šï¼Œç”¨ http://code.google.com/p/kgtp/wiki/HOWTOCN#ç¡®å®šLinuxå†…æ ¸è°ƒè¯•é•œåƒæ˜¯æ­£ç¡®çš„ ä»‹ç»çš„æ–¹æ³•å‘çŽ°Linuxå†…æ ¸è°ƒè¯•é•œåƒåœ°å€ä¿¡æ¯å’ŒLinuxå†…æ ¸æ‰§è¡Œæ—¶ä¸åŒï¼Œè€Œä¸”ç¡®å®šä½¿ç”¨çš„Linuxå†…æ ¸è°ƒè¯•é•œåƒæ˜¯æ­£ç¡®çš„ã€‚
+è¿™ä¸ªé—®é¢˜æ˜¯å› ä¸ºï¼š
+
+Processor type and features  --->
+        (0x1000000) Physical address where the kernel is loaded
+        (0x100000) Alignment value to which kernel should be aligned
+è¿™ä¸ªä¸¤ä¸ªå‚æ•°çš„å€¼ä¸åŒã€‚è¯· æ³¨æ„ "Physical address where the kernel is loaded" æœ‰æ—¶ä¸ä¼šåœ¨é…ç½®çš„æ—¶å€™æ˜¾ç¤ºï¼Œä½ å¯ä»¥é€šè¿‡æœç´¢ "PHYSICAL_START" å–å¾—å®ƒçš„å€¼ã€‚
+
+ä½ å¯ä»¥é€šè¿‡ä¿®æ”¹ "Alignment value to which kernel should be aligned" çš„å€¼å’Œ "Physical address where the kernel is loaded" æ¥å¤„ç†è¿™ä¸ªé—®é¢˜ã€‚
+è¿™ä¸ªé—®é¢˜ä¸å½±å“X86_64ã€‚
+
+å–å¾—KGTP
+é€šè¿‡httpä¸‹è½½KGTP
+è¯·åˆ° http://code.google.com/p/kgtp/downloads/list æˆ–è€… UPDATE åŽ»ä¸‹è½½æºç åŒ…ã€‚
+
+é€šè¿‡svnä¸‹è½½KGTP
+ä¸‹é¢çš„å‘½ä»¤å°†è®©ä½ å–å¾—KGTPæœ€åŽçš„å‘å¸ƒç‰ˆæœ¬ï¼š
+
+svn checkout http://kgtp.googlecode.com/svn/tags/kgtp/
+
+ä¸‹é¢çš„å‘½ä»¤å°†è®©ä½ å–å¾—KGTPæ‰€æœ‰çš„æ–‡ä»¶ï¼š
+
+svn checkout http://kgtp.googlecode.com/svn/ kgtp-read-only
+kgtp-read-only/tags/ è¿™é‡Œæ˜¯KGTPæ¯ä¸ªå‘å¸ƒçš„ç‰ˆæœ¬ã€‚
+kgtp-read-only/trunk/ è¿™é‡Œæ˜¯KGTPçš„ä¸»å¹²ã€‚
+
+é…ç½®KGTP
+ä¸‹é¢è¿™éƒ¨åˆ†æ˜¯åœ¨KGTP Makefileé‡Œçš„é…ç½®ã€‚ç”¨è¿™ä¸ªé…ç½®ï¼ŒKGTPå°†è‡ªåŠ¨å’Œå½“å‰ç³»ç»Ÿçš„å†…æ ¸ä¸€èµ·ç¼–è¯‘ã€‚
+
+KERNELDIR := /lib/modules/`uname -r`/build
+CROSS_COMPILE :=
+KERELDIR è®¾ç½®äº†ä½ è¦ä¸€èµ·ç¼–è¯‘çš„å†…æ ¸ï¼Œé»˜è®¤æƒ…å†µä¸‹ï¼ŒKGTPä¼šå’Œå½“å‰çš„å†…æ ¸ä¸€èµ·ç¼–è¯‘ã€‚
+è¯· æ³¨æ„ è¿™ä¸ªç›®å½•åº”è¯¥æ˜¯å†…æ ¸ç¼–è¯‘ç›®å½•æˆ–è€…linux-headersç›®å½•ï¼Œè€Œä¸æ˜¯å†…æ ¸æºç ç›®å½•ã€‚å†…æ ¸ç¼–è¯‘ç›®å½•åªæœ‰åœ¨ç¼–è¯‘æˆåŠŸåŽæ‰èƒ½ä½¿ç”¨ã€‚
+CROSS_COMPILE è®¾ç½®ç¼–è¯‘KGTPçš„ç¼–è¯‘å™¨å‰ç¼€åã€‚ç•™ç©ºåˆ™ä½¿ç”¨é»˜è®¤ç¼–è¯‘å™¨ã€‚
+ARCH æ˜¯ä½“ç³»ç»“æž„ã€‚
+
+æˆ–è€…ä½ å¯ä»¥é€šè¿‡ä¿®æ”¹KGTPç›®å½•é‡Œçš„Makefileé€‰æ‹©ä½ è¦å’Œå“ªä¸ªå†…æ ¸ä¸€èµ·ç¼–è¯‘ä»¥åŠä½ ç”¨ä»€ä¹ˆç¼–è¯‘å™¨ç¼–è¯‘KGTPã€‚
+ä¾‹å¦‚ï¼š
+
+KERNELDIR := /home/teawater/kernel/bamd64
+CROSS_COMPILE :=x86_64-glibc_std-
+ARCH := x86_64
+KERNELDIR è®¾ç½®ä¸º /home/teawater/kernel/bamd64ã€‚ Compiler è®¾ç½®ä¸º x86_64-glibc_std-gccã€‚
+
+ç¼–è¯‘KGTP
+æ™®é€šç¼–è¯‘
+cd kgtp/
+make
+åœ¨ä¸€äº›ç¼–è¯‘çŽ¯å¢ƒä¸­(ä¾‹å¦‚Android)å°†å‡ºçŽ°ä¸€äº›ç¼–è¯‘åº”ç”¨ç¨‹åºgetmodæˆ–è€…getframeçš„é”™è¯¯ã€‚è¯·å¿½ç•¥è¿™äº›é”™è¯¯å¹¶ä½¿ç”¨ç›®å½•ä¸­çš„gtp.koã€‚
+å¦‚æžœä½ åœ¨Fedoraä¸Šå¾—åˆ°å‡ºé”™ä¿¡æ¯"/usr/bin/ld: cannot find -lc"ï¼Œè¯·ç”¨ä¸‹é¢çš„å‘½ä»¤å¤„ç†å…¶ã€‚
+
+sudo yum install glibc-static
+ç”¨ä¸€äº›ç‰¹æ®Šé€‰é¡¹ç¼–è¯‘KGTP
+å¤§éƒ¨åˆ†æ—¶å€™ï¼ŒKGTPå¯ä»¥è‡ªåŠ¨é€‰æ‹©æ­£ç¡®çš„å‚æ•°å’Œå’Œå„ç§ç‰ˆæœ¬çš„Linuxå†…æ ¸ä¸€èµ·ç¼–è¯‘ã€‚
+ä½†æ˜¯å¦‚æžœä½ æƒ³é…ç½®ä¸€äº›ç‰¹æ®Šé€‰é¡¹ï¼Œå¯ä»¥æŒ‰ç…§ä¸‹é¢çš„ä»‹ç»æ¥åšï¼š
+ç”¨è¿™ä¸ªé€‰é¡¹ï¼ŒKGTPå°†ä¸è‡ªåŠ¨é€‰æ‹©ä»»ä½•ç¼–è¯‘é€‰é¡¹ã€‚
+
+make AUTO=0
+ç”¨è¿™ä¸ªé€‰é¡¹ï¼ŒKGTPå°†ä½¿ç”¨ç®€å•frameæ›¿ä»£KGTP ring bufferã€‚
+ç®€å•frameä¸æ”¯æŒgtpframe_pipeï¼Œå®ƒçŽ°åœ¨åªç”¨æ¥è°ƒè¯•KGTPã€‚
+
+make AUTO=0 FRAME_SIMPLE=1
+ç”¨è¿™ä¸ªé€‰é¡¹ï¼Œ$clockå°†è¿”å›žrdtscçš„å€¼è€Œä¸æ˜¯local_clockã€‚
+
+make AUTO=0 CLOCK_CYCLE=1
+ç”¨è¿™ä¸ªé€‰é¡¹ï¼ŒKGTPå¯ä»¥ç”¨procfsæ›¿ä»£debugfsã€‚
+
+make AUTO=0 USE_PROC=1
+è¿™äº›é€‰çº¿å¯ä»¥ä¸€èµ·ä½¿ç”¨ï¼Œä¾‹å¦‚ï¼š
+
+make AUTO=0 FRAME_SIMPLE=1 CLOCK_CYCLE=1
+å®‰è£…å’Œå¸è½½ KGTP
+å› ä¸ºKGTPå¯ä»¥ç›´æŽ¥åœ¨ç¼–è¯‘ç›®å½•é‡Œinsmodï¼Œæ‰€ä»¥ä¸ç¼–è¯‘åŽä¸å®‰è£…ä¹Ÿå¯ä»¥ç›´æŽ¥ä½¿ç”¨ï¼ˆè§ http://code.google.com/p/kgtp/wiki/HOWTOCN#æ‰§è¡Œï¼‰ã€‚ä½†æ˜¯å¦‚æžœéœ€è¦ä¹Ÿå¯ä»¥å°†å…¶å®‰è£…åˆ°ç³»ç»Ÿä¸­ã€‚ å®‰è£…ï¼š
+
+cd kgtp/
+sudo make install
+å¸è½½ï¼š
+
+cd kgtp/
+sudo make uninstall
+å’ŒDKMSä¸€èµ·ä½¿ç”¨KGTP
+å¦‚æžœä½ éœ€è¦çš„è¯ï¼Œä½ è¿˜å¯ä»¥è®©DKMSæ¥ä½¿ç”¨KGTPã€‚
+ä¸‹é¢çš„å‘½ä»¤å°†æ‹·è´KGTPçš„æ–‡ä»¶åˆ°DKMSéœ€è¦çš„ç›®å½•ä¸­ã€‚
+
+cd kgtp/
+sudo make dkms
+äºŽæ˜¯ä½ å¯ä»¥ç”¨DKMSå‘½ä»¤æŽ§åˆ¶KGTPã€‚è¯·åˆ° http://linux.dell.com/dkms/manpage.html åŽ»çœ‹å¦‚ä½•ä½¿ç”¨DKMSã€‚
+
+ä½¿ç”¨KGTP Linuxå†…æ ¸patch
+å¤§å¤šæ•°æ—¶å€™ï¼Œä½ ä¸éœ€è¦KGTP patchï¼Œå› ä¸ºKGTPä»¥ä¸€ä¸ªLKMçš„å½¢å¼ç¼–è¯‘å®‰è£…æ›´ä¸ºæ–¹ä¾¿ã€‚ä½†æ˜¯ä¸ºäº†å¸®åŠ©äººä»¬é›†æˆKGTPåˆ°ä»–ä»¬è‡ªå·±çš„å†…æ ¸æ ‘ï¼ŒKGTPä¹Ÿæä¾›äº†patch. åœ¨KGTPç›®å½•ä¸­ï¼š
+gtp_3.7_to_upstream.patch æ˜¯ç»™Linux kernel ä»Ž3.7åˆ°upstreamçš„patchã€‚
+gtp_3.0_to_3.6.patch æ˜¯ç»™Linux kernel ä»Ž3.0åˆ°3.6çš„patchã€‚
+gtp_2.6.39.patch æ˜¯ç»™Linux kernel 2.6.39çš„patchã€‚
+gtp_2.6.33_to_2.6.38.patch æ˜¯ç»™Linux kernel ä»Ž2.6.33åˆ°2.6.38çš„patchã€‚
+gtp_2.6.20_to_2.6.32.patch æ˜¯ç»™Linux kernel ä»Ž2.6.20åˆ°2.6.32çš„patchã€‚
+gtp_older_to_2.6.19.patch æ˜¯ç»™Linux kernel 2.6.19ä»¥åŠæ›´æ—©ç‰ˆæœ¬çš„patchã€‚
+å®‰è£…å¯ä»¥å’ŒKGTPä¸€èµ·ä½¿ç”¨çš„GDB
+æ—©äºŽ7.6ç‰ˆæœ¬çš„GDBçš„tracepointåŠŸèƒ½æœ‰ä¸€äº›bugï¼Œè€Œä¸”è¿˜æœ‰ä¸€äº›åŠŸèƒ½åšçš„ä¸æ˜¯å¾ˆå¥½ã€‚
+æ‰€ä»¥å¦‚æžœä½ çš„GDBå°äºŽ7.6è¯·åˆ° https://code.google.com/p/gdbt/ åŽ»å®‰è£…å¯ä»¥å’ŒKGTPä¸€èµ·ä½¿ç”¨çš„GDBã€‚è¿™é‡Œæä¾›UBUBTU, CentOS, Fedora, Mandriva, RHEL, SLE, openSUSEæºã€‚å…¶ä»–ç³»ç»Ÿè¿˜å¯ä»¥ä¸‹è½½é™æ€ç¼–è¯‘ç‰ˆæœ¬ã€‚
+å¦‚æžœä½ æœ‰GDBçš„é—®é¢˜ï¼Œè¯·æ ¹æ®è¿™é‡Œçš„ä¿¡æ¯http://code.google.com/p/kgtp/wiki/HOWTOCN#éœ€è¦å¸®åŠ©æˆ–è€…æ±‡æŠ¥é—®é¢˜å–å¾—å¸®åŠ©ã€‚
+
+å¦‚ä½•è®©GDBè¿žæŽ¥KGTP
+è¦ä½¿ç”¨KGTPçš„åŠŸèƒ½éœ€è¦å…ˆè®©GDBè¿žæŽ¥åˆ°KGTPä¸Šã€‚
+
+æ™®é€šLinux
+å®‰è£…KGTPæ¨¡å—
+å¦‚æžœä½ å·²ç»å®‰è£…äº†KGTPåœ¨ä½ çš„ç³»ç»Ÿä¸­ï¼Œä½ å¯ä»¥ï¼š
+
+sudo modprobe gtp
+æˆ–è€…ä½ å¯ä»¥ç›´æŽ¥ä½¿ç”¨KGTPç›®å½•é‡Œçš„æ–‡ä»¶ï¼š
+
+cd kgtp/
+sudo insmod gtp.ko
+å¤„ç†æ‰¾ä¸åˆ°"/sys/kernel/debug/gtp"çš„é—®é¢˜
+å¦‚æžœä½ æœ‰è¿™ä¸ªé—®é¢˜ï¼Œè¯·å…ˆç¡®å®šä½ çš„å†…æ ¸configæ‰“å¼€äº†"Debug Filesystem"ã€‚http://code.google.com/p/kgtp/wiki/HOWTOCN#å¦‚æžœä½ çš„ç³»ç»Ÿå†…æ ¸æ˜¯è‡ªå·±ç¼–è¯‘çš„
+å¦‚æžœå®ƒä»¥åŠè¢«æ‰“å¼€äº†ï¼Œè¯·ç”¨ä¸‹é¢å‘½ä»¤mount sysfsã€‚
+
+sudo mount -t sysfs none /sys/
+ä¹Ÿè®¸ä½ å¯èƒ½ä¼šå¾—åˆ°ä¸€äº›é”™è¯¯ä¾‹å¦‚"sysfs is already mounted on /sys"ï¼Œè¯·å¿½ç•¥ä»–ä»¬ã€‚ 
+è¯·ç”¨ä¸‹é¢å‘½ä»¤mount debugfsã€‚
+
+mount -t debugfs none /sys/kernel/debug/
+ç„¶åŽä½ å°±æ‰¾åˆ°"/sys/kernel/debug/gtp"ã€‚
+
+è®©GDBè¿žæŽ¥åˆ°KGTP
+è¯· æ³¨æ„ è®©GDBæ‰“å¼€æ­£ç¡®çš„vmlinuxæ–‡ä»¶éžå¸¸é‡è¦ã€‚è¯·åˆ° http://code.google.com/p/kgtp/wiki/HOWTOCN#ç¡®å®šLinuxå†…æ ¸è°ƒè¯•é•œåƒæ˜¯æ­£ç¡®çš„ åŽ»çœ‹ä¸‹å¦‚ä½•åšã€‚
+
+GDBåœ¨æœ¬åœ°ä¸»æœºä¸Š
+sudo gdb ./vmlinux
+(gdb) target remote /sys/kernel/debug/gtp
+Remote debugging using /sys/kernel/debug/gtp
+0x0000000000000000 in ?? ()
+ç„¶åŽä½ å°±å¯ä»¥ç”¨GDBå‘½ä»¤è°ƒè¯•å’Œè·Ÿè¸ªLinuxå†…æ ¸äº†ã€‚
+
+å¦‚æžœGDBåœ¨è¿œç¨‹ä¸»æœºä¸Š
+ç”¨ncæŠŠKGTPæŽ¥å£æ˜ å°„åˆ°ç«¯å£1024ä¸Šã€‚
+
+sudo su
+nc -l 1234 </sys/kernel/debug/gtp >/sys/kernel/debug/gtp
+#(nc -l -p 1234 </sys/kernel/debug/gtp >/sys/kernel/debug/gtp ç»™è€ç‰ˆæœ¬çš„nc)
+ä¹‹åŽï¼Œncä¼šåœ¨é‚£é‡Œç­‰å¾…è¿žæŽ¥ã€‚
+è®©GDBè¿žæŽ¥1234ç«¯å£ã€‚
+
+gdb-release ./vmlinux
+(gdb) target remote xxx.xxx.xxx.xxx:1234
+ç„¶åŽä½ å°±å¯ä»¥ç”¨GDBå‘½ä»¤è°ƒè¯•å’Œè·Ÿè¸ªLinuxå†…æ ¸äº†ã€‚
+
+Android
+è¿™ä¸ªè§†é¢‘ä»‹ç»äº†ä½¿ç”¨GDBè¿žæŽ¥Androidä¸ŠKGTPçš„è¿‡ç¨‹ï¼Œå¯è®¿é—® http://www.tudou.com/programs/view/qCumSPhByFI/ æˆ–è€… http://youtu.be/9YMpAvsl37I è¿›è¡Œè§‚çœ‹ã€‚
+
+å®‰è£…KGTPæ¨¡å—
+ç¬¬ä¸€æ­¥ ç¡®å®šADBå·²ç»è¿žæŽ¥åˆ°Androidä¸Šã€‚
+ç¬¬äºŒæ­¥ æ‹·è´KGTPæ¨¡å—åˆ°Androidä¸Šã€‚
+
+sudo adb push gtp.ko /
+ç›®å½• "/" å¯èƒ½æ˜¯åªè¯»çš„ã€‚ä½ å¯ä»¥é€‰æ‹©å…¶ä»–ç›®å½•æˆ–è€…ç”¨å‘½ä»¤"sudo adb shell mount -o rw,remount /"æŠŠè¿™ä¸ªç›®å½•remountä¸ºå¯å†™ã€‚
+ç¬¬ä¸‰æ­¥ å®‰è£…KGTPæ¨¡å—ã€‚
+
+adb shell insmod /gtp.ko
+å¤„ç†æ‰¾ä¸åˆ°"/sys/kernel/debug/gtp"çš„é—®é¢˜
+å¦‚æžœä½ æœ‰è¿™ä¸ªé—®é¢˜ï¼Œè¯·å…ˆç¡®å®šä½ çš„å†…æ ¸configæ‰“å¼€äº†"Debug Filesystem"ã€‚http://code.google.com/p/kgtp/wiki/HOWTOCN#å¦‚æžœä½ çš„ç³»ç»Ÿå†…æ ¸æ˜¯è‡ªå·±ç¼–è¯‘çš„
+å¦‚æžœå®ƒä»¥åŠè¢«æ‰“å¼€äº†ï¼Œè¯·ç”¨ä¸‹é¢å‘½ä»¤mount sysfsã€‚
+
+sudo adb shell mount -t sysfs none /sys/
+ä¹Ÿè®¸ä½ å¯èƒ½ä¼šå¾—åˆ°ä¸€äº›é”™è¯¯ä¾‹å¦‚"Device or resource busy"ï¼Œè¯·å¿½ç•¥ä»–ä»¬ã€‚ 
+è¯·ç”¨ä¸‹é¢å‘½ä»¤mount debugfsã€‚
+
+sudo adb shell mount -t debugfs none /sys/kernel/debug/
+ç„¶åŽä½ å°±æ‰¾åˆ°"/sys/kernel/debug/gtp"ã€‚
+
+GDBè¿žæŽ¥KGTP
+ç”¨ncå°†KGTPæŽ¥å£æ˜ å°„åˆ°1024ç«¯å£ä¸Šã€‚
+
+adb forward tcp:1234 tcp:1234
+adb shell "nc -l -p 1234 </sys/kernel/debug/gtp >/sys/kernel/debug/gtp"
+#(adb shell "nc -l 1234 </sys/kernel/debug/gtp >/sys/kernel/debug/gtp" ç»™æ–°ç‰ˆæœ¬çš„nc)
+ä¹‹åŽï¼Œncä¼šåœ¨é‚£é‡Œç­‰å¾…è¿žæŽ¥ã€‚
+è®©GDBè¿žæŽ¥1234ç«¯å£ã€‚
+
+gdb-release ./vmlinux
+(gdb) target remote :1234
+ç„¶åŽä½ å°±å¯ä»¥ç”¨GDBå‘½ä»¤è°ƒè¯•å’Œè·Ÿè¸ªLinuxå†…æ ¸äº†ã€‚
+
+å¢žåŠ æ¨¡å—çš„ç¬¦å·ä¿¡æ¯åˆ°GDB
+æœ‰æ—¶ä½ éœ€è¦æ·»åŠ ä¸€ä¸ªLinuxå†…æ ¸æ¨¡å—çš„ç¬¦å·ä¿¡æ¯åˆ°GDBå¥½è°ƒè¯•å…¶ã€‚
+æ‰‹åŠ¨å¢žåŠ ç¬¦å·ä¿¡æ¯ä¸å¤ªå®¹æ˜“ï¼Œæ‰€ä»¥KGTPåŒ…é‡ŒåŒ…å«äº†GDB Pythonè„šæœ¬"getmod.py"å’Œç¨‹åº"getmod"å¯ä»¥å¸®åˆ°ä½ ã€‚
+
+å¦‚ä½•ä½¿ç”¨getmod
+"getmod" æ˜¯ç”¨Cå†™çš„æ‰€ä»¥ä½ å¯ä»¥æŠŠå®ƒç”¨åœ¨ä»»ä½•åœ°æ–¹å³ä½¿æ˜¯ä¸€ä¸ªåµŒå…¥å¼çŽ¯å¢ƒã€‚
+ä¾‹å¦‚ï¼š
+
+#ä¸‹é¢çš„å‘½ä»¤å°†æŠŠLinuxå†…æ ¸æ¨¡å—ä¿¡æ¯ä»¥GDBå‘½ä»¤çš„æ ¼å¼ä¿å­˜åˆ°æ–‡ä»¶/tmp/miã€‚
+sudo getmod >/tmp/mi
+#åœ¨GDBé‚£è¾¹ï¼š
+(gdb) source /tmp/mi
+add symbol table from file "/lib/modules/2.6.39-rc5+/kernel/fs/nls/nls_iso8859-1.ko" at
+        .text_addr = 0xf80de000
+        .note.gnu.build-id_addr = 0xf80de088
+        .exit.text_addr = 0xf80de074
+        .init.text_addr = 0xf8118000
+        .rodata.str1.1_addr = 0xf80de0ac
+        .rodata_addr = 0xf80de0c0
+        __mcount_loc_addr = 0xf80de9c0
+        .data_addr = 0xf80de9e0
+        .gnu.linkonce.this_module_addr = 0xf80dea00
+#è¿™æ¡GDBå‘½ä»¤åŽï¼Œæ‰€æœ‰Linuxå†…æ ¸æ¨¡å—ä¿¡æ¯éƒ½è¢«è£…è½½è¿›GDBäº†ã€‚
+#After this GDB command, all the Linux Kernel module info is loaded into GDB.
+å¦‚æžœä½ ä½¿ç”¨è¿œç¨‹è°ƒè¯•æˆ–è€…ç¦»çº¿è°ƒè¯•ï¼Œä½ å¯ä»¥éœ€è¦ä¿®æ”¹åŸºæœ¬ç›®å½•ã€‚ä¸‹é¢æ˜¯ä¸€ä¸ªä¾‹å­ï¼š
+
+#/home/teawater/kernel/b26æ˜¯GDBæ‰€åœ¨ä¸»æœºä¸Šå†…æ ¸æ¨¡å—æ‰€åœ¨çš„è·¯å¾„
+sudo ./getmod -r /home/teawater/kernel/b26 >~/tmp/mi
+å¦‚ä½•ä½¿ç”¨getmod.py
+è¯· æ³¨æ„ https://code.google.com/p/gdbt/ä¸‹è½½çš„é™æ€ç¼–è¯‘GDBä¸èƒ½ä½¿ç”¨getmod.pyã€‚
+åœ¨ä½¿ç”¨getmod.pyå‰è¿žæŽ¥åˆ°KGTPã€‚
+
+(gdb) source ~/kgtp/getmod.py
+äºŽæ˜¯è¿™ä¸ªè„šæœ¬å°†è‡ªåŠ¨è£…è½½Linuxå†…æ ¸æ¨¡å—åˆ°GDBä¸­ã€‚
+
+å¦‚ä½•ä½¿ç”¨GDBæŽ§åˆ¶KGTPè·Ÿè¸ªå’Œè°ƒè¯•Linuxå†…æ ¸
+åœ¨æ™®é€šæ¨¡å¼ç›´æŽ¥è®¿é—®å½“å‰å€¼
+åœ¨GDBè¿žåˆ°KGTPä¸Šä»¥åŽï¼Œå¦‚æžœæ²¡æœ‰ç”¨GDBå‘½ä»¤"tfind"é€‰æ‹©ä¸€æ¡traceå¸§ç¼“å­˜é‡Œé¢çš„æ¡ç›®ï¼ŒGDBå°±å¤„äºŽ æ™®é€šæ¨¡å¼ã€‚äºŽæ˜¯ä½ å¯ä»¥ç›´æŽ¥è®¿é—®å†…å­˜(Linuxå†…æ ¸æˆ–è€…ç”¨æˆ·ç¨‹åº)çš„å€¼å’ŒtraceçŠ¶æ€å˜é‡çš„å€¼ã€‚
+å¦‚æžœä½ é€‰æ‹©äº†ä¸€ä¸ªtraceå¸§æ¡ç›®ï¼Œå¯ä»¥ç”¨GDBå‘½ä»¤"tfind -1"è¿”å›žåˆ°æ™®é€šæ¨¡å¼ã€‚è¯·åˆ°http://code.google.com/p/kgtp/wiki/HOWTOCN#ç”¨tfindé€‰æ‹©traceå¸§ç¼“å­˜é‡Œé¢çš„æ¡ç›®å–å¾—GDBå‘½ä»¤"tfind"çš„æ›´å¤šä¿¡æ¯ã€‚
+
+Linuxå†…æ ¸çš„å†…å­˜
+ä¾‹å¦‚ä½ å¯ä»¥ç”¨ä¸‹é¢çš„å‘½ä»¤è®¿é—®"jiffies_64"ï¼š
+
+(gdb) p jiffies_64
+æˆ–è€…ä½ å¯ä»¥ç”¨ä¸‹é¢çš„å‘½ä»¤è®¿é—®"static LIST_HEAD(modules)"çš„ç¬¬ä¸€æ¡è®°å½•ï¼š
+
+(gdb) p *((struct module *)((char *)modules->next - ((size_t) &(((struct module *)0)->list))))
+æˆ–è€…ä½ å¯ä»¥è®¿é—®"DEFINE_PER_CPU(struct device *, mce_device);"CPU0çš„æ•°æ®ï¼š
+
+p *(struct device *)(__per_cpu_offset[0]+(uint64_t)(&mce_device))
+å¦‚æžœæƒ³åœ¨ç”¨ä¸€ä¸ªGDBå‘½ä»¤æ˜¾ç¤ºå¤šä¸ªå˜é‡ï¼Œè¯·ä½¿ç”¨ä¸‹é¢çš„ä¾‹å­ï¼š
+
+(gdb) printf "%4d %4d %4d %4d %4d %4d %18d %lu\n", this_rq->cpu, this_rq->nr_running, this_rq->nr_uninterruptible, nr_active, calc_load_tasks->counter, this_rq->calc_load_active, delta, this_rq->calc_load_update
+2 1 0 0 0 0 673538312 717077240
+ç”¨æˆ·ç¨‹åºçš„å†…å­˜
+KGTPå¯ä»¥ä¸åŒåœæ­¢åº”ç”¨å±‚ç¨‹åºçš„æƒ…å†µä¸‹ç›´æŽ¥è¯»å–å…¶å†…å­˜ï¼Œä¾‹å¦‚ï¼š
+
+#è¿žæŽ¥KGTP(è¿™é‡Œå’Œå‰é¢ä»‹ç»çš„è¿žæŽ¥æ–¹æ³•ä¸åŒ)
+(gdb) target extended-remote /sys/kernel/debug/gtp
+#å¢žåŠ ä¸€ä¸ªæ–°çš„inferiorç”¨æ¥åˆ†æžåº”ç”¨ç¨‹åºçš„ä¿¡æ¯ã€‚
+(gdb) add-inferior
+Added inferior 2
+#åˆ‡æ¢åˆ°è¿™ä¸ªinferior
+(gdb) inferior 2
+[Switching to inferior 2 [<null>] (<noexec>)]
+#è½¬è½½è¿™ä¸ªç¨‹åºçš„ç¬¦å·æ–‡ä»¶
+(gdb) file ~/kernel/svn/bak/a.out
+Reading symbols from /home/teawater/kernel/svn/bak/a.out...done.
+#attachåˆ°è¿™ä¸ªè¿›ç¨‹ä¸Š(è¿™ä¸ä¼šåœæ­¢è¿™ä¸ªç¨‹åº)ã€‚
+(gdb) attach 10039
+Attaching to program: /home/teawater/kernel/svn/bak/a.out, Remote target
+Reading symbols from /lib/x86_64-linux-gnu/libc.so.6...(no debugging symbols found)...done.
+Loaded symbols for /lib/x86_64-linux-gnu/libc.so.6
+Reading symbols from /lib64/ld-linux-x86-64.so.2...(no debugging symbols found)...done.
+Loaded symbols for /lib64/ld-linux-x86-64.so.2
+0x0000000000000000 in ?? ()
+#äºŽæ˜¯å¯ä»¥è¯»è¿™ä¸ªç¨‹åºçš„å†…å­˜
+(gdb) p c
+$3 = -1222013392
+(gdb) p c
+$4 = -590910451
+åœ¨è¿™ä¸ªä¾‹å­ä¸­ï¼Œæˆ‘ä½¿ç”¨äº†ä¸€ä¸ªå¤šinferiorå‘½ä»¤ã€‚è¯·åˆ° http://sourceware.org/gdb/current/onlinedocs/gdb/Inferiors-and-Programs.html åŽ»å–å¾—å…¶æ›´å¤šç›¸å…³ä¿¡æ¯ã€‚
+
+traceçŠ¶æ€å˜é‡
+ä½ å¯ä»¥ä½¿ç”¨å’Œè®¿é—®å†…å­˜ä¸€æ ·çš„å‘½ä»¤è®¿é—®TSVã€‚ è¯·åˆ° http://code.google.com/p/kgtp/wiki/HOWTOCN#å¦‚æžœä½¿ç”¨traceçŠ¶æ€å˜é‡ å–å¾—æ›´å¤šTSVçš„ä¿¡æ¯ã€‚
+
+GDB tracepoint
+tracepointå°±æ˜¯GDBå®šä¹‰ä¸€äº›åœ°å€å’Œä¸€äº›åŠ¨ä½œã€‚åœ¨tracepointå¯åŠ¨ä¹‹åŽï¼Œå½“Linuxå†…æ ¸æ‰§è¡Œåˆ°é‚£äº›åœ°å€çš„æ—¶å€™ï¼ŒKGTPå°†æ‰§è¡Œè¿™äº›åŠ¨ä½œ(å®ƒä»¬ä¸­çš„æœ‰äº›ä¼šæ”¶é›†æ•°æ®å¹¶å­˜å…¥tracepointå¸§ç¼“å†²)å¹¶æŠŠå®ƒä»¬å‘ç»™è°ƒè¯•ç›®æ ‡(KGTP)ã€‚è€ŒåŽï¼ŒLinuxå†…æ ¸å°†ç»§ç»­æ‰§è¡Œã€‚
+KGTPæä¾›äº†ä¸€äº›æŽ¥å£å¯ä»¥è®©GDBæˆ–è€…å…¶ä»–ç¨‹åºå–å‡ºtracepointå¸§ç¼“å†²çš„æ•°æ®åšåˆ†æžã€‚
+å…³äºŽè¿™äº›æŽ¥å£ï¼Œæ–‡æ¡£å‰é¢å·²ç»ä»‹ç»äº†"/sys/kernel/debug/gtp"ï¼Œå°†åœ¨åŽé¢ä»‹ç»"/sys/kernel/debug/gtpframe" å’Œ "/sys/kernel/debug/gtpframe_pipe"ã€‚
+
+GDB tracepointæ–‡æ¡£åœ¨ http://sourceware.org/gdb/current/onlinedocs/gdb/Tracepoints.htmlã€‚
+
+è®¾ç½®tracepint
+traceå‘½ä»¤éžå¸¸ç±»ä¼¼breakå‘½ä»¤ï¼Œå®ƒçš„å‚æ•°å¯ä»¥æ˜¯æ–‡ä»¶è¡Œï¼Œå‡½æ•°åæˆ–è€…ä¸€ä¸ªåœ°å€ã€‚traceå°†å®šä¹‰ä¸€ä¸ªæˆ–è€…å¤šä¸ªåœ°å€å®šä¹‰ä¸€ä¸ªtracepointï¼ŒKGTPå°†åœ¨è¿™ä¸ªç‚¹åšä¸€äº›åŠ¨ä½œã€‚
+è¿™æ˜¯ä¸€äº›ä½¿ç”¨traceå‘½ä»¤çš„ä¾‹å­ï¼š
+
+(gdb) trace foo.c:121    // ä¸€ä¸ªæ–‡ä»¶å’Œè¡Œå·
+
+(gdb) trace +2           // 2è¡Œä»¥åŽ
+
+(gdb) trace my_function  // å‡½æ•°çš„ç¬¬ä¸€è¡Œ
+
+(gdb) trace *my_function // å‡½æ•°çš„ç¬¬ä¸€ä¸ªåœ°å€
+
+(gdb) trace *0x2117c4    // ä¸€ä¸ªåœ°å€
+è¿™ä¸ªå‡½æ•°ç¡®å®žå­˜åœ¨ä½†æ˜¯è®¾ç½®tracepointåˆ°ä¸Šé¢ä¼šå¤±è´¥å¦‚ä½•å¤„ç†
+GCCä¸ºäº†æé«˜ç¨‹åºæ‰§è¡Œæ•ˆçŽ‡ä¼šinlineä¸€äº›staticå‡½æ•°ã€‚å› ä¸ºç›®æ ‡æ–‡ä»¶æ²¡æœ‰inlineå‡½æ•°çš„ç¬¦å·ï¼Œæ‰€ä»¥ä½ ä¸èƒ½è®¾ç½®tracepointåœ¨å‡½æ•°åä¸Šã€‚
+ä½ å¯ä»¥ç”¨"trace æ–‡ä»¶:è¡Œå·"åœ¨å…¶ä¸Šè®¾ç½®æ–­ç‚¹ã€‚
+
+å¦‚ä½•è®¾ç½®æ¡ä»¶tracepoint
+http://sourceware.org/gdb/current/onlinedocs/gdb/Tracepoint-Conditions.html
+å’Œbreakpointä¸€æ ·ï¼Œæˆ‘ä»¬å¯ä»¥è®¾ç½®tracepointçš„è§¦å‘æ¡ä»¶ã€‚è€Œä¸”å› ä¸ºæ¡ä»¶æ£€æŸ¥æ˜¯åœ¨KGTPæ‰§è¡Œçš„ï¼Œæ‰€ä»¥é€Ÿåº¦æ¯”breakpointçš„æ¡ä»¶æ£€æŸ¥å¿«å¾ˆå¤šã€‚
+ä¾‹å¦‚ï¼š
+
+(gdb) trace handle_irq if (irq == 47)
+tracepoint 1çš„åŠ¨ä½œå°†åªåœ¨irqæ˜¯47çš„æ—¶å€™æ‰è¢«æ‰§è¡Œã€‚
+
+ä½ è¿˜å¯ä»¥ç”¨GDBå‘½ä»¤"condition"è®¾ç½®tracepointçš„è§¦å‘æ¡ä»¶ã€‚GDBå‘½ä»¤"condition N COND"å°†è®¾ç½®tracepoint Nåªæœ‰æ¡ä»¶CONDä¸ºçœŸçš„æ—¶å€™æ‰§è¡Œã€‚
+ä¾‹å¦‚ï¼š
+
+(gdb) trace handle_irq
+(gdb) condition 1 (irq == 47)
+GDBå‘½ä»¤"info tracepoint"å°†æ˜¾ç¤ºtracepointçš„IDã€‚
+
+$bpnumçš„å€¼æ˜¯æœ€åŽä¸€ä¸ªGDB tracepointçš„IDï¼Œæ‰€ä»¥ä½ å¯ä»¥ä¸å–å¾—tracepointçš„IDå°±ç”¨conditionæ¥è®¾ç½®æœ€åŽè®¾ç½®çš„tracepointçš„æ¡ä»¶ï¼Œä¾‹å¦‚ï¼š
+
+(gdb) trace handle_irq
+(gdb) condition $bpnum (irq == 47)
+å¦‚ä½•å¤„ç†é”™è¯¯ "Unsupported operator (null) (52) in expression."
+å¦‚æžœä½ ä½¿ç”¨å…³äºŽå­—ç¬¦ä¸²çš„æ¡ä»¶tracepointï¼Œä½ åœ¨è°ƒç”¨"tstart"çš„æ—¶å€™å¯èƒ½å¾—åˆ°è¿™ä¸ªå‡ºé”™ä¿¡æ¯ã€‚
+ä½ å¯ä»¥è½¬åŒ–charä¸ºintæ¥å¤„ç†è¿™ä¸ªé—®é¢˜ï¼Œä¾‹å¦‚ï¼š
+
+(gdb) p/x 'A'
+$4 = 0x41
+(gdb) condition 1 (buf[0] == 0x41)
+actions [num]
+è¿™ä¸ªå‘½ä»¤å°†è®¾ç½®ä¸€ç»„actionå½“tracepoint numè§¦å‘çš„æ—¶å€™æ‰§è¡Œã€‚å¦‚æžœæ²¡æœ‰è®¾ç½®numåˆ™å°†è®¾ç½®actionåˆ°æœ€è¿‘åˆ›å»ºçš„tracepointä¸Š(å› æ­¤ä½ å¯ä»¥å®šä¹‰ä¸€ä¸ªtracepointç„¶åŽç›´æŽ¥è¾“å…¥actionsè€Œä¸éœ€è¦å‚æ•°)ã€‚ç„¶åŽå°±è¦åœ¨åŽé¢è¾“å…¥actionï¼Œæœ€åŽä»¥endä¸ºç»“æŸã€‚åˆ°ç›®å‰ä¸ºæ­¢ï¼Œæ”¯æŒçš„actionæœ‰collectï¼Œtevalå’Œwhile-steppingã€‚
+
+collect expr1, expr2, ...
+å½“tracepointè§¦å‘çš„æ—¶å€™ï¼Œæ”¶é›†è¡¨è¾¾å¼çš„å€¼ã€‚è¿™ä¸ªå‘½ä»¤å¯æŽ¥å—ç”¨é€—å·åˆ†å‰²çš„ä¸€ç»„åˆ—è¡¨ï¼Œè¿™äº›åˆ—è¡¨é™¤äº†å¯ä»¥æ˜¯å…¨å±€ï¼Œå±€éƒ¨æˆ–è€…æœ¬åœ°å˜é‡ï¼Œè¿˜å¯ä»¥æ˜¯ä¸‹é¢çš„è¿™äº›å‚æ•°ï¼š
+
+$regs   æ”¶é›†å…¨éƒ¨å¯„å­˜å™¨ã€‚
+$args   æ”¶é›†å‡½æ•°å‚æ•°ã€‚
+$locals æ”¶é›†å…¨éƒ¨å±€éƒ¨å˜é‡ã€‚
+è¯· æ³¨æ„ collect ä¸€ä¸ªæŒ‡é’ˆ(collect ptr)å°†åªèƒ½collectè¿™ä¸ªæŒ‡é’ˆçš„åœ°å€. åœ¨æŒ‡é’ˆå‰é¢å¢žåŠ ä¸€ä¸ª * å°†ä¼šè®©action collectæŒ‡é’ˆæŒ‡å‘çš„æ•°æ®(collect *ptr)ã€‚
+
+teval expr1, expr2, ...
+å½“tracepointè§¦å‘çš„æ—¶å€™ï¼Œæ‰§è¡ŒæŒ‡å®šçš„è¡¨è¾¾å¼ã€‚è¿™ä¸ªå‘½ä»¤å¯æŽ¥å—ç”¨é€—å·åˆ†å‰²çš„ä¸€ç»„åˆ—è¡¨ã€‚è¡¨è¾¾å¼çš„ç»“æžœå°†è¢«åˆ é™¤ï¼Œæ‰€ä»¥æœ€ä¸»è¦çš„ä½œç”¨æ˜¯æŠŠå€¼è®¾ç½®åˆ°traceçŠ¶æ€å˜é‡ä¸­ (see http://code.google.com/p/kgtp/wiki/HOWTOCN#æ™®é€štraceçŠ¶æ€å˜é‡)ï¼Œè€Œä¸ç”¨æƒ³collectä¸€æ ·æŠŠè¿™äº›å€¼å­˜åˆ°traceå¸§ä¸­ã€‚
+
+while-stepping n
+è¯·åˆ° https://code.google.com/p/kgtp/wiki/HOWTOCN#ä½¿ç”¨while-steppingè®©Linuxå†…æ ¸åšå•æ­¥ åŽ»çœ‹å¦‚ä½•ä½¿ç”¨å®ƒã€‚
+
+å¯åŠ¨å’Œåœæ­¢ tracepoint
+tracepointåªæœ‰åœ¨ç”¨ä¸‹é¢çš„GDBå‘½ä»¤å¯åŠ¨åŽæ‰å¯ä»¥æ‰§è¡Œactionï¼š
+
+(gdb) tstart
+å®ƒå¯ä»¥ç”¨ä¸‹é¢çš„å‘½ä»¤åœæ­¢ï¼š
+
+(gdb) tstop
+Enable å’Œ disable tracepoint
+å’Œbreakpointä¸€æ ·ï¼Œtracepointå¯ä»¥ä½¿ç”¨GDBå‘½ä»¤ "enable" å’Œ "disable"ã€‚ä½†æ˜¯è¯· æ³¨æ„ å®ƒä»¬åªåœ¨tracepointåœæ­¢çš„æ—¶å€™æœ‰æ•ˆã€‚
+
+ç”¨tfindé€‰æ‹©traceå¸§ç¼“å­˜é‡Œé¢çš„æ¡ç›®
+tracepointåœæ­¢çš„æ—¶å€™ï¼ŒGDBå‘½ä»¤"tfind"å¯ä»¥ç”¨æ¥é€‰æ‹©traceå¸§ç¼“å­˜é‡Œé¢çš„æ¡ç›®ã€‚
+å½“GDBåœ¨"tfind"æ¨¡å¼çš„æ—¶å€™ï¼Œå…¶åªèƒ½æ˜¾ç¤ºtracepoint action collectçš„å­˜åœ¨äºŽè¿™ä¸ªæ¡ç›®ä¸­çš„æ•°æ®ã€‚æ‰€ä»¥GDBå°†è¾“å‡ºä¸€äº›é”™è¯¯ä¿¡æ¯å¦‚æžœæƒ³æ‰“å°æ²¡æœ‰collectçš„æ•°æ®ä¾‹å¦‚å‡½æ•°çš„å‚æ•°ã€‚è¿™ä¸æ˜¯bugï¼Œä¸ç”¨æ‹…å¿ƒã€‚
+å¦‚æžœæƒ³é€‰æ‹©ä¸‹ä¸€ä¸ªæ¡ç›®ï¼Œå¯ä»¥å†æ¬¡ä½¿ç”¨å‘½ä»¤"tfind"ã€‚è¿˜å¯ä»¥ç”¨"tfind æ¡ç›®ID"åŽ»é€‰æ‹©æŸä¸ªæ¡ç›®ã€‚
+è¦å›žåˆ°æ™®é€šæ¨¡å¼(http://code.google.com/p/kgtp/wiki/HOWTOCN#åœ¨æ™®é€šæ¨¡å¼ç›´æŽ¥è®¿é—®å½“å‰å€¼)ï¼Œè¯·ä½¿ç”¨GDBå‘½ä»¤"tfind -1"ã€‚ è¯·åˆ° http://sourceware.org/gdb/current/onlinedocs/gdb/tfind.html å–å¾—å®ƒçš„è¯¦ç»†ä¿¡æ¯ã€‚
+
+å¦‚ä½•å¤„ç†é”™è¯¯ "No such file or directory." æˆ–è€… "æ²¡æœ‰é‚£ä¸ªæ–‡ä»¶æˆ–ç›®å½•."
+å½“GDBä¸èƒ½æ‰¾åˆ°Linuxå†…æ ¸æºç çš„æ—¶å€™ï¼Œå…¶å°±ä¼šæ˜¾ç¤ºè¿™ä¸ªé”™è¯¯ä¿¡æ¯ã€‚ ä¾‹å¦‚ï¼š
+
+(gdb) tfind 
+Found trace frame 0, tracepoint 1
+#0  vfs_read (file=0xffff8801b6c3a500, buf=0x3f588b8 <Address 0x3f588b8 out of bounds>, count=8192, 
+    pos=0xffff8801eee49f48) at /build/buildd/linux-3.2.0/fs/read_write.c:365
+365     /build/buildd/linux-3.2.0/fs/read_write.c: æ²¡æœ‰é‚£ä¸ªæ–‡ä»¶æˆ–ç›®å½•.
+ä½ å¯ä»¥ç”¨GDBå‘½ä»¤ "set substitute-path" å¤„ç†å®ƒã€‚å‰é¢è¿™ä¸ªä¾‹å­Linuxå†…æ ¸æºç åœ¨"/build/buildd/test/linux-3.2.0/"ä½†æ˜¯vmlinuxè®©GDBåœ¨"/build/buildd/linux-3.2.0/"æ‰¾å†…æ ¸è¿œå•Šï¼Œä½ å¯ä»¥å¤„ç†ä»–ä»¬ï¼š
+
+(gdb) set substitute-path /build/buildd/linux-3.2.0/ /build/buildd/test/linux-3.2.0/
+(gdb) tfind 
+Found trace frame 1, tracepoint 1
+#0  vfs_read (file=0xffff8801c36e6400, buf=0x7fff51a8f110 <Address 0x7fff51a8f110 out of bounds>, count=16, 
+    pos=0xffff8801761dff48) at /build/buildd/linux-3.2.0/fs/read_write.c:365
+365     {
+GDBè¿˜æä¾›å…¶ä»–çš„å‘½ä»¤å¤„ç†æºç é—®é¢˜ï¼Œè¯·åˆ°http://sourceware.org/gdb/current/onlinedocs/gdb/Source-Path.htmlå–å¾—ä»–ä»¬çš„ä»‹ç»ã€‚
+
+ä¿å­˜traceå¸§ä¿¡æ¯åˆ°ä¸€ä¸ªæ–‡ä»¶ä¸­
+/sys/kernel/debug/gtpframeæ˜¯ä¸€ä¸ªå½“KGTPåœæ­¢æ—¶çš„tfineæ ¼å¼ï¼ˆGDBå¯ä»¥è¯»å–å®ƒï¼‰çš„æŽ¥å£ã€‚
+è¯· æ³¨æ„ æœ‰äº›"cp"ä¸èƒ½å¾ˆå¥½çš„å¤„ç†è¿™ä¸ªé—®é¢˜ï¼Œå¯ä»¥ç”¨"cat /sys/kernel/debug/gtpframe > ./gtpframe"æ‹·è´å®ƒã€‚
+ä½ å¯ä»¥åœ¨éœ€è¦çš„æ—¶å€™æ‰“å¼€æ–‡ä»¶gtpframe:
+
+(gdb) target tfile ./gtpframe
+Tracepoint 1 at 0xffffffff8114f3dc: file /home/teawater/kernel/linux-2.6/fs/readdir.c, line 24.
+Created tracepoint 1 for target's tracepoint 1 at 0xffffffff8114f3c0.
+(gdb) tfind 
+Found trace frame 0, tracepoint 1
+#0  vfs_readdir (file=0xffff880036e8f300, filler=0xffffffff8114f240 <filldir>, buf=0xffff880001e5bf38)
+    at /home/teawater/kernel/linux-2.6/fs/readdir.c:24
+24      {
+æ˜¾ç¤ºå’Œå­˜å‚¨tracepoint
+ä½ å¯ä»¥ç”¨GDBå‘½ä»¤"info tracepoints"æ˜¾ç¤ºæ‰€æœ‰çš„tracepointã€‚
+ä½ å¯ä»¥ç”¨GDBå‘½ä»¤"save tracepoints filename"ä¿å­˜æ‰€æœ‰çš„è®¾ç½®tracepointçš„å‘½ä»¤åˆ°æ–‡ä»¶filenameé‡Œã€‚äºŽæ˜¯ä½ å¯ä»¥åœ¨ä¹‹åŽç”¨GDBå‘½ä»¤"source filename"è®¾ç½®é‡æ–°è¿™äº›tracepointã€‚
+
+åˆ é™¤tracepoint
+GDBå‘½ä»¤"delete id"å°†åˆ é™¤tracepoint idã€‚å¦‚æžœ"delete"æ²¡æœ‰å‚æ•°ï¼Œåˆ™åˆ é™¤æ‰€æœ‰tracepointã€‚
+
+ç”¨tracepointä»Žå†…æ ¸ä¸­æŸç‚¹å–å¾—å¯„å­˜å™¨ä¿¡æ¯
+ä¸‹é¢æ˜¯è®°å½•å†…æ ¸è°ƒç”¨å‡½æ•°"vfs_readdir"æ—¶çš„å¯„å­˜å™¨ä¿¡æ¯çš„ä¾‹å­ï¼š
+
+(gdb) target remote /sys/kernel/debug/gtp
+(gdb) trace vfs_readdir
+Tracepoint 1 at 0xc01a1ac0: file
+/home/teawater/kernel/linux-2.6/fs/readdir.c, line 23.
+(gdb) actions
+Enter actions for tracepoint 1, one per line.
+End with a line saying just "end".
+>collect $reg
+>end
+(gdb) tstart
+(gdb) shell ls
+(gdb) tstop
+(gdb) tfind
+Found trace frame 0, tracepoint 1
+#0  0xc01a1ac1 in vfs_readdir (file=0xc5528d00, filler=0xc01a1900 <filldir64>,
+   buf=0xc0d09f90) at /home/teawater/kernel/linux-2.6/fs/readdir.c:23
+23      /home/teawater/kernel/linux-2.6/fs/readdir.c: No such file or directory.
+       in /home/teawater/kernel/linux-2.6/fs/readdir.c
+(gdb) info reg
+eax            0xc5528d00       -984445696
+ecx            0xc0d09f90       -1060069488
+edx            0xc01a1900       -1072031488
+ebx            0xfffffff7       -9
+esp            0xc0d09f8c       0xc0d09f8c
+ebp            0x0      0x0
+esi            0x8061480        134616192
+edi            0xc5528d00       -984445696
+eip            0xc01a1ac1       0xc01a1ac1 <vfs_readdir+1>
+eflags         0x286    [ PF SF IF ]
+cs             0x60     96
+ss             0x8061480        134616192
+ds             0x7b     123
+es             0x7b     123
+fs             0x0      0
+gs             0x0      0
+(gdb) tfind
+Found trace frame 1, tracepoint 1
+0xc01a1ac1      23      in /home/teawater/kernel/linux-2.6/fs/readdir.c
+(gdb) info reg
+eax            0xc5528d00       -984445696
+ecx            0xc0d09f90       -1060069488
+edx            0xc01a1900       -1072031488
+ebx            0xfffffff7       -9
+esp            0xc0d09f8c       0xc0d09f8c
+ebp            0x0      0x0
+esi            0x8061480        134616192
+edi            0xc5528d00       -984445696
+eip            0xc01a1ac1       0xc01a1ac1 <vfs_readdir+1>
+eflags         0x286    [ PF SF IF ]
+cs             0x60     96
+ss             0x8061480        134616192
+ds             0x7b     123
+es             0x7b     123
+fs             0x0      0
+gs             0x0      0
+ç”¨tracepointä»Žå†…æ ¸ä¸­æŸç‚¹å–å¾—å˜é‡çš„å€¼
+ä¸‹é¢æ˜¯è®°å½•å†…æ ¸è°ƒç”¨å‡½æ•°"vfs_readdir"æ—¶"jiffies_64"çš„å€¼çš„ä¾‹å­ï¼š
+
+(gdb) target remote /sys/kernel/debug/gtp
+(gdb) trace vfs_readdir 
+Tracepoint 1 at 0xc01ed740: file /home/teawater/kernel/linux-2.6/fs/readdir.c, line 24.
+(gdb) actions 
+Enter actions for tracepoint 1, one per line.
+End with a line saying just "end".
+>collect jiffies_64
+>collect file->f_path.dentry->d_iname
+>end
+(gdb) tstart 
+(gdb) shell ls
+arch    drivers   include  kernel    mm               Module.symvers  security  System.map  virt
+block   firmware  init     lib       modules.builtin  net             sound     t           vmlinux
+crypto  fs        ipc      Makefile  modules.order    scripts         source    usr         vmlinux.o
+(gdb) tstop 
+(gdb) tfind 
+Found trace frame 0, tracepoint 1
+#0  0xc01ed741 in vfs_readdir (file=0xf4063000, filler=0xc01ed580 <filldir64>, buf=0xd6dfdf90)
+    at /home/teawater/kernel/linux-2.6/fs/readdir.c:24
+24      {
+(gdb) p jiffies_64
+$1 = 4297248706
+(gdb) p file->f_path.dentry->d_iname
+$1 = "b26", '\000' <repeats 28 times>
+æ˜¾ç¤ºå½“å‰è¿™ä¸€æ¡traceç¼“å­˜é‡Œå­˜å‚¨çš„æ‰€æœ‰ä¿¡æ¯
+åœ¨ç”¨"tfind"é€‰æ‹©å¥½ä¸€ä¸ªæ¡ç›®åŽï¼Œä½ å¯ä»¥ç”¨"tdump"ã€‚
+
+(gdb) tdump 
+Data collected at tracepoint 1, trace frame 0:
+$cr = void
+file->f_path.dentry->d_iname = "gtp\000.google.chrome.g05ZYO\000\235\337\000\000\000\000\200\067k\364\200\067", <incomplete sequence \364>
+jiffies_64 = 4319751455
+å–å¾— tracepoint çš„çŠ¶æ€
+è¯·ç”¨GDBå‘½ä»¤"tstatus"ã€‚
+
+è®¾ç½®traceç¼“å­˜ä¸ºå¾ªçŽ¯ç¼“å­˜
+http://sourceware.org/gdb/current/onlinedocs/gdb/Starting-and-Stopping-Trace-Experiments.html
+å¸§ç¼“å­˜é»˜è®¤æƒ…å†µä¸‹ä¸æ˜¯å¾ªçŽ¯ç¼“å­˜ã€‚å½“ç¼“å­˜æ»¡äº†çš„æ—¶å€™ï¼Œtracepointå°†åœæ­¢ã€‚
+ä¸‹é¢çš„å‘½ä»¤å°†è®¾ç½®traceç¼“å­˜ä¸ºå¾ªçŽ¯ç¼“å­˜ï¼Œå½“ç¼“å­˜æ»¡äº†çš„æ—¶å€™ï¼Œå…¶å°†è‡ªåŠ¨åˆ é™¤æœ€æ—©çš„æ•°æ®å¹¶ç»§ç»­traceã€‚
+
+(gdb) set circular-trace-buffer on
+GDBæ–­å¼€çš„æ—¶å€™ä¸è¦åœæ­¢tracepoint
+http://sourceware.org/gdb/current/onlinedocs/gdb/Starting-and-Stopping-Trace-Experiments.html
+é»˜è®¤æƒ…å†µä¸‹ï¼Œå½“GDBæ–­å¼€KGTPçš„æ—¶å€™å°†è‡ªåŠ¨åœæ­¢tracepointå¹¶åˆ é™¤traceå¸§ã€‚
+ä¸‹é¢çš„å‘½ä»¤å°†æ‰“å¼€KGTP disconnect-traceã€‚åœ¨è®¾ç½®ä¹‹åŽï¼Œå½“GDBæ–­å¼€KGTPçš„æ—¶å€™ï¼ŒKGTPå°†ä¸åœæ­¢tracepointã€‚GDBé‡æ–°è¿žåˆ°KGTPçš„æ—¶å€™ï¼Œå…¶å¯ä»¥ç»§ç»­æŽ§åˆ¶KGTPã€‚
+
+(gdb) set disconnected-tracing on
+kprobes-optimizationå’Œtracepointçš„æ‰§è¡Œé€Ÿåº¦
+å› ä¸ºtracepointæ˜¯å’ŒLinuxå†…æ ¸ä¸€èµ·æ‰§è¡Œï¼Œæ‰€ä»¥å®ƒçš„é€Ÿåº¦å°†å½±å“åˆ°ç³»ç»Ÿæ‰§è¡Œçš„é€Ÿåº¦ã€‚
+KGTP tracepointæ˜¯åŸºäºŽLinuxå†…æ ¸kprobeã€‚å› ä¸ºæ™®é€škprobeæ˜¯åŸºäºŽæ–­ç‚¹æŒ‡ä»¤ï¼Œæ‰€ä»¥å®ƒçš„é€Ÿåº¦ä¸æ˜¯å¾ˆå¿«ã€‚
+
+ä½†æ˜¯å¦‚æžœä½ çš„archæ˜¯X86_64 æˆ–è€… X86_32 è€Œä¸”å†…æ ¸é…ç½®æ²¡æœ‰æ‰“å¼€"Preemptible Kernel" (PREEMPT)ï¼Œkprobeçš„é€Ÿåº¦å°†è¢«kprobes-optimization (CONFIG_OPTPROBES)æé«˜å¾ˆå¤šã€‚
+å¯ä»¥ç”¨ä¸‹é¢çš„å‘½ä»¤æ¥ç¡®è®¤ï¼š
+
+sysctl -A | grep kprobe
+debug.kprobes-optimization = 1
+è¿™ä¸ªçš„æ„æ€å°±æ˜¯ä½ çš„ç³»ç»Ÿæ”¯æŒkprobes-optimizationã€‚
+è¯· æ³¨æ„ ä¸€äº›KGTPçš„åŠŸèƒ½ä¼šå¯¼è‡´tracepointåªèƒ½ä½¿ç”¨æ™®é€škprobeå³ä½¿ç³»ç»Ÿæ”¯æŒkprobes-optimizationã€‚æ–‡æ¡£å°†åœ¨ä»‹ç»è¿™äº›åŠŸèƒ½çš„æ—¶å€™å¢žåŠ æé†’ï¼Œå¦‚æžœä½ å¾ˆä»‹æ„tracepointçš„é€Ÿåº¦å°±è¯·é¿å…ä½¿ç”¨è¿™äº›åŠŸèƒ½ã€‚
+
+å¦‚æžœä½¿ç”¨traceçŠ¶æ€å˜é‡
+http://sourceware.org/gdb/current/onlinedocs/gdb/Trace-State-Variables.html
+traceçŠ¶æ€å˜é‡ç®€ç§°TSVã€‚
+TSVå¯ä»¥åœ¨tracepoint actionå’Œconditionä¸­è¢«è®¿é—®ï¼Œå¹¶ä¸”å¯ä»¥ç›´æŽ¥è¢«GDBå‘½ä»¤è®¿é—®ã€‚
+è¯· æ³¨æ„ GDB 7.2.1å’Œæ›´æ™šçš„ç‰ˆæœ¬ç›´æŽ¥è®¿é—®traceçŠ¶æ€å˜é‡ï¼Œæ¯”ä»–ä»¬è€çš„GDBåªèƒ½é€šè¿‡å‘½ä»¤"info tvariables"å–å¾—traceçŠ¶æ€å˜é‡çš„å€¼ã€‚
+
+æ™®é€štraceçŠ¶æ€å˜é‡
+å®šä¹‰traceçŠ¶æ€å˜é‡$c.
+
+(gdb) tvariable $c
+traceçŠ¶æ€å˜é‡ $c è¢«åˆ›å»ºå¹¶åˆå§‹åŒ–0ã€‚ ä¸‹é¢çš„actionå°†ä½¿ç”¨$cè®°å½•å†…æ ¸é‡Œå‘ç”Ÿäº†å¤šå°‘æ¬¡IRQã€‚
+
+(gdb) target remote /sys/kernel/debug/gtp
+(gdb) trace handle_irq
+(gdb) actions 
+Enter actions for tracepoint 3, one per line.
+End with a line saying just "end".
+>collect $c     #Save current value of $c to the trace frame buffer.
+>teval $c=$c+1  #Increase the $c.
+>end
+ä½ è¿˜å¯ä»¥å°†æŸä¸ªå˜é‡çš„å€¼ä¼ åˆ°çŠ¶æ€å˜é‡é‡Œï¼Œä½†æ˜¯åˆ«å¿˜è®°è½¬åŒ–è¿™ä¸ªå€¼ä¸º"uint64_t"ã€‚
+
+>teval $c=(uint64_t)a
+ä½ å¯ä»¥å–å¾—$cçš„å€¼å½“traceåœ¨è¿è¡Œæˆ–è€…åœæ­¢çš„æ—¶å€™ã€‚
+
+(gdb) tstart
+(gdb) info tvariables
+$c              0           31554
+(gdb) p $c
+$5 = 33652
+(gdb) tstop
+(gdb) p $c
+$9 = 105559
+å½“ä½¿ç”¨tfindçš„æ—¶å€™ï¼Œä½ å¯ä»¥åˆ†æžtrace frame bufferã€‚å¦‚æžœtraceçŠ¶æ€å˜é‡è¢«æ”¶é›†äº†ï¼Œä½ å¯ä»¥æŠŠå®ƒå–å‡ºæ¥ã€‚
+
+(gdb) tstop 
+(gdb) tfind 
+(gdb) info tvariables
+$c              0           0
+(gdb) p $c
+$6 = 0
+(gdb) tfind 100
+(gdb) p $c
+$7 = 100
+å¦‚æžœéœ€è¦çš„æ—¶å€™ï¼Œè®¿é—®traceçŠ¶æ€å˜é‡çš„tracepoint actionå°†è‡ªåŠ¨åŠ é”ï¼Œæ‰€ä»¥å…¶å¯ä»¥å¾ˆå¥½çš„å¤„ç†traceçŠ¶æ€å˜é‡çš„ç«žæ€æ¡ä»¶é—®é¢˜ã€‚
+ä¸‹é¢è¿™ä¸ªä¾‹å­å³ä½¿åœ¨ä¸€ä¸ªå¤šCPUçš„çŽ¯å¢ƒä¹Ÿå¯ä»¥æ­£å¸¸ä½¿ç”¨ã€‚
+
+>teval $c=$c+1
+Per_cpu traceçŠ¶æ€å˜é‡
+Per_cpu traceçŠ¶æ€å˜é‡æ˜¯ä¸€ç§ç‰¹æ®Šçš„æ™®é€štraceçŠ¶æ€å˜é‡ã€‚ å½“ä¸€ä¸ªtracepoint actionè®¿é—®åˆ°å…¶çš„æ—¶å€™ï¼Œå…¶å°†è‡ªåŠ¨è®¿é—®è¿™ä¸ªCPUçš„Per_cpu traceçŠ¶æ€å˜é‡ã€‚
+å®ƒæœ‰ä¸¤ä¸ªä¼˜ç‚¹ï¼š
+1. è®¿é—®Per_cpu traceçŠ¶æ€å˜é‡çš„tracepoint actionsä¸å­˜åœ¨ç«žæ€æ¡ä»¶é—®é¢˜ï¼Œæ‰€ä»¥å…¶ä¸éœ€è¦å¯¹traceçŠ¶æ€å˜é‡åŠ é”ã€‚æ‰€ä»¥å…¶åœ¨å¤šæ ¸çš„æœºå™¨ä¸Šé€Ÿåº¦æ›´å¿«ã€‚ 
+2. å†™é’ˆå¯¹è®°å½•æŸä¸ªCPUçš„tracepoint actionsæ¯”æ™®é€štraceçŠ¶æ€å˜é‡æ›´å®¹æ˜“ã€‚
+
+å¦‚ä½•å®šä¹‰
+Per_cpu traceçŠ¶æ€å˜é‡æœ‰ä¸¤ç§ç±»åž‹ï¼š
+
+æœ¬åœ°CPUå˜é‡
+"per_cpu_"+string
+æˆ–è€…
+
+"p_"+string
+ä¾‹å¦‚ï¼š
+
+(gdb) tvariable $p_count
+åœ¨tracepoint actionä¸­è®¿é—®è¿™ä¸ªtraceçŠ¶æ€å˜é‡çš„æ—¶å€™ï¼Œå…¶å°†è¿”å›žè¿™ä¸ªå˜é‡åœ¨è¿™ä¸ªactionè¿è¡Œçš„CPUä¸Šçš„å€¼ã€‚
+
+CPU idå˜é‡
+"per_cpu_"+string+CPU_id
+æˆ–è€…
+
+"p_"+string+CPU_id
+ä¾‹å¦‚ï¼š
+
+(gdb) tvariable $p_count0
+(gdb) tvariable $p_count1
+(gdb) tvariable $p_count2
+(gdb) tvariable $p_count3
+åœ¨tracepoint actionæˆ–è€…GDBå‘½ä»¤è¡Œä¸­è®¿é—®è¿™ä¸ªå˜é‡çš„æ—¶å€™ï¼Œå…¶å°†è¿”å›žè¿™ä¸ªå˜é‡åœ¨CPU CPI_id ä¸Šçš„å€¼ã€‚ 
+ä¸‹é¢è¿™ä¸ªä¾‹å­å¯ä»¥è‡ªåŠ¨è¿™ä¸ªè¿™å°ä¸»æœºä¸Šçš„æ¯ä¸ªCPUå®šä¹‰CPU idå˜é‡ã€‚(è¯· æ³¨æ„ ç”¨è¿™äº›å‘½ä»¤ä¹‹å‰éœ€è¦è®©GDBè¿žä¸ŠKGTPã€‚)
+
+(gdb) set $tmp=0
+(gdb) while $tmp<$cpu_number
+ >eval "tvariable $p_count%d",$tmp
+ >set $tmp=$tmp+1
+ >end
+ä¾‹å­1
+è¿™ä¸ªä¾‹å­å®šä¹‰äº†ä¸€ä¸ªè®°å½•æ¯ä¸ªCPUè°ƒç”¨å¤šå°‘æ¬¡vfs_readçš„tracepointã€‚
+
+tvariable $p_count
+set $tmp=0
+while $tmp<$cpu_number
+  eval "tvariable $p_count%d",$tmp
+  set $tmp=$tmp+1
+  end
+trace vfs_read
+actions
+  teval $p_count=$p_count+1
+  end
+äºŽæ˜¯ä½ å¯ä»¥åœ¨"tstart"åŽæ˜¾ç¤ºæ¯ä¸ªCPUè°ƒç”¨äº†å¤šå°‘æ¬¡vfs_readï¼š
+
+(gdb) p $p_count0
+$3 = 44802
+(gdb) p $p_count1
+$4 = 55272
+(gdb) p $p_count2
+$5 = 102085
+(gdb) p $p_count3
+ä¾‹å­2
+è¿™ä¸ªä¾‹å­è®°å½•äº†æ¯ä¸ªCPUä¸Šå…³é—­IRQæ—¶é—´æœ€é•¿çš„å‡½æ•°çš„stack dumpã€‚
+
+set pagination off
+
+tvariable $bt=1024
+tvariable $p_count
+tvariable $p_cc
+set $tmp=0
+while $tmp<$cpu_number
+eval "tvariable $p_cc%d",$tmp
+set $tmp=$tmp+1
+end
+
+tvariable $ignore_error=1
+
+trace arch_local_irq_disable
+  commands
+    teval $p_count=$clock
+  end
+trace arch_local_irq_enable if ($p_count && $p_cc < $clock - $p_count)
+  commands
+    teval $p_cc = $clock - $p_count
+    collect $bt
+    collect $p_cc
+    teval $p_count=0
+  end
+
+enable
+set pagination on
+ç‰¹æ®ŠtraceçŠ¶æ€å˜é‡ $current_taskï¼Œ$current_task_pidï¼Œ$current_thread_infoï¼Œ$cpu_idï¼Œ$dump_stackï¼Œ$printk_levelï¼Œ$printk_formatï¼Œ$printk_tmpï¼Œ$clockï¼Œ$hardirq_countï¼Œ$softirq_count å’Œ $irq_count
+KGTPç‰¹æ®ŠtraceçŠ¶æ€å˜é‡$current_taskï¼Œ$current_thread_infoï¼Œ$cpu_id å’Œ $clockå¯ä»¥å¾ˆå®¹æ˜“çš„è®¿é—®å„ç§ç‰¹æ®Šçš„å€¼ï¼Œå½“ä½ ç”¨GDBè¿žåˆ°KGTPåŽå°±å¯ä»¥è®¿é—®åˆ°ä»–ä»¬ã€‚ ä½ å¯ä»¥åœ¨tracepointæ¡ä»¶å’Œactionsé‡Œä½¿ç”¨ä»–ä»¬ã€‚
+åœ¨tracepointæ¡ä»¶å’Œactionsé‡Œè®¿é—®$current_taskå¯ä»¥å–å¾—get_current()çš„è¿”å›žå€¼ã€‚
+åœ¨tracepointæ¡ä»¶å’Œactionsé‡Œè®¿é—®$current_task_pidå¯ä»¥å–å¾—get_current()->pidçš„å€¼ã€‚
+åœ¨tracepointæ¡ä»¶å’Œactionsé‡Œè®¿é—®$current_thread_infoå¯ä»¥å–å¾—current_thread_info()çš„è¿”å›žå€¼ã€‚
+åœ¨tracepointæ¡ä»¶å’Œactionsé‡Œè®¿é—®$cpu_idå¯ä»¥å–å¾—smp_processor_id()çš„è¿”å›žå€¼ã€‚
+åœ¨tracepointæ¡ä»¶å’Œactionsé‡Œè®¿é—®$clockå¯ä»¥å–å¾—local_clock()çš„è¿”å›žå€¼ï¼Œä¹Ÿå°±æ˜¯å–å¾—çº³ç§’ä¸ºå•ä½çš„æ—¶é—´æˆ³ã€‚
+$rdtscåªåœ¨ä½“ç³»ç»“æž„æ˜¯X86æˆ–è€…X86_64çš„æ—¶å€™è®¿é—®çš„åˆ°ï¼Œä»»ä½•æ—¶å€™è®¿é—®å®ƒå¯ä»¥å–å¾—ç”¨æŒ‡ä»¤RDTSCå–å¾—çš„TSCçš„å€¼ã€‚
+åœ¨tracepointæ¡ä»¶å’Œactionsé‡Œè®¿é—®$hardirq_countå¯ä»¥å–å¾—hardirq_count()çš„è¿”å›žå€¼ã€‚
+åœ¨tracepointæ¡ä»¶å’Œactionsé‡Œè®¿é—®$softirq_countå¯ä»¥å–å¾—softirq_count()çš„è¿”å›žå€¼ã€‚
+åœ¨tracepointæ¡ä»¶å’Œactionsé‡Œè®¿é—®$irq_countå¯ä»¥å–å¾—irq_count()çš„è¿”å›žå€¼ã€‚
+KGTPè¿˜æœ‰ä¸€äº›ç‰¹æ®ŠtraceçŠ¶æ€å˜é‡$dump_stackï¼Œ$printk_levelï¼Œ$printk_format å’Œ $printk_tmpã€‚ä»–ä»¬å¯ä»¥ç”¨æ¥ç›´æŽ¥æ˜¾ç¤ºå€¼ï¼Œè¯·çœ‹http://code.google.com/p/kgtp/wiki/HOWTOCN#å¦‚ä½•è®©tracepointç›´æŽ¥è¾“å‡ºä¿¡æ¯ã€‚
+ä¸‹é¢æ˜¯ä¸€ä¸ªç”¨$cè®°å½•è¿›ç¨‹16663è°ƒç”¨å¤šå°‘æ¬¡vfs_readå¹¶æ”¶é›†thread_infoç»“æž„çš„ä¾‹å­ï¼š
+
+(gdb) target remote /sys/kernel/debug/gtp
+(gdb) trace vfs_read if (((struct task_struct *)$current_task)->pid == 16663)
+(gdb) tvariable $c
+(gdb) actions
+Enter actions for tracepoint 4, one per line.
+End with a line saying just "end".
+>teval $c=$c+1
+>collect (*(struct thread_info *)$current_thread_info)
+>end
+(gdb) tstart 
+(gdb) info tvariables 
+Name            Initial     Current     
+$c              0           184         
+$current_task   0           <unknown>   
+$current_thread_info 0           <unknown>   
+$cpu_id         0           <unknown>   
+(gdb) tstop
+(gdb) tfind
+(gdb) p *(struct thread_info *)$current_thread_info
+$10 = {task = 0xf0ac6580, exec_domain = 0xc07b1400, flags = 0, status = 0, cpu = 1, preempt_count = 2, addr_limit = {
+    seg = 4294967295}, restart_block = {fn = 0xc0159fb0 <do_no_restart_syscall>, {{arg0 = 138300720, arg1 = 11, 
+        arg2 = 1, arg3 = 78}, futex = {uaddr = 0x83e4d30, val = 11, flags = 1, bitset = 78, time = 977063750, 
+        uaddr2 = 0x0}, nanosleep = {index = 138300720, rmtp = 0xb, expires = 335007449089}, poll = {
+        ufds = 0x83e4d30, nfds = 11, has_timeout = 1, tv_sec = 78, tv_nsec = 977063750}}}, 
+  sysenter_return = 0xb77ce424, previous_esp = 0, supervisor_stack = 0xef340044 "", uaccess_err = 0}
+è¿™æ˜¯ä¸€ä¸ªè®°å½•æ¯ä¸ªCPUè°ƒç”¨äº†å¤šå°‘æ¬¡sys_read()çš„ä¾‹å­ã€‚
+
+(gdb) tvariable $c0
+(gdb) tvariable $c1
+(gdb) trace sys_read 
+(gdb) condition $bpnum ($cpu_id == 0)
+(gdb) actions
+>teval $c0=$c0+1
+>end
+(gdb) trace sys_read 
+(gdb) condition $bpnum ($cpu_id == 1)
+(gdb) actions
+>teval $c1=$c1+1
+>end
+(gdb) info tvariables 
+Name            Initial     Current     
+$current_task   0           <unknown>   
+$cpu_id         0           <unknown>   
+$c0             0           3255        
+$c1             0           1904     
+sys_read() åœ¨CPU0ä¸Šè¢«æ‰§è¡Œäº†3255æ¬¡ï¼ŒCPU1ä¸Šæ‰§è¡Œäº†1904æ¬¡ã€‚è¯· æ³¨æ„ è¿™ä¸ªä¾‹å­åªæ˜¯ä¸ºäº†æ˜¾ç¤ºå¦‚ä½•ä½¿ç”¨$cpu_idï¼Œå®žé™…ä¸Šç”¨per_cpu traceçŠ¶æ€å˜é‡å†™æ›´å¥½ã€‚
+
+ç‰¹æ®ŠtraceçŠ¶æ€å˜é‡ $self_trace
+$self_traceå’Œå‰é¢ä»‹ç»çš„ç‰¹æ®ŠtraceçŠ¶æ€å˜é‡ä¸åŒï¼Œå®ƒæ˜¯ç”¨æ¥æŽ§åˆ¶tracepointçš„è¡Œä¸ºçš„ã€‚
+é»˜è®¤æƒ…å†µä¸‹ï¼Œtracepointè¢«è§¦å‘åŽï¼Œå¦‚æžœcurrent_taskæ˜¯KGTPè‡ªå·±çš„è¿›ç¨‹ï¼ˆGDBï¼Œnetcatï¼Œgetframeæˆ–è€…å…¶ä»–è®¿é—®KGTPæŽ¥å£çš„è¿›ç¨‹ï¼‰çš„æ—¶å€™ï¼Œå…¶å°†ä¸æ‰§è¡Œä»»ä½•actionsã€‚
+å¦‚æžœä½ æƒ³è®©tracepoint actionså’Œä»»ä½•taskçš„æ—¶å€™éƒ½æ‰§è¡Œï¼Œè¯·åŒ…å«ä¸€ä¸ªåŒ…å«ä¸€ä¸ªè®¿é—®åˆ°$self_traceçš„å‘½ä»¤åˆ°actionsä¸­ï¼Œä¹Ÿå°±æ˜¯è¯´å¢žåŠ ä¸‹é¢çš„å‘½ä»¤åˆ°actionsä¸­ï¼š
+
+>teval $self_trace=0
+ç”¨$kret traceå‡½æ•°çš„ç»“å°¾
+æœ‰æ—¶ï¼Œå› ä¸ºå†…æ ¸æ˜¯ç”¨ä¼˜åŒ–ç¼–è¯‘çš„ï¼Œæ‰€ä»¥åœ¨å‡½æ•°ç»“å°¾è®¾ç½®tracepointæœ‰æ—¶å¾ˆå›°éš¾ã€‚è¿™æ—¶ä½ å¯ä»¥ç”¨$kretå¸®åŠ©ä½ ã€‚
+$kretæ˜¯ä¸€ä¸ªç±»ä¼¼$self_traceçš„ç‰¹æ®ŠtraceçŠ¶æ€å˜é‡ã€‚å½“ä½ åœ¨tracepoint actioné‡Œè®¾ç½®å®ƒçš„å€¼çš„æ—¶å€™ï¼Œè¿™ä¸ªtracepointå°†ç”¨kretprobeè€Œä¸æ˜¯kprobeæ³¨å†Œã€‚äºŽæ˜¯å…¶å°±å¯ä»¥traceä¸€ä¸ªå‡½æ•°çš„ç»“å°¾ã€‚
+è¯· æ³¨æ„ è¿™ä¸ªtracepoint å¿…é¡»ç”¨ "function_name" çš„æ ¼å¼è®¾ç½®åœ¨å‡½æ•°çš„ç¬¬ä¸€ä¸ªåœ°å€ä¸Šã€‚
+
+ä¸‹é¢çš„éƒ¨åˆ†æ˜¯ä¸€ä¸ªä¾‹å­ï¼š
+
+#"*(function_name)" format can make certain that GDB send the first address of function to KGTP.
+(gdb) trace *vfs_read
+(gdb) actions
+>teval $kret=0
+#Following part you can set commands that you want.
+ç”¨ $ignore_error å’Œ $last_errno å¿½ç•¥tstartçš„é”™è¯¯
+å½“KGTPåœ¨tstartå–å¾—é”™è¯¯ï¼Œè¿™ä¸ªå‘½ä»¤å°†å¤±è´¥ã€‚
+ä½†æœ‰æ—¶æˆ‘ä»¬éœ€è¦å¿½ç•¥è¿™ä¸ªé”™è¯¯ä¿¡æ¯å¹¶è®©KGTPå·¥ä½œã€‚ä¾‹å¦‚ï¼šå¦‚æžœä½ åœ¨inlineå‡½æ•°spin_lockè®¾ç½®tracepointï¼Œè¿™ä¸ªtracepointå°†è¢«è®¾ç½®åˆ°å¾ˆå¤šåœ°å€ä¸Šï¼Œæœ‰ä¸€äº›åœ°å€ä¸èƒ½è®¾ç½®kprobeï¼ŒäºŽæ˜¯å®ƒå°±ä¼šè®©tstartå‡ºé”™ã€‚è¿™æ—¶ä½ å°±å¯ä»¥ç”¨"$ignore_error"å¿½ç•¥è¿™äº›é”™è¯¯ã€‚
+æœ€åŽä¸€ä¸ªé”™è¯¯ä¿¡æ¯å°†å­˜åœ¨"$last_errno"ä¸­ã€‚
+
+(gdb) tvariable $ignore_error=1
+è¿™ä¸ªå‘½ä»¤å°†æ‰“å¼€å¿½ç•¥ã€‚
+
+(gdb) tvariable $ignore_error=0
+è¿™ä¸ªå‘½ä»¤å°†å…³é—­å¿½ç•¥ã€‚
+
+ä½¿ç”¨ $cooked_clock å’Œ $cooked_rdtsc å–å¾—ä¸åŒ…å«KGTPè¿è¡Œæ—¶é—´çš„æ—¶é—´ä¿¡æ¯
+è®¿é—®è¿™ä¸¤ä¸ªtraceçŠ¶æ€å˜é‡å¯ä»¥å–å¾—ä¸åŒ…å«KGTPè¿è¡Œæ—¶é—´çš„æ—¶é—´ä¿¡æ¯ï¼ŒäºŽæ˜¯æˆ‘ä»¬å¯ä»¥å–å¾—ä¸€æ®µä»£ç æ›´çœŸå®žçš„æ‰§è¡Œæ—¶é—´å³ä½¿è¿™ä¸ªtracepointçš„actionæ¯”è¾ƒå¤æ‚ã€‚
+
+ä½¿ç”¨ $xtime_sec å’Œ $xtime_nsec å–å¾— timespec
+è®¿é—®traceçŠ¶æ€å˜é‡å°†è¿”å›žç”¨getnstimeofdayå–å¾—çš„timespecæ—¶é—´ä¿¡æ¯ã€‚
+$xtime_sec å°†è¿”å›žtimespecç§’çš„éƒ¨åˆ†ã€‚
+$xtime_nsec å°†è¿”å›žtimespecçº³ç§’çš„éƒ¨åˆ†ã€‚
+
+å¦‚ä½• backtrace (stack dump)
+æ¯æ¬¡ä½ çš„ç¨‹åºåšä¸€ä¸ªå‡½æ•°è°ƒç”¨çš„æ—¶å€™ï¼Œ è¿™æ¬¡è°ƒç”¨çš„ä¿¡æ¯å°±ä¼šç”Ÿæˆã€‚è¿™äº›ä¿¡æ¯åŒ…æ‹¬è°ƒç”¨å‡½æ•°çš„åœ°å€ï¼Œè°ƒç”¨å‚æ•°ï¼Œå±€éƒ¨å˜é‡çš„å€¼ã€‚è¿™äº›ä¿¡æ¯è¢«å­˜å‚¨åœ¨æˆ‘ä»¬ç§°ä¸ºæ ˆå¸§çš„åœ°æ–¹ï¼Œæ ˆå¸§æ˜¯ä»Žè°ƒç”¨æ ˆä¸­åˆ†é…è€Œæ¥ã€‚
+
+é€šè¿‡$btæ”¶é›†æ ˆå¹¶ç”¨GDBå‘½ä»¤backtraceè¿›è¡Œåˆ†æž
+å› ä¸ºè¿™ä¸ªæ–¹æ³•æ›´å¿«ï¼ˆå› ä¸ºåœ¨traceçš„æ—¶å€™åªæ”¶é›†ï¼‰è€Œä¸”å¯ä»¥åˆ†æžå‡ºå¤§éƒ¨åˆ†çš„è°ƒç”¨æ ˆä¸­çš„ä¿¡æ¯ï¼ˆå‰é¢ä»‹ç»çš„æ ˆä¿¡æ¯éƒ½å¯ä»¥åˆ†æžå‡ºæ¥ï¼‰ï¼Œæ‰€ä»¥æ—¶é—´ä½ ä½¿ç”¨è¿™ä¸ªæ–¹æ³•åšæ ˆåˆ†æžã€‚
+é¦–å…ˆæˆ‘ä»¬éœ€è¦åœ¨tracepoint actionä¸­å¢žåŠ å‘½ä»¤æ”¶é›†æ ˆã€‚
+GDBæ”¶é›†æ ˆçš„é€šå¸¸å‘½ä»¤æ˜¯ï¼š åœ¨x86_32, ä¸‹é¢çš„å‘½ä»¤å°†æ”¶é›†512å­—èŠ‚çš„æ ˆå†…å®¹ã€‚
+>collect *(unsigned char *)$esp@512
+åœ¨x86_64, ä¸‹é¢çš„å‘½ä»¤å°†æ”¶é›†512å­—èŠ‚çš„æ ˆå†…å®¹ã€‚
+>collect *(unsigned char *)$rsp@512
+åœ¨MIPSæˆ–è€…ARM, ä¸‹é¢çš„å‘½ä»¤å°†æ”¶é›†512å­—èŠ‚çš„æ ˆå†…å®¹ã€‚
+>collect *(unsigned char *)$sp@512
+è¿™äº›å‘½ä»¤å¾ˆéš¾è®°ï¼Œè€Œä¸”ä¸åŒçš„ä½“ç³»ç»“æž„éœ€è¦ä¸åŒçš„å‘½ä»¤ã€‚
+KGTPæœ‰ä¸€ä¸ªç‰¹æ®ŠtraceçŠ¶æ€å˜é‡$btã€‚å¦‚æžœtracepoint actionè®¿é—®åˆ°å®ƒï¼ŒKGTPå°†è‡ªåŠ¨æ”¶é›†$bté•¿åº¦ï¼ˆé»˜è®¤å€¼æ˜¯512ï¼‰çš„æ ˆã€‚ä¸‹é¢è¿™ä¸ªactionå°†æ”¶é›†512å­—èŠ‚çš„æ ˆå†…å­˜ï¼š
+
+>collect $bt
+å¦‚æžœä½ æƒ³æ”¹å˜$btçš„å€¼ï¼Œä½ å¯ä»¥åœ¨"tstart"ä½¿ç”¨ä¸‹é¢è¿™ä¸ªGDBå‘½ä»¤ï¼š
+
+(gdb) tvariable $bt=1024
+ä¸‹é¢çš„éƒ¨åˆ†æ˜¯ä¸€ä¸ªæ”¶é›†æ ˆå¹¶ç”¨GDBè¿›è¡Œåˆ†æžçš„ä¾‹å­ï¼š
+
+(gdb) target remote /sys/kernel/debug/gtp
+(gdb) trace vfs_readdir
+Tracepoint 1 at 0xffffffff8118c300: file /home/teawater/kernel2/linux/fs/readdir.c, line 24.
+(gdb) actions 
+Enter actions for tracepoint 1, one per line.
+End with a line saying just "end".
+>collect $bt
+>end
+(gdb) tstart 
+(gdb) shell ls
+1      crypto    fs             include  kernel    mm               Module.symvers  security  System.map  vmlinux
+arch   drivers   hotcode.html   init     lib       modules.builtin  net             sound     usr         vmlinux.o
+block  firmware  hotcode.html~  ipc      Makefile  modules.order    scripts         source    virt
+(gdb) tstop 
+(gdb) tfind 
+Found trace frame 0, tracepoint 1
+#0  vfs_readdir (file=0xffff8800c5556d00, filler=0xffffffff8118c4b0 <filldir>, buf=0xffff880108709f40)
+    at /home/teawater/kernel2/linux/fs/readdir.c:24
+24      {
+(gdb) bt
+#0  vfs_readdir (file=0xffff8800c5556d00, filler=0xffffffff8118c4b0 <filldir>, buf=0xffff880108709f40)
+    at /home/teawater/kernel2/linux/fs/readdir.c:24
+#1  0xffffffff8118c689 in sys_getdents (fd=<optimized out>, dirent=0x1398c58, count=32768) at /home/teawater/kernel2/linux/fs/readdir.c:214
+#2  <signal handler called>
+#3  0x00007f00253848a5 in ?? ()
+#4  0x00003efd32cddfc9 in ?? ()
+#5  0x00002c15b7d04101 in ?? ()
+#6  0x000019c0c5704bf1 in ?? ()
+#7  0x0000000900000000 in ?? ()
+#8  0x000009988cc8d269 in ?? ()
+#9  0x000009988cc9b8d1 in ?? ()
+#10 0x0000000000000000 in ?? ()
+(gdb) up
+#1  0xffffffff8118c689 in sys_getdents (fd=<optimized out>, dirent=0x1398c58, count=32768) at /home/teawater/kernel2/linux/fs/readdir.c:214
+214             error = vfs_readdir(file, filldir, &buf);
+(gdb) p buf
+$1 = {current_dir = 0x1398c58, previous = 0x0, count = 32768, error = 0}
+(gdb) p error
+$3 = -9
+(gdb) frame 0
+#0  vfs_readdir (file=0xffff8800c5556d00, filler=0xffffffff8118c4b0 <filldir>, buf=0xffff880108709f40)
+    at /home/teawater/kernel2/linux/fs/readdir.c:24
+24      {
+ä»Žè¿™ä¸ªä¾‹å­ï¼Œæˆ‘ä»¬å¯ä»¥çœ‹åˆ°ä¸€äº›åˆ†æžè°ƒç”¨æ ˆçš„GDBå‘½ä»¤ï¼š
+bt æ˜¯GDBå‘½ä»¤ backtrace çš„åˆ«åï¼Œè¿™ä¸ªå‘½ä»¤å°†æ‰“å°stackä¸­çš„ä¿¡æ¯ï¼šæ¯ä¸€è¡Œæ˜¯ä¸€ä¸ªè°ƒç”¨æ ˆã€‚
+up n æ˜¯å‘ä¸Šç§»åŠ¨nä¸ªå¸§ã€‚å¦‚æžœnæ˜¯æ­£æ•°ï¼Œåˆ™å‘å¤–åˆ°æ›´é«˜çš„å¸§ï¼Œä¸€ç›´åˆ°è¿™ä¸ªæ ˆæœ€å¤§çš„ä¸€è¡Œã€‚nçš„é»˜è®¤å€¼æ˜¯1ã€‚
+down n æ˜¯å‘ä¸‹ç§»åŠ¨nä¸ªå¸§ã€‚å¦‚æžœnæ˜¯æ­£æ•°ï¼Œåˆ™å‘å†…åˆ°æ›´ä½Žçš„å¸§ï¼Œä¸€ç›´åˆ°æœ€æ–°åˆ›å»ºçš„é‚£ä¸ªæ ˆå¸§ã€‚nçš„é»˜è®¤å€¼æ˜¯1ã€‚
+is move n frames down the stack. For positive numbers n, this advances toward the innermost frame, to lower frame numbers, to frames that were created more recently. n defaults to one. ä½ å¯ä»¥æŠŠ down ç¼©å†™ä¸º doã€‚
+frame n æ˜¯é€‰æ‹©å¸§nã€‚å¸§0æ˜¯æœ€è¿‘åˆ›å»ºçš„å¸§ï¼Œå¸§1è°ƒç”¨è¿™ä¸ªå¸§çš„å¸§ã€‚æ‰€ä»¥æœ€é«˜çš„å¸§æ˜¯mainã€‚
+ä½ è¿˜å¯ä»¥çœ‹åˆ°å½“ä½ ç”¨upï¼Œdownæˆ–è€…frameæ¥é€‰æ‹©è°ƒç”¨æ ˆå¸§çš„æ—¶å€™ï¼Œä½ å¯ä»¥è¾“å‡ºä¸åŒå¸§çš„å‚æ•°å’Œå±€éƒ¨å˜é‡ã€‚
+è¦å–å¾—æ›´å¤šå…³äºŽå¦‚ä½•ä½¿ç”¨GDBåˆ†æžè°ƒç”¨æ ˆçš„ä¿¡æ¯ï¼Œè¯·åˆ°http://sourceware.org/gdb/current/onlinedocs/gdb/Stack.htmlã€‚
+ç”¨$_retæ¥å–å¾—å½“å‰å‡½æ•°çš„è°ƒç”¨å‡½æ•°çš„æ ˆ
+å¦‚æžœä½ åªæƒ³å–å¾—å½“å‰å‡½æ•°çš„è°ƒç”¨å‡½æ•°çš„æ ˆï¼Œå¯ä»¥ç”¨$_retã€‚
+è¯· æ³¨æ„ ä½¿ç”¨$_retçš„tracepointä¸èƒ½è®¾ç½®åœ¨å‡½æ•°çš„ç¬¬ä¸€ä¸ªåœ°å€ä¸Šã€‚
+ä¾‹å¦‚ï¼š
+
+(gdb) list vfs_read
+360     }
+361     
+362     EXPORT_SYMBOL(do_sync_read);
+363     
+364     ssize_t vfs_read(struct file *file, char __user *buf, size_t count, loff_t *pos)
+365     {
+366             ssize_t ret;
+367     
+368             if (!(file->f_mode & FMODE_READ))
+369                     return -EBADF;
+(gdb) trace 368
+Tracepoint 2 at 0xffffffff8117a244: file /home/teawater/kernel2/linux/fs/read_write.c, line 368.
+(gdb) actions 
+Enter actions for tracepoint 2, one per line.
+End with a line saying just "end".
+>collect $_ret
+>end
+(gdb) tstart 
+(gdb) tstop 
+(gdb) tfind 
+Found trace frame 0, tracepoint 2
+#0  vfs_read (file=0xffff880141c46000, buf=0x359bda0 <Address 0x359bda0 out of bounds>, count=8192, pos=0xffff88012fa49f48)
+    at /home/teawater/kernel2/linux/fs/read_write.c:368
+368             if (!(file->f_mode & FMODE_READ))
+(gdb) bt
+#0  vfs_read (file=0xffff880141c46000, buf=0x359bda0 <Address 0x359bda0 out of bounds>, count=8192, pos=0xffff88012fa49f48)
+    at /home/teawater/kernel2/linux/fs/read_write.c:368
+#1  0xffffffff8117a3ea in sys_read (fd=<optimized out>, buf=<unavailable>, count=<unavailable>)
+    at /home/teawater/kernel2/linux/fs/read_write.c:469
+Backtrace stopped: not enough registers or memory available to unwind further
+(gdb) up
+#1  0xffffffff8117a3ea in sys_read (fd=<optimized out>, buf=<unavailable>, count=<unavailable>)
+    at /home/teawater/kernel2/linux/fs/read_write.c:469
+469                     ret = vfs_read(file, buf, count, &pos);
+(gdb) p ret
+$2 = -9
+æˆ‘ä»¬å¯ä»¥çœ‹åˆ°è°ƒç”¨vfs_readçš„å‡½æ•°æ˜¯sys_readï¼Œå‡½æ•°sys_readçš„å±€éƒ¨å˜é‡retçš„å€¼æ˜¯-9ã€‚
+
+ç”¨ $dump_stack è¾“å‡ºæ ˆåˆ†æžåˆ°printké‡Œ
+å› ä¸ºè¿™ä¸ªæ–¹æ³•éœ€è¦åœ¨traceçš„æ—¶å€™åˆ†æžæ ˆå¹¶è°ƒç”¨printkï¼Œæ‰€ä»¥å®ƒæ¯”è¾ƒæ…¢ï¼Œä¸å®‰å…¨ï¼Œä¸æ¸…æ™°ä¹Ÿä¸èƒ½è®¿é—®è°ƒç”¨æ ˆä¸­çš„å¾ˆå¤šå†…å®¹ï¼Œæ‰€ä»¥æˆ‘å»ºè®®ä½ ä¸Šä¸€éƒ¨åˆ†ä»‹ç»çš„æ–¹æ³•
+KGTPæœ‰ä¸€ä¸ªç‰¹æ®Šçš„traceçŠ¶æ€å˜é‡$dump_stackï¼Œæ”¶é›†è¿™ä¸ªå˜é‡å¯ä»¥ä»¤GDBè°ƒç”¨æ ˆåˆ†æžå¹¶ç”¨printkè¾“å‡ºã€‚ ä¸‹é¢æ˜¯ä¸€ä¸ªè®©å†…æ ¸è¾“å‡ºvfs_readdiræ ˆåˆ†æžçš„ä¾‹å­ï¼š
+
+target remote /sys/kernel/debug/gtp
+trace vfs_readdir
+  commands
+    collect $dump_stack
+  end
+äºŽæ˜¯ä½ çš„å†…æ ¸å°±ä¼šprintkè¿™æ ·çš„ä¿¡æ¯ï¼š
+
+[22779.208064] gtp 1:Pid: 441, comm: python Not tainted 2.6.39-rc3+ #46
+[22779.208068] Call Trace:
+[22779.208072]  [<fe653cca>] gtp_get_var+0x4a/0xa0 [gtp]
+[22779.208076]  [<fe653d79>] gtp_collect_var+0x59/0xa0 [gtp]
+[22779.208080]  [<fe655974>] gtp_action_x+0x1bb4/0x1dc0 [gtp]
+[22779.208084]  [<c05b6408>] ? _raw_spin_unlock+0x18/0x40
+[22779.208088]  [<c023f152>] ? __find_get_block_slow+0xd2/0x160
+[22779.208091]  [<c01a8c56>] ? delayacct_end+0x96/0xb0
+[22779.208100]  [<c023f404>] ? __find_get_block+0x84/0x1d0
+[22779.208103]  [<c05b6408>] ? _raw_spin_unlock+0x18/0x40
+[22779.208106]  [<c02e0838>] ? find_revoke_record+0xa8/0xc0
+[22779.208109]  [<c02e0c45>] ? jbd2_journal_cancel_revoke+0xd5/0xe0
+[22779.208112]  [<c02db51f>] ? __jbd2_journal_temp_unlink_buffer+0x2f/0x110
+[22779.208115]  [<fe655c4c>] gtp_kp_pre_handler+0xcc/0x1c0 [gtp]
+[22779.208118]  [<c05b8a88>] kprobe_exceptions_notify+0x3d8/0x440
+[22779.208121]  [<c05b7d54>] ? hw_breakpoint_exceptions_notify+0x14/0x180
+[22779.208124]  [<c05b95eb>] ? sub_preempt_count+0x7b/0xb0
+[22779.208126]  [<c0227ac5>] ? vfs_readdir+0x15/0xb0
+[22779.208128]  [<c0227ac4>] ? vfs_readdir+0x14/0xb0
+[22779.208131]  [<c05b9743>] notifier_call_chain+0x43/0x60
+[22779.208134]  [<c05b9798>] __atomic_notifier_call_chain+0x38/0x50
+[22779.208137]  [<c05b97cf>] atomic_notifier_call_chain+0x1f/0x30
+[22779.208140]  [<c05b980d>] notify_die+0x2d/0x30
+[22779.208142]  [<c05b71c5>] do_int3+0x35/0xa0
+å¦‚ä½•è®©tracepointç›´æŽ¥è¾“å‡ºä¿¡æ¯
+åœ¨å‰é¢çš„ç« èŠ‚ï¼Œä½ å¯ä»¥çœ‹åˆ°å¦‚æžœæƒ³å–å¾—Linuxå†…æ ¸çš„ä¿¡æ¯ï¼Œä½ éœ€è¦ç”¨tracepoint "collect" actionæ¥ä¿å­˜ä¿¡æ¯åˆ°tracepointå¸§ä¸­å¹¶ç”¨GDB tfindå‘½æ¥æ¥åˆ†æžè¿™äº›æ•°æ®å¸§ã€‚
+ä½†æ˜¯æœ‰æ—¶æˆ‘ä»¬å¸Œæœ›ç›´æŽ¥å–å¾—è¿™äº›æ•°æ®ï¼Œæ‰€ä»¥KGTPæä¾›äº†ä¸€ç§ç›´æŽ¥å–å¾—è¿™äº›æ•°æ®çš„æ–¹æ³•ã€‚
+
+åˆ‡æ¢collectä¸ºç›´æŽ¥è¾“å‡ºæ•°æ®
+KGTPæœ‰ç‰¹æ®ŠtraceçŠ¶æ€å˜é‡$printk_levelï¼Œ$printk_format å’Œ $printk_tmpæ”¯æŒè¿™ä¸ªåŠŸèƒ½ã€‚
+$printk_levelï¼Œå¦‚æžœè¿™ä¸ªå€¼æ˜¯8ï¼ˆè¿™æ˜¯é»˜è®¤å€¼ï¼‰ï¼Œ"collect" actionå°†æ˜¯æ™®é€šè¡Œä¸ºä¹Ÿå°±æ˜¯ä¿å­˜æ•°æ®åˆ°tracepointå¸§ä¸­ã€‚
+å¦‚æžœå€¼æ˜¯0-7ï¼Œ"collect" å°†ä»¥è¿™ä¸ªæ•°å­—ä¸ºprintkçº§åˆ«è¾“å‡ºä¿¡æ¯ï¼Œè¿™äº›çº§åˆ«æ˜¯ï¼š
+
+0       KERN_EMERG      system is unusable
+1       KERN_ALERT      action must be taken immediately
+2       KERN_CRIT       critical conditions
+3       KERN_ERR        error conditions
+4       KERN_WARNING    warning conditions
+5       KERN_NOTICE     normal but significant condition
+6       KERN_INFO       informational
+7       KERN_DEBUG      debug-level messages
+$printk_formatï¼Œcollect printkå°†æŒ‰ç…§è¿™é‡Œè®¾ç½®çš„æ ¼å¼è¿›è¡Œè¾“å‡ºã€‚ è¿™äº›æ ¼å¼æ˜¯ï¼š
+
+0       è¿™æ˜¯é»˜è®¤å€¼ã€‚
+        å¦‚æžœcollectçš„é•¿åº¦æ˜¯1ï¼Œ2ï¼Œ4ï¼Œ8åˆ™å…¶å°†è¾“å‡ºä¸€ä¸ªæ— ç¬¦å·åè¿›åˆ¶æ•°ã€‚
+        å¦‚æžœä¸æ˜¯ï¼Œåˆ™å…¶å°†è¾“å‡ºåå…­è¿›åˆ¶å­—ä¸²ã€‚
+1       è¾“å‡ºå€¼æ˜¯æœ‰ç¬¦å·åè¿›åˆ¶æ•°ã€‚
+2       è¾“å‡ºå€¼æ˜¯æ— ç¬¦å·åè¿›åˆ¶æ•°ã€‚
+3       è¾“å‡ºå€¼æ˜¯æ— ç¬¦å·åå…­è¿›åˆ¶æ•°ã€‚
+4       è¾“å‡ºå€¼æ˜¯å­—ç¬¦ä¸²ã€‚
+5       è¾“å‡ºå€¼æ˜¯åå…­è¿›åˆ¶å­—ä¸²ã€‚
+å¦‚æžœè¦è¾“å‡ºä¸€ä¸ªå…¨å±€å˜é‡ï¼Œéœ€è¦å°†å…¶å…ˆè®¾ç½®åˆ°$printk_tmpä¸­ã€‚
+
+ä¸‹é¢æ˜¯ä¸€ä¸ªæ˜¾ç¤ºè°ƒç”¨vfs_readdiræ—¶çš„è®¡æ•°ï¼Œpidï¼Œjiffies_64å’Œæ–‡ä»¶åçš„ä¾‹å­ï¼š
+
+(gdb) target remote /sys/kernel/debug/gtp
+(gdb) tvariable $c
+(gdb) trace vfs_readdir
+(gdb) actions
+>teval $printk_level=0
+>collect $c=$c+1
+>collect ((struct task_struct *)$current_task)->pid
+>collect $printk_tmp=jiffies_64
+>teval $printk_format=4
+>collect file->f_path.dentry->d_iname
+>end
+äºŽæ˜¯å†…æ ¸å°†printkè¿™äº›ä¿¡æ¯ï¼š
+
+gtp 1:$c=$c+1=41
+gtp 1:((struct task_struct *)$current_task)->pid=12085
+gtp 1:$printk_tmp=jiffies_64=4322021438
+gtp 1:file->f_path.dentry->d_iname=b26
+gtp 1:$c=$c+1=42
+gtp 1:((struct task_struct *)$current_task)->pid=12085
+gtp 1:$printk_tmp=jiffies_64=4322021438
+gtp 1:file->f_path.dentry->d_iname=b26
+"gtp 1" çš„æ„æ€æ˜¯æ•°æ®æ˜¯tracepoint 1è¾“å‡ºçš„ã€‚
+
+å¦‚ä½•ç”¨watch tracepointæŽ§åˆ¶ç¡¬ä»¶æ–­ç‚¹è®°å½•å†…å­˜è®¿é—®
+Watch tracepoint å¯ä»¥é€šè¿‡è®¾ç½®ä¸€äº›ç‰¹æ®Šçš„traceçŠ¶æ€å˜é‡è®¾ç½®ç¡¬ä»¶æ–­ç‚¹æ¥è®°å½•å†…å­˜è®¿é—®ã€‚
+è¯· æ³¨æ„ watch tracepointçŽ°åœ¨åªæœ‰X86å’ŒX86_64æ”¯æŒã€‚è€Œä¸”å› ä¸ºLinux 2.6.26å’Œæ›´è€ç‰ˆæœ¬æœ‰ä¸€äº›IPIçš„é—®é¢˜ï¼Œåªæœ‰Linux 2.6.27å’Œæ›´æ–°ç‰ˆæœ¬ä¸Šå¯ä»¥æ­£å¸¸ä½¿ç”¨åŠ¨æ€watch tracepointã€‚
+
+watch tracepointçš„traceçŠ¶æ€å˜é‡
+åç§°	æ™®é€štracepointå†™	æ™®é€štracepointè¯»	é™æ€static tracepointå†™	é™æ€static tracepointè¯»	åŠ¨æ€static tracepointå†™	åŠ¨æ€static tracepointå†™
+$watch_static	 ä¸æ”¯æŒ	 ä¸æ”¯æŒ	 å¦‚æžœ"teval $watch_static=1"åˆ™è¿™ä¸ªtracepointæ˜¯é™æ€watch tracepointã€‚	 ä¸æ”¯æŒ	 å¦‚æžœ"teval $watch_static=0"åˆ™è¿™ä¸ªtracepointæ˜¯åŠ¨æ€watch tracepointã€‚	 ä¸æ”¯æŒ
+$watch_set_id	 å½“è¿™ä¸ªtracepointè¦è®¾ç½®ä¸€ä¸ªåŠ¨æ€watch tracepointçš„æ—¶å€™ï¼Œè®¾ç½®åŠ¨æ€watch tracepointçš„IDåˆ°$watch_set_idæ¥æ ‡æ˜Žä½ è¦è®¾ç½®å“ªä¸ªåŠ¨æ€watch tracepointã€‚	 ä¸æ”¯æŒ	 ä¸æ”¯æŒ	 ä¸æ”¯æŒ	 ä¸æ”¯æŒ	 ä¸æ”¯æŒ
+$watch_set_addr	 å½“è¿™ä¸ªtracepointè¦è®¾ç½®ä¸€ä¸ªåŠ¨æ€watch tracepointçš„æ—¶å€™ï¼Œè®¾ç½®åŠ¨æ€watch tracepointçš„åœ°å€åˆ°$watch_set_addræ¥æ ‡æ˜Žä½ è¦è®¾ç½®å“ªä¸ªåŠ¨æ€watch tracepointã€‚	 ä¸æ”¯æŒ	 ä¸æ”¯æŒ	 ä¸æ”¯æŒ	 ä¸æ”¯æŒ	 ä¸æ”¯æŒ
+$watch_type	 å½“è¿™ä¸ªtracepointè¦è®¾ç½®ä¸€ä¸ªåŠ¨æ€watch tracepointçš„æ—¶å€™ï¼Œè®¾ç½®watchç±»åž‹åˆ°$watch_typeã€‚
+0æ˜¯æ‰§è¡Œã€‚ 1æ˜¯å†™ã€‚ 2æ˜¯è¯»æˆ–è€…å†™ã€‚	 å–å¾—è¿™ä¸ªtracepointè®¾ç½®åˆ°$watch_typeé‡Œçš„å€¼ã€‚	 è®¾ç½®watch tracepointçš„ç±»åž‹ã€‚	 å–å¾—è¿™ä¸ªwatch tracepointçš„ç±»åž‹ã€‚	 è®¾ç½®watch tracepointçš„é»˜è®¤ç±»åž‹ã€‚	 å–å¾—è¿™ä¸ªwatch tracepointåœ¨å®žé™…æ‰§è¡Œä¸­çš„ç±»åž‹ã€‚
+$watch_size	 å½“è¿™ä¸ªtracepointè¦è®¾ç½®ä¸€ä¸ªåŠ¨æ€watch tracepointçš„æ—¶å€™ï¼Œè®¾ç½®watché•¿åº¦åˆ°$watch_sizeã€‚
+é•¿åº¦æ˜¯1, 2, 4, 8ã€‚	 å–å¾—è¿™ä¸ªtracepointè®¾ç½®åˆ°$watch_sizeé‡Œçš„å€¼ã€‚	 è®¾ç½®watch tracepointçš„é•¿åº¦ã€‚	 å–å¾—è¿™ä¸ªwatch tracepointçš„é•¿åº¦ã€‚	 è®¾ç½®watch tracepointçš„é»˜è®¤é•¿åº¦ã€‚	 å–å¾—è¿™ä¸ªwatch tracepointåœ¨å®žé™…æ‰§è¡Œä¸­çš„é•¿åº¦ã€‚
+$watch_start	 è®¾ç½®åœ°å€åˆ°åŠ¨æ€watch tracepoint($watch_set_addræˆ–è€…$watch_set_idè®¾ç½®)ä¸­å¹¶è®©å…¶å¼€å§‹å·¥ä½œã€‚	 å–å¾—è¿™æ¬¡å¼€å§‹çš„è¿”å›žå€¼ã€‚ ï¼ˆå…¶å¯èƒ½ä¼šå¤±è´¥å› ä¸ºX86åªæœ‰4ä¸ªç¡¬ä»¶æ–­ç‚¹ï¼‰
+å–å¾—0åˆ™æˆåŠŸï¼Œå°äºŽ0åˆ™æ˜¯é”™è¯¯IDã€‚	 ä¸æ”¯æŒ	 ä¸æ”¯æŒ	 ä¸æ”¯æŒ	 ä¸æ”¯æŒ
+$watch_stop	 è®¾ç½®åœ°å€åˆ°$watch_stopå°†è®©ä¸€ä¸ªwatchè¿™ä¸ªåœ°å€çš„åŠ¨æ€watch tracepointåœæ­¢ã€‚	 å–å¾—è¿™æ¬¡åœæ­¢çš„è¿”å›žå€¼ã€‚	 ä¸æ”¯æŒ	 ä¸æ”¯æŒ	 ä¸æ”¯æŒ	 ä¸æ”¯æŒ
+$watch_trace_num	 ä¸æ”¯æŒ	 ä¸æ”¯æŒ	 ä¸æ”¯æŒ	 ä¸æ”¯æŒ	 ä¸æ”¯æŒ	 è®¾ç½®è¿™ä¸ªåŠ¨æ€watch tracepointçš„tracepointçš„å·ç ã€‚
+$watch_trace_addr	 ä¸æ”¯æŒ	 ä¸æ”¯æŒ	 ä¸æ”¯æŒ	 ä¸æ”¯æŒ	 ä¸æ”¯æŒ	 è®¾ç½®è¿™ä¸ªåŠ¨æ€watch tracepointçš„tracepointçš„åœ°å€ã€‚
+$watch_addr	 ä¸æ”¯æŒ	 ä¸æ”¯æŒ	 ä¸æ”¯æŒ	 è¿™ä¸ªwatch tracepointç›‘è§†çš„åœ°å€ã€‚	 ä¸æ”¯æŒ	 è¿™ä¸ªwatch tracepointç›‘è§†çš„åœ°å€ã€‚
+$watch_val	 ä¸æ”¯æŒ	 ä¸æ”¯æŒ	 ä¸æ”¯æŒ	 è¿™ä¸ªwatch tracepointç›‘è§†çš„å†…å­˜çš„å½“å‰å€¼ã€‚	 ä¸æ”¯æŒ	 è¿™ä¸ªwatch tracepointç›‘è§†çš„å†…å­˜çš„å½“å‰å€¼ã€‚
+$watch_prev_val	 ä¸æ”¯æŒ	 ä¸æ”¯æŒ	 ä¸æ”¯æŒ	 è¿™ä¸ªwatch tracepointç›‘è§†çš„å†…å­˜çš„ä¿®æ”¹å‰å€¼ã€‚	 ä¸æ”¯æŒ	 è¿™ä¸ªwatch tracepointç›‘è§†çš„å†…å­˜çš„ä¿®æ”¹å‰å€¼ã€‚
+$watch_count	 ä¸æ”¯æŒ	 ä¸æ”¯æŒ	 ä¸æ”¯æŒ	 ä¸æ”¯æŒ	 ä¸æ”¯æŒ	 è¿™ä¸ªwatch tracepointä¼šè¯çš„ä¸€ä¸ªç‰¹æ®Šè®¡æ•°IDã€‚
+é™æ€watch tracepoint
+å½“ä½ è¦ç›‘è§†å…¨å±€å˜é‡æˆ–è€…å¯ä»¥å–å¾—åœ°å€çš„å˜é‡çš„å€¼çš„æ—¶å€™ï¼Œä½ å¯ä»¥ä½¿ç”¨é™æ€watch tracepointã€‚ä¸‹é¢æ˜¯ä¸€ä¸ªç›‘è§†jiffies_64å†™çš„ä¾‹å­:
+
+#é™æ€watch tracepointä»Žtracepointçš„åœ°å€ä¸­å–å¾—è¦ç›‘è§†çš„åœ°å€
+trace *&jiffies_64
+  actions
+    #Set this watch tracepoint to static
+    teval $watch_static=1
+    #Watch memory write
+    teval $watch_type=1
+    teval $watch_size=8
+    collect $watch_val
+    collect $watch_prev_val
+    collect $bt
+  end
+åŠ¨æ€watch tracepoint
+å½“ä½ è¦ç›‘è§†å±€éƒ¨å˜é‡æˆ–è€…åªèƒ½åœ¨å‡½æ•°ä¸­å–å¾—åœ°å€çš„å˜é‡çš„å€¼çš„æ—¶å€™ï¼Œä½ å¯ä»¥ä½¿ç”¨åŠ¨æ€watch tracepointã€‚ä¸‹é¢æ˜¯ä¸€ä¸ªç›‘è§†å‡½æ•°function get_empty_filpä¸­f->f_posf->f_opå†™çš„ä¾‹å­:
+
+trace *1
+  commands
+    teval $watch_static=0
+    teval $watch_type=1
+    teval $watch_size=8
+    collect $bt
+    collect $watch_addr
+    collect $watch_val
+    collect $watch_prev_val
+  end
+å®šä¹‰äº†ä¸€ä¸ªåŠ¨æ€watch tracepointã€‚åœ°å€"1"å¹¶ä¸æ˜¯å…¶è¦ç›‘è§†çš„åœ°å€ã€‚å…¶å°†å¸®åŠ©tracepointæ¥æ‰¾åˆ°è¿™ä¸ªåŠ¨æ€watch tracepointã€‚
+
+list get_empty_filp
+trace 133
+  commands
+    teval $watch_set_addr=1
+    teval $watch_size=4
+    teval $watch_start=&(f->f_pos)
+    teval $watch_size=8
+    teval $watch_start=&(f->f_op)
+  end
+åœ¨å‡½æ•°get_empty_filpä¸­å®šä¹‰ä¸€ä¸ªæ™®é€štracepointï¼Œå…¶å°†å¼€å§‹ç›‘è§†f->f_poså’Œf->f_opã€‚
+
+trace file_sb_list_del
+  commands
+    teval $watch_stop=&(file->f_pos)
+    teval $watch_stop=&(file->f_op)
+  end
+åœ¨å‡½æ•°file_sb_list_delä¸­å®šä¹‰ä¸€ä¸ªæ™®é€štracepointï¼Œå…¶å°†åœæ­¢ç›‘è§†file->f_poså’Œfile->f_opã€‚
+
+ä½¿ç”¨while-steppingè®©Linuxå†…æ ¸åšå•æ­¥
+è¯· æ³¨æ„ while-steppingçŽ°åœ¨åªæœ‰X86å’ŒX86_64æ”¯æŒã€‚
+ä»‹ç»ä½¿ç”¨while-steppingçš„è§†é¢‘ http://www.codepark.us/a/12ã€‚
+
+å¦‚ä½•ä½¿ç”¨ while-stepping
+while-stepping æ˜¯ä¸€ç§å¯ä»¥åŒ…å«actionsçš„ç‰¹æ®Štracepoint actionã€‚
+å½“ä¸€ä¸ªactionsä¸­åŒ…å«äº†â€œwhile-stepping nâ€çš„tracepointæ‰§è¡Œçš„æ—¶å€™ï¼Œå…¶å°†åšnæ¬¡å•æ­¥å¹¶æ‰§è¡Œwhile-steppingçš„actionsã€‚ä¾‹å¦‚ï¼š
+
+trace vfs_read
+#å› ä¸ºå•æ­¥ä¼šå½±å“ç³»ç»Ÿé€Ÿåº¦ï¼Œæ‰€ä»¥æœ€å¥½ç”¨passcountæˆ–è€…conditioné™åˆ¶tracepointçš„æ‰§è¡Œæ¬¡æ•°ã€‚
+passcount 1
+  commands
+    collect $bt
+    collect $step_count
+    #åš2000æ¬¡å•æ­¥ã€‚
+    while-stepping 2000
+      #ä¸‹é¢è¿™éƒ¨åˆ†æ˜¯"while-stepping 2000"çš„actionsã€‚
+      #å› ä¸ºå•æ­¥å¯èƒ½ä¼šæ‰§è¡Œåˆ°å…¶ä»–å‡½æ•°ï¼Œæ‰€ä»¥æœ€å¥½ä¸è¦è®¿é—®å±€éƒ¨å˜é‡ã€‚
+      collect $bt
+      collect $step_count
+    end
+  end
+è¯· æ³¨æ„ tracepointåœ¨æ‰§è¡Œå•æ­¥çš„æ—¶å€™ä¼šå…³é—­å½“å‰CPUçš„ä¸­æ–­ã€‚ åœ¨actionsä¸­è®¿é—® $step_count å°†å¾—åˆ°ä»Ž1å¼€å§‹çš„è¿™æ­¥çš„è®¡æ•°ã€‚
+
+è¯»while-steppingçš„traceframe
+ä¸åŒstepçš„æ•°æ®å°†ä¼šè¢«è®°å½•åˆ°ä¸åŒçš„traceframeä¸­ï¼Œä½ å¯ä»¥ç”¨tfind (https://code.google.com/p/kgtp/wiki/HOWTOCN#ç”¨tfindé€‰æ‹©traceå¸§ç¼“å­˜é‡Œé¢çš„æ¡ç›®) é€‰æ‹©ä»–ä»¬ã€‚
+æˆ–è€…ä½ å¯ä»¥å°†KGTPåˆ‡æ¢åˆ°å›žæ”¾æ¨¡å¼ï¼Œè¿™æ ·GDBå¯ä»¥ç”¨æ‰§è¡Œå’Œåå‘æ‰§è¡Œå‘½ä»¤é€‰æ‹©ä¸€ä¸ªwhile-stepping tracepointçš„traceframeã€‚ä¾‹å¦‚ï¼š
+ç”¨tfindé€‰æ‹©ä¸€ä¸ªwhile-steppingçš„traceframeã€‚
+
+(gdb) tfind 
+Found trace frame 0, tracepoint 1
+#0  vfs_read (file=0xffff8801f7bd4c00, buf=0x7fff74e4edb0 <Address 0x7fff74e4edb0 out of bounds>, count=16, 
+    pos=0xffff8801f4b45f48) at /build/buildd/linux-3.2.0/fs/read_write.c:365
+365     {
+ä¸‹é¢çš„å‘½ä»¤å°†åˆ‡æ¢KGTPåˆ°å›žæ”¾æ¨¡å¼ã€‚
+
+(gdb) monitor replay
+(gdb) tfind -1
+No longer looking at any trace frame
+#0  vfs_read (file=0xffff8801f7bd4c00, buf=0x7fff74e4edb0 <Address 0x7fff74e4edb0 out of bounds>, count=16, 
+    pos=0xffff8801f4b45f48) at /build/buildd/linux-3.2.0/fs/read_write.c:365
+365     {
+äºŽæ˜¯å¯ä»¥ä½¿ç”¨æ‰§è¡Œå‘½ä»¤ã€‚
+
+(gdb) n
+368             if (!(file->f_mode & FMODE_READ))
+(gdb) p file->f_mode
+$5 = 3
+è®¾ç½®æ–­ç‚¹ (åªåœ¨å›žæ”¾æ¨¡å¼ä¸‹æœ‰æ•ˆï¼Œä¸ä¼šå½±å“åˆ°Linuxå†…æ ¸æ‰§è¡Œ)ã€‚
+
+(gdb) b 375
+Breakpoint 2 at 0xffffffff81179b75: file /build/buildd/linux-3.2.0/fs/read_write.c, line 375.
+(gdb) c
+Continuing.
+
+Breakpoint 2, vfs_read (file=0xffff8801f7bd4c00, buf=0x7fff74e4edb0 <Address 0x7fff74e4edb0 out of bounds>, count=16, 
+    pos=0xffff8801f4b45f48) at /build/buildd/linux-3.2.0/fs/read_write.c:375
+375             ret = rw_verify_area(READ, file, pos, count);
+(gdb) s
+rw_verify_area (read_write=0, file=0xffff8801f7bd4c00, ppos=0xffff8801f4b45f48, count=16)
+    at /build/buildd/linux-3.2.0/fs/read_write.c:300
+300             inode = file->f_path.dentry->d_inode;
+ä½¿ç”¨åå‘æ‰§è¡Œå‘½ä»¤ã€‚
+
+(gdb) rs
+
+Breakpoint 2, vfs_read (file=0xffff8801f7bd4c00, buf=0x7fff74e4edb0 <Address 0x7fff74e4edb0 out of bounds>, count=16, 
+    pos=0xffff8801f4b45f48) at /build/buildd/linux-3.2.0/fs/read_write.c:375
+375             ret = rw_verify_area(READ, file, pos, count);
+(gdb) rn
+372             if (unlikely(!access_ok(VERIFY_WRITE, buf, count)))
+GDBå‘½ä»¤tstartï¼Œtstopï¼Œtfindæˆ–è€…quitå¯ä»¥è‡ªåŠ¨å…³é—­å›žæ”¾æ¨¡å¼ã€‚
+
+å¦‚ä½•æ˜¾ç¤ºè¢«ä¼˜åŒ–æŽ‰çš„å˜é‡å€¼
+æœ‰æ—¶GDBä¼šè¿™æ ·è¾“å‡ºä¿¡æ¯ï¼š
+
+inode has been optimized out of existence.
+res has been optimized out of existence.
+è¿™æ˜¯å› ä¸ºinodeå’Œresçš„å€¼è¢«ä¼˜åŒ–æŽ‰äº†ã€‚å†…æ ¸ç”¨-O2ç¼–è¯‘çš„æ‰€ä»¥ä½ æœ‰æ—¶ä¼šç¢°åˆ°è¿™ä¸ªé—®é¢˜ã€‚
+æœ‰ä¸¤ä¸ªæ–¹æ³•å¤„ç†è¿™ä¸ªé—®é¢˜ï¼š
+
+å‡çº§ä½ çš„GCC
+VTA branch http://gcc.gnu.org/wiki/Var_Tracking_Assignments å·²ç»æ•´åˆè¿›GCC 4.5ï¼Œå…¶å¯ä»¥å¸®åŠ©ç”Ÿæˆä¹‹å‰è¢«æ ‡è®°ä¸º"optimized out"çš„å€¼çš„è°ƒè¯•ä¿¡æ¯ã€‚
+
+é€šè¿‡åˆ†æžæ±‡ç¼–ä»£ç å–å¾—è®¿é—®è¢«ä¼˜åŒ–æŽ‰å˜é‡çš„æ–¹æ³•
+å³ä½¿å‡çº§äº†GCCï¼Œä½ å¯èƒ½è¿˜ä¼šé‡åˆ°é—®é¢˜ã€‚ä¸»è¦åŽŸå› æ˜¯æ•°æ®åœ¨å¯„å­˜å™¨ä¸­ä½†æ˜¯GCCæ²¡æœ‰æŠŠä¿¡æ¯æ”¾åˆ°è°ƒè¯•ä¿¡æ¯ä¸­ã€‚æ‰€ä»¥GDBåªèƒ½æ˜¾ç¤ºè¿™ä¸ªå˜é‡è¢«åˆä¼˜åŒ–æŽ‰äº†ã€‚
+ä½†ä½ å¯ä»¥é€šè¿‡åˆ†æžæ±‡ç¼–ä»£ç å–å¾—è¿™ä¸ªå˜é‡åœ¨å“ªå¹¶åœ¨tracepoint actionsä¸­è®¿é—®å…¶ã€‚
+ä¸‹é¢æ˜¯ä¸€ä¸ªåœ¨å‡½æ•°get_empty_filpä¸­å¯»æ‰¾å˜é‡"f"å¹¶åœ¨tracepoint actionsä¸­ä½¿ç”¨å…¶çš„ä¾‹å­ï¼š
+æˆ‘ä»¬æƒ³collectå˜é‡fçš„å€¼ï¼Œä½†æ˜¯å…¶å·²ç»è¢«ä¼˜åŒ–æŽ‰äº†ã€‚
+
+(gdb) list get_empty_filp
+...
+...
+...
+137             INIT_LIST_HEAD(&f->f_u.fu_list);
+138             atomic_long_set(&f->f_count, 1);
+139             rwlock_init(&f->f_owner.lock);
+140             spin_lock_init(&f->f_lock);
+141             eventpoll_init_file(f);
+(gdb) 
+142             /* f->f_version: 0 */
+143             return f;
+(gdb) trace 143
+Tracepoint 1 at 0xffffffff8119b30e: file fs/file_table.c, line 143.
+(gdb) actions 
+Enter actions for tracepoint 1, one per line.
+End with a line saying just "end".
+>collect f
+`f' is optimized away and cannot be collected.
+çŽ°åœ¨ç”¨"disassemble /m"å‘½ä»¤å–å¾—å’Œ"f"æœ‰å…³çš„æ±‡ç¼–ä»£ç å’Œæºç å¹¶åˆ†æžä»–ä»¬ã€‚
+
+(gdb) disassemble /m get_empty_filp
+...
+...
+...
+125             f = kmem_cache_zalloc(filp_cachep, GFP_KERNEL);
+126             if (unlikely(!f))
+   0xffffffff8119b28c <+92>:    test   %rax,%rax
+   0xffffffff8119b292 <+98>:    je     0xffffffff8119b362 <get_empty_filp+306>
+
+127                     return ERR_PTR(-ENOMEM);
+   0xffffffff8119b362 <+306>:   mov    $0xfffffffffffffff4,%rax
+   0xffffffff8119b369 <+313>:   jmp    0xffffffff8119b311 <get_empty_filp+225>
+å› ä¸º"+98"åˆ°"+132"çš„ä»£ç å› ä¸ºå±žäºŽinlineå‡½æ•°æ‰€ä»¥æ²¡æœ‰åœ¨è¿™é‡Œæ˜¾ç¤ºï¼Œä½†æ˜¯ä½ å¯ä»¥ç”¨"disassemble get_empty_filp"å–å¾—ä»–ä»¬ã€‚
+
+   0xffffffff8119b287 <+87>:    callq  0xffffffff81181cb0 <kmem_cache_alloc>
+   0xffffffff8119b28c <+92>:    test   %rax,%rax
+   0xffffffff8119b28f <+95>:    mov    %rax,%rbx
+   0xffffffff8119b292 <+98>:    je     0xffffffff8119b362 <get_empty_filp+306>
+   0xffffffff8119b298 <+104>:   mov    0xb4d406(%rip),%edx        # 0xffffffff81ce86a4 <percpu_counter_batch>
+   0xffffffff8119b29e <+110>:   mov    $0x1,%esi
+   0xffffffff8119b2a3 <+115>:   mov    $0xffffffff81c05340,%rdi
+---Type <return> to continue, or q <return> to quit---
+   0xffffffff8119b2aa <+122>:   callq  0xffffffff8130dd20 <__percpu_counter_add>
+æ ¹æ®æ±‡ç¼–ä»£ç ä½ å¯ä»¥çœ‹åˆ°kmem_cache_allocçš„è¿”å›žå€¼åœ¨$raxä¸­ï¼Œå…¶çš„å€¼è¢«è®¾ç½®åˆ°äº†$rbxä¸­ã€‚
+çœ‹èµ·æ¥$rbxæœ‰"f"çš„å€¼ï¼Œè®©æˆ‘ä»¬çœ‹å…¶ä»–çš„æ±‡ç¼–ä»£ç ã€‚
+
+128     
+129             percpu_counter_inc(&nr_files);
+130             f->f_cred = get_cred(cred);
+   0xffffffff8119b2b4 <+132>:   mov    %r12,0x70(%rbx)
+è®¾ç½®ä¸€ä¸ªå€¼åˆ°fçš„å…ƒç´ ä¸­ã€‚æ±‡ç¼–ä»£ç æ˜¯è®¾ç½®$r12çš„å€¼åˆ°ä»¥$rbxä¸ºåŸºç¡€åœ°å€çš„å†…å­˜ä¸­ã€‚å…¶è®©$rbxçœ‹èµ·æ¥æ˜¯"f"ã€‚
+
+131             error = security_file_alloc(f);
+   0xffffffff8119b2b8 <+136>:   mov    %rbx,%rdi
+   0xffffffff8119b2bb <+139>:   callq  0xffffffff8128ee30 <security_file_alloc>
+
+132             if (unlikely(error)) {
+   0xffffffff8119b2c0 <+144>:   test   %eax,%eax
+   0xffffffff8119b2c2 <+146>:   jne    0xffffffff8119b36b <get_empty_filp+315>
+---Type <return> to continue, or q <return> to quit---
+
+133                     file_free(f);
+134                     return ERR_PTR(error);
+   0xffffffff8119b393 <+355>:   movslq -0x14(%rbp),%rax
+   0xffffffff8119b397 <+359>:   jmpq   0xffffffff8119b311 <get_empty_filp+225>
+
+135             }
+136     
+137             INIT_LIST_HEAD(&f->f_u.fu_list);
+138             atomic_long_set(&f->f_count, 1);
+139             rwlock_init(&f->f_owner.lock);
+   0xffffffff8119b2e4 <+180>:   movl   $0x100000,0x50(%rbx)
+
+140             spin_lock_init(&f->f_lock);
+   0xffffffff8119b2c8 <+152>:   xor    %eax,%eax
+   0xffffffff8119b2d1 <+161>:   mov    %ax,0x30(%rbx)
+
+141             eventpoll_init_file(f);
+142             /* f->f_version: 0 */
+143             return f;
+   0xffffffff8119b30e <+222>:   mov    %rbx,%rax
+åœ¨æ£€æŸ¥äº†å…¶ä»–æ±‡ç¼–ä»£ç åŽï¼Œä½ å¯ä»¥ç¡®å®š$rbxå°±æ˜¯"f"ã€‚
+äºŽæ˜¯ä½ å¯ä»¥åœ¨tracepoint actionsä¸­é€šè¿‡è®¿é—®$rbxè€Œè®¿é—®"f"ï¼Œä¾‹å¦‚ï¼š
+
+(gdb) trace 143
+Tracepoint 1 at 0xffffffff8119b30e: file fs/file_table.c, line 143.
+(gdb) actions 
+Enter actions for tracepoint 1, one per line.
+End with a line saying just "end".
+#collect f
+>collect $rbx
+#collect *f
+>collect *((struct file *)$rbx)
+#collect f->f_op
+>collect ((struct file *)$rbx)->f_op
+>end
+å¦‚ä½•å–å¾—å‡½æ•°æŒ‡é’ˆæŒ‡å‘çš„å‡½æ•°
+å¦‚æžœå‡½æ•°æŒ‡é’ˆæ²¡æœ‰è¢«ä¼˜åŒ–æŽ‰
+ä½ å¯ä»¥ç›´æŽ¥collectè¿™ä¸ªæŒ‡é’ˆï¼Œä¾‹å¦‚ï¼š
+
+377                     count = ret;
+378                     if (file->f_op->read)
+379                             ret = file->f_op->read(file, buf, count, pos);
+(gdb) 
+(gdb) trace 379
+Tracepoint 1 at 0xffffffff81173ba5: file /home/teawater/kernel/linux/fs/read_write.c, line 379.
+(gdb) actions 
+Enter actions for tracepoint 1, one per line.
+End with a line saying just "end".
+>collect file->f_op->read
+>end
+(gdb) tstart
+(gdb) tstop
+(gdb) tfind
+(gdb) p file->f_op->read
+$5 = (ssize_t (*)(struct file *, char *, size_t, loff_t *)) 0xffffffff81173190 <do_sync_read>
+#äºŽæ˜¯å°±çŸ¥é“file->f_op->readæŒ‡å‘do_sync_readã€‚
+å¦‚æžœå‡½æ•°æŒ‡é’ˆè¢«ä¼˜åŒ–æŽ‰äº†
+å¯ä»¥ç”¨tracepoint stepå¤„ç†è¿™ä¸ªé—®é¢˜ï¼Œä¾‹å¦‚ï¼š
+
+#æ‰¾åˆ°è°ƒç”¨æŒ‡é’ˆçš„æŒ‡ä»¤
+(gdb) disassemble /rm vfs_read
+379                             ret = file->f_op->read(file, buf, count, pos);
+   0xffffffff81173ba5 <+181>:   48 89 da        mov    %rbx,%rdx
+   0xffffffff81173ba8 <+184>:   4c 89 e9        mov    %r13,%rcx
+   0xffffffff81173bab <+187>:   4c 89 e6        mov    %r12,%rsi
+   0xffffffff81173bae <+190>:   4c 89 f7        mov    %r14,%rdi
+   0xffffffff81173bb1 <+193>:   ff d0   callq  *%rax
+   0xffffffff81173bb3 <+195>:   48 89 c3        mov    %rax,%rbx
+(gdb) trace *0xffffffff81173bb1
+Tracepoint 1 at 0xffffffff81173bb1: file /home/teawater/kernel/linux/fs/read_write.c, line 379.
+(gdb) actions 
+Enter actions for tracepoint 1, one per line.
+End with a line saying just "end".
+>while-stepping 1
+ >collect $reg
+ >end
+>end
+(gdb) tstart 
+(gdb) tstop 
+(gdb) tfind 
+#0  tty_read (file=0xffff88006ca74900, buf=0xb6b7dc <Address 0xb6b7dc out of bounds>, count=8176, 
+    ppos=0xffff88006e197f48) at /home/teawater/kernel/linux/drivers/tty/tty_io.c:960
+960     {
+#äºŽæ˜¯å°±çŸ¥é“file->f_op->readæŒ‡å‘tty_readã€‚
+è¯· æ³¨æ„ while-stepping å°†è®©tracepointä¸èƒ½ä½¿ç”¨kprobes-optimizationã€‚
+
+/sys/kernel/debug/gtpframeå’Œç¦»çº¿è°ƒè¯•
+/sys/kernel/debug/gtpframeæ˜¯ä¸€ä¸ªå½“KGTPåœæ­¢æ—¶çš„tfineæ ¼å¼ï¼ˆGDBå¯ä»¥è¯»å–å®ƒï¼‰çš„æŽ¥å£ã€‚
+åœ¨è¿è¡ŒGDBçš„ä¸»æœºä¸Šï¼š
+æ”¹å˜ "target remote XXXX" ä¸ºï¼š
+
+(gdb) target remote | perl ./getgtprsp.pl
+ä¹‹åŽåƒå¹³æ—¶ä¸€æ ·è®¾ç½®tracepointï¼š
+
+(gdb) trace vfs_readdir
+Tracepoint 1 at 0xffffffff8114f3c0: file /home/teawater/kernel/linux-2.6/fs/readdir.c, line 24.
+(gdb) actions 
+Enter actions for tracepoint 1, one per line.
+End with a line saying just "end".
+#If your GDB support tracepoint "printf" (see "Howto use tracepoint printf"), use it to show the value directly is better.
+>collect $reg
+>end
+(gdb) tstart 
+(gdb) stop 
+(gdb) quit
+äºŽæ˜¯ä½ å¯ä»¥åœ¨å½“å‰ç›®å½•æ‰¾åˆ°æ–‡ä»¶gtpstartå’Œgtpstopï¼ŒæŠŠä»–ä»¬æ‹·è´åˆ°ä½ æƒ³è°ƒè¯•çš„ä¸»æœºä¸Šã€‚
+
+åœ¨è¢«è°ƒè¯•ä¸»æœºä¸Šï¼Œå…ˆæ‹·è´KGTPç›®å½•ä¸­çš„ç¨‹åº"putgtprsp"å’Œ"gtp.ko"åˆ°è¿™å°æœºå™¨ä¸Šã€‚insmod gtp.koä¹‹åŽï¼š
+å¯åŠ¨tracepointï¼š
+
+./putgtprsp ./gtpstart
+åœæ­¢tracepointï¼š
+
+./putgtprsp ./gtpstop
+å¯ä»¥æŒ‰ç…§http://code.google.com/p/kgtp/wiki/HOWTOCN#å¦‚ä½•è®©tracepointç›´æŽ¥è¾“å‡ºä¿¡æ¯ç›´æŽ¥åœ¨æ¿å­ä¸Šæ˜¾ç¤ºä¿¡æ¯ã€‚
+
+å¦‚æžœè¦ä¿å­˜traceå¸§ä¹‹åŽå†åˆ†æžï¼Œä½ å¯ä»¥æ‹·è´æ–‡ä»¶"/sys/kernel/debug/gtpframe"åˆ°æœ‰GDBçš„ä¸»æœºä¸Šã€‚
+è¯· æ³¨æ„ æœ‰äº›"cp"ä¸èƒ½å¾ˆå¥½çš„å¤„ç†è¿™ä¸ªé—®é¢˜ï¼Œå¯ä»¥ç”¨"cat /sys/kernel/debug/gtpframe > ./gtpframe"æ‹·è´å®ƒã€‚
+åœ¨è¿è¡ŒGDBçš„ä¸»æœºä¸Šï¼š
+(gdb) target tfile ./gtpframe
+Tracepoint 1 at 0xffffffff8114f3dc: file /home/teawater/kernel/linux-2.6/fs/readdir.c, line 24.
+Created tracepoint 1 for target's tracepoint 1 at 0xffffffff8114f3c0.
+(gdb) tfind 
+Found trace frame 0, tracepoint 1
+#0  vfs_readdir (file=0xffff880036e8f300, filler=0xffffffff8114f240 <filldir>, buf=0xffff880001e5bf38)
+    at /home/teawater/kernel/linux-2.6/fs/readdir.c:24
+24      {
+è¯· æ³¨æ„ å¦‚æžœä½ æƒ³åœ¨ä½¿ç”¨ç¦»çº¿è°ƒè¯•åŽä»Žè¿œç¨‹ä¸»æœºä¸Šçš„GDBè¿žæŽ¥KGTPï¼Œä½ éœ€è¦åœ¨è°ƒç”¨"nc"ä¹‹å‰"rmmod gtp"å’Œ"insmod gtp.ko"ã€‚
+
+å¦‚ä½•ä½¿ç”¨ /sys/kernel/debug/gtpframe_pipe
+è¿™ä¸ªæŽ¥å£æä¾›å’Œ"gtpframe"åŒæ ·çš„æ•°æ®ï¼Œä½†æ˜¯å¯ä»¥åœ¨KGTP tracepointè¿è¡Œçš„æ—¶å€™ä¹Ÿå¯ä»¥ä½¿ç”¨ã€‚åœ¨æ•°æ®è¯»å‡ºä¹‹åŽï¼Œå…¶å°†è‡ªåŠ¨ä»Žtraceå¸§é‡Œåˆ é™¤ç±»ä¼¼ftrace "trace_pipe"ã€‚
+
+ç”¨GDBè¯»å¸§ä¿¡æ¯
+#è¿žæŽ¥åˆ°æŽ¥å£ä¸Š
+(gdb) target tfile /sys/kernel/debug/gtpframe_pipe
+#å–å¾—ä¸€ä¸ªtraceå¸§æ¡ç›®
+(gdb) tfind 0
+Found trace frame 0, tracepoint 1
+#å–å¾—ä¸‹ä¸€ä¸ª
+(gdb) tfind 
+Target failed to find requested trace frame.
+(gdb) tfind 0
+Found trace frame 0, tracepoint 1
+è¿™ä¸ªæ–¹æ³•å’Œpythonä¸€èµ·åˆ†æžå†…æ ¸æ¯”è¾ƒå¥½ï¼Œadd-ons/hotcode.pyå°±æ˜¯è¿™æ ·çš„ä¾‹å­ã€‚
+
+ç”¨catè¯»å¸§ä¿¡æ¯
+sudo cat /sys/kernel/debug/gtpframe_pipe > g
+äºŽæ˜¯æ‰€æœ‰å¸§ä¿¡æ¯éƒ½è¢«å­˜å…¥äº†æ–‡ä»¶"g"ã€‚
+
+ç”¨getframeè¯»å¸§ä¿¡æ¯
+KGTPåŒ…å«ä¸€ä¸ª"getframe"å¯ä»¥ç”¨æ¥å¸®åŠ©å–å¾—traceå¸§ã€‚
+ä¸‹é¢è¿™é‡Œæ˜¯å®ƒçš„å¸®åŠ©ï¼š
+
+getframe -h
+Get the trace frame of KGTP and save them in current 
+directory with tfile format.
+Usage: ./getframe [option]
+
+  -g n    Set the minimum free size limit to n G.
+          When free size of current disk is smaller than n G,
+          ./getframe will exit (-q) or wait some seconds (-w).
+          The default value of it is 2 G.
+
+  -q      Quit when current disk is smaller than
+          minimum free size limit (-g).
+
+  -w n    Wait n seconds when current disk is smaller
+          than minimum free size limit (-g).
+
+  -e n    Set the entry number of each tfile to n.
+          The default value of it is 1000.
+
+  -h      Display this information.
+ä½¿ç”¨ $pipe_trace
+ä¸ºäº†é”å®‰å…¨ï¼ŒKGTPé»˜è®¤å°†è‡ªåŠ¨å¿½ç•¥è¯»/sys/kernel/debug/gtpframe_pipeçš„ä»»åŠ¡ã€‚
+å¦‚æžœä½ çœŸå¸Œæœ›traceè¿™ä¸ªä»»åŠ¡è€Œä¸”ç¡®å®šè¿™æ˜¯å®‰å…¨çš„ï¼Œä½ å¯ä»¥ä½¿ç”¨"tstart"ä¹‹å‰ä½¿ç”¨ä¸‹é¢çš„å‘½ä»¤ï¼š
+
+(gdb) tvariable $pipe_trace=1
+äºŽæ˜¯KGTPå°†ä¸å†å¿½ç•¥è¯»/sys/kernel/debug/gtpframe_pipeçš„ä»»åŠ¡ã€‚
+
+å’Œç”¨æˆ·å±‚ç¨‹åºä¸€èµ·ä½¿ç”¨KGTP
+ç›´æŽ¥è¯»ç”¨æˆ·å±‚ç¨‹åºçš„å†…å­˜
+KGTPå¯ä»¥ä¸åŒåœæ­¢åº”ç”¨å±‚ç¨‹åºçš„æƒ…å†µä¸‹ç›´æŽ¥è¯»å–å…¶å†…å­˜ï¼Œè¯·åˆ°http://code.google.com/p/kgtp/wiki/HOWTOCN#ç”¨æˆ·ç¨‹åºçš„å†…å­˜å–å¾—å¦‚ä½•åšã€‚
+
+åœ¨tracepointæ”¶é›†ç”¨æˆ·å±‚ç¨‹åºçš„æ ˆä¿¡æ¯(å¯ç”¨æ¥åšbacktrace)
+$current æ˜¯ä¸€ä¸ªç‰¹æ®ŠtraceçŠ¶æ€å˜é‡ã€‚å½“ä¸€ä¸ªtracepointçš„action è®¿é—®å…¶çš„æ—¶å€™ï¼Œtracepointå°†æ”¶é›†å½“å‰taskçš„å¯„å­˜å™¨å’Œå†…å­˜å€¼è€Œä¸æ˜¯å†…æ ¸ä¸­çš„å€¼ã€‚
+ä¸€èˆ¬æ¥è¯´ï¼Œtracepointé€šè¿‡ task_pt_regs å–å¾—å¯„å­˜å™¨çš„å€¼ã€‚äºŽæ˜¯åœ¨tracepoint actionsä¸­collect $current å°†è®©tracepointè®¿é—®å½“å‰taskã€‚ä¾‹å¦‚ï¼š
+
+(gdb) actions 
+Enter actions for tracepoint 1, one per line.
+End with a line saying just "end".
+>collect $current
+>collect $bt
+>end
+æ­¤å¤–ï¼Œé’ˆå¯¹ä¸€äº›å‚æ•°ä¸­åŒ…å«æŒ‡å‘å½“å‰TASKå¯„å­˜å™¨æŒ‡é’ˆçš„ç‰¹æ®Šå‡½æ•°(ä¾‹å¦‚ï¼šX86çš„do_IRQå‡½æ•°)ï¼Œtracepointéœ€è¦ä»Žå‡½æ•°çš„å‚æ•°ä¸­å–å¾—å¯„å­˜å™¨ä¿¡æ¯ã€‚åˆ™è®¾ç½®æŒ‡é’ˆåˆ° $current å°†è®©tracepointå¾—åˆ°å…¶ã€‚ä¾‹å¦‚ï¼š
+
+(gdb) actions 
+Enter actions for tracepoint 1, one per line.
+End with a line saying just "end".
+>teval $current=(uint64_t)regs
+>collect $bt
+>end
+$current_task_user æ˜¯ä¸€ä¸ªç‰¹æ®ŠtraceçŠ¶æ€å˜é‡ã€‚å½“current task åœ¨useræ¨¡å¼çš„æ—¶å€™ï¼Œå…¶çš„å€¼ä¸ºçœŸã€‚
+ç”¨è¿™ä¸¤ä¸ªtraceçŠ¶æ€å˜é‡ï¼Œå°±å¯ä»¥ç”¨KGTPæ”¶é›†ç”¨æˆ·å±‚ç¨‹åºçš„æ ˆä¿¡æ¯(å¯ç”¨æ¥åšbacktrace)ã€‚
+ä¸‹é¢è¿™ä¸ªä¾‹å­æ˜¾ç¤ºå¦‚ä½•ä»Žç”¨æˆ·å±‚åˆ°Linuxå†…æ ¸å±‚åšbacktrace(stack dump)ï¼š
+
+#è¿žæŽ¥KGTP(å’Œä¸Šä¸€èŠ‚ä»‹ç»çš„æ–¹æ³•ç›¸åŒ)
+(gdb) target extended-remote /sys/kernel/debug/gtp
+#è®¾ç½®ä¸€ä¸ªæ”¶é›†è¿›ç¨‹18776çš„ç”¨æˆ·æ ˆçš„tracepointã€‚
+(gdb) trace vfs_read
+Tracepoint 1 at 0xffffffff8117a3d0: file /home/teawater/kernel/linux/fs/read_write.c, line 365.
+(gdb) condition 1 ($current_task_user && $current_task_pid == 18776)
+(gdb) actions 
+Enter actions for tracepoint 1, one per line.
+End with a line saying just "end".
+>collect $current
+>collect $bt
+>end
+#Setup a tracepoint that collect kernel space stack of task 18776.
+#è®¾ç½®ä¸€ä¸ªæ”¶é›†è¿›ç¨‹18776çš„å†…æ ¸æ ˆçš„tracepointã€‚
+(gdb) trace vfs_read
+Note: breakpoint 1 also set at pc 0xffffffff8117a3d0.
+Tracepoint 2 at 0xffffffff8117a3d0: file /home/teawater/kernel/linux/fs/read_write.c, line 365.
+(gdb) condition 2 ($current_task_user && $current_task_pid == 18776)
+(gdb) actions 
+Enter actions for tracepoint 2, one per line.
+End with a line saying just "end".
+>collect $bt
+>end
+(gdb) tstart
+(gdb) tstop
+#ä¸‹é¢è¿™éƒ¨åˆ†å’Œä¸Šä¸€èŠ‚ç›¸åŒï¼Œå¢žåŠ ä¸€ä¸ªæ–°çš„inferiorç”¨æ¥åˆ†æžåº”ç”¨ç¨‹åºçš„ä¿¡æ¯ã€‚
+(gdb) add-inferior 
+Added inferior 2
+(gdb) inferior 2
+[Switching to inferior 2 [<null>] (<noexec>)]
+(gdb) file gdb
+Reading symbols from /usr/local/bin/gdb...done.
+(gdb) attach 18776
+#tracepoint 1 æ”¶é›†äº†ç”¨æˆ·å±‚çš„æ ˆä¿¡æ¯ã€‚
+(gdb) tfind
+Found trace frame 0, tracepoint 1
+#0  0x00007f77331d7d0f in __read_nocancel () from /lib/x86_64-linux-gnu/libpthread.so.0
+#è¿™æ˜¯ç¨‹åº18776ç”¨æˆ·å±‚çš„backtraceã€‚
+(gdb) bt
+#0  0x00007f77331d7d0f in __read_nocancel () from /lib/x86_64-linux-gnu/libpthread.so.0
+#1  0x000000000078e145 in rl_callback_read_char () at ../../src/readline/callback.c:201
+#2  0x000000000069de79 in rl_callback_read_char_wrapper (client_data=<optimized out>) at ../../src/gdb/event-top.c:169
+#3  0x000000000069ccf8 in process_event () at ../../src/gdb/event-loop.c:401
+#4  process_event () at ../../src/gdb/event-loop.c:351
+#5  0x000000000069d448 in gdb_do_one_event () at ../../src/gdb/event-loop.c:465
+#6  0x000000000069d5d5 in start_event_loop () at ../../src/gdb/event-loop.c:490
+#7  0x0000000000697083 in captured_command_loop (data=<optimized out>) at ../../src/gdb/main.c:226
+#8  0x0000000000695d8b in catch_errors (func=0x697070 <captured_command_loop>, func_args=0x0, errstring=0x14df99e "", 
+    mask=6) at ../../src/gdb/exceptions.c:546
+#9  0x00000000006979e6 in captured_main (data=<optimized out>) at ../../src/gdb/main.c:1001
+#10 0x0000000000695d8b in catch_errors (func=0x697360 <captured_main>, 
+    func@entry=<error reading variable: PC not available>, func_args=0x7fff08afd5b0, 
+    func_args@entry=<error reading variable: PC not available>, errstring=<unavailable>, 
+    errstring@entry=<error reading variable: PC not available>, mask=<unavailable>, 
+    mask@entry=<error reading variable: PC not available>) at ../../src/gdb/exceptions.c:546
+#11 <unavailable> in ?? ()
+Backtrace stopped: not enough registers or memory available to unwind further
+#tracepoint 2æ”¶é›†äº†å†…æ ¸ç©ºé—´çš„æ ˆï¼Œæ‰€ä»¥è¦åˆ‡æ¢å›žinferior 1è£…è½½å†…æ ¸è°ƒè¯•ä¿¡æ¯ã€‚
+(gdb) tfind
+Found trace frame 1, tracepoint 2
+#0  0xffffffff8117a3d0 in ?? ()
+(gdb) inferior 1
+[Switching to inferior 1 [Remote target] (/home/teawater/kernel/b/vmlinux)]
+[Switching to thread 1 (Remote target)] 
+#0  vfs_read (file=0xffff88021a559500, buf=0x7fff08afd31f <Address 0x7fff08afd31f out of bounds>, count=1, 
+    pos=0xffff8800c47e1f48) at /home/teawater/kernel/linux/fs/read_write.c:365
+365     {
+#è¿™æ˜¯å†…æ ¸æ ˆçš„backtraceã€‚
+(gdb) bt
+#0  vfs_read (file=0xffff88021a559500, buf=0x7fff08afd31f <Address 0x7fff08afd31f out of bounds>, count=1, 
+    pos=0xffff8800c47e1f48) at /home/teawater/kernel/linux/fs/read_write.c:365
+#1  0xffffffff8117a59a in sys_read (fd=<optimized out>, buf=0x7fff08afd31f <Address 0x7fff08afd31f out of bounds>, 
+    count=1) at /home/teawater/kernel/linux/fs/read_write.c:469
+#2  <signal handler called>
+#3  0x00007f77331d7d10 in ?? ()
+#4  0x0000000000000000 in ?? ()
+å¦‚ä½•ä½¿ç”¨ add-ons/hotcode.py
+è¿™ä¸ªè„šæœ¬å¯ä»¥é€šè¿‡è®°å½•å¹¶åˆ†æžä¸­æ–­å¤„ç†æ—¶å€™çš„å–å¾—çš„PCå€¼ä»Žè€Œå¾—åˆ°Linux kernelæˆ–è€…ç”¨æˆ·å±‚ç¨‹åºçš„çƒ­ç‚¹ä»£ç ã€‚
+è¯·åˆ° http://code.google.com/p/kgtp/wiki/hotcode åŽ»çœ‹å¦‚ä½•ä½¿ç”¨å®ƒã€‚
+
+å¦‚ä½•å¢žåŠ ç”¨Cå†™çš„æ’ä»¶
+KGTPæ”¯æŒç”¨Cå†™çš„æ’ä»¶ï¼Œæ’ä»¶å°†è¢«ç¼–è¯‘æˆLKMã€‚ KGTP support plugin that write in C. The plugin will be built as LKM
+
+API
+#include "gtp.h"
+è¿™æ˜¯æ’ä»¶éœ€è¦çš„åŒ…å«APIçš„å¤´æ–‡ä»¶ã€‚ 
+
+extern int gtp_plugin_mod_register(struct module *mod);
+extern int gtp_plugin_mod_unregister(struct module *mod);
+è¿™ä¸¤ä¸ªå‡½æ•°æ³¨å†Œå’Œæ³¨é”€æ’ä»¶æ¨¡å—ã€‚è¿™æ ·KGTPå°±å¯ä»¥åœ¨è®¿é—®æ’ä»¶æ¨¡å—èµ„æºçš„æ—¶å€™å¢žåŠ å…¶çš„å¼•ç”¨è®¡æ•°äº†ã€‚ 
+
+extern struct gtp_var *gtp_plugin_var_add(char *name, int64_t val,
+                                          struct gtp_var_hooks *hooks);
+è¿™ä¸ªå‡½æ•°ä¼šå¢žåŠ ç‰¹æ®ŠtraceçŠ¶æ€å˜é‡åˆ°KGTPã€‚
+
+name ç‰¹æ®ŠtraceçŠ¶æ€å˜é‡çš„åå­—.
+val ç‰¹æ®ŠtraceçŠ¶æ€å˜é‡çš„åˆå§‹å€¼.
+hooks å‡½æ•°æŒ‡é’ˆã€‚å¦‚æžœè¿™ä¸ªåŠŸèƒ½ä¸æ”¯æŒï¼Œå‡½æ•°æŒ‡é’ˆå°±è®¾ç½®ä¸ºNULLã€‚
+è¿”å›žå€¼ æˆåŠŸè¿”å›žgtp_varæŒ‡é’ˆã€‚å¤±è´¥åˆ™è¿”å›žç”¨IS_ERRå’ŒPTR_ERRå¯ä»¥å¤„ç†çš„é”™è¯¯ç ã€‚
+
+
+struct gtp_var_hooks {
+        int     (*gdb_set_val)(struct gtp_trace_s *unused, struct gtp_var *var,
+                               int64_t val);
+        int     (*gdb_get_val)(struct gtp_trace_s *unused, struct gtp_var *var,
+                               int64_t *val);
+        int     (*agent_set_val)(struct gtp_trace_s *gts, struct gtp_var *var,
+                                 int64_t val);
+        int     (*agent_get_val)(struct gtp_trace_s *gts, struct gtp_var *var,
+                                 int64_t *val);
+};
+gdb_set_val åœ¨GDBè®¾ç½®TSVå€¼çš„æ—¶å€™è°ƒç”¨ï¼Œè¯· æ³¨æ„ TSVåªèƒ½è¢«GDBå‘½ä»¤"tvariable $xxx=1"è®¾ç½®è€Œä¸”åªæœ‰åœ¨GDBå‘½ä»¤"tstart"çš„æ—¶å€™æ‰ä¼šè¢«å‘åˆ°KGTPã€‚
+unused æ˜¯æ— ç”¨çš„ï¼Œåªç”¨æ¥è®©è¿™ä¸ªæŒ‡é’ˆå¯ä»¥å’Œagent_set_valå…±äº«å‡½æ•°ã€‚
+var æ˜¯æŒ‡å‘gtp_varçš„æŒ‡é’ˆï¼ŒäºŽæ˜¯å½“å¤šä¸ªTSVå…±äº«ä¸€ä¸ªå‡½æ•°çš„æ—¶å€™ï¼Œè¿™ä¸ªå€¼å¯ä»¥ç”¨æ¥åˆ¤å®šå“ªä¸ªTSVè¢«è®¿é—®äº†ã€‚
+val æ˜¯GDBè®¾ç½®æ¥çš„å€¼ã€‚
+è¿”å›žå€¼ é”™è¯¯è¿”å›ž-1ï¼Œæ­£ç¡®è¿”å›ž0ã€‚
+gdb_get_val åœ¨GDBå–TSVå€¼çš„æ—¶å€™è¢«è°ƒç”¨ã€‚è¯· æ³¨æ„ å–TSVå€¼å’Œè®¾ç½®TSVä¸åŒï¼Œè®¾ç½®ä»»ä½•æ—¶å€™éƒ½ä¼šç›´æŽ¥ä»ŽKGTPé‡Œå–ï¼Œå¹¶ä¸”å–å€¼çš„GDBå‘½ä»¤å’Œè®¿é—®ä¸€ä¸ªæ™®é€šçš„GDBå†…éƒ¨å˜é‡ä¸€æ ·ã€‚ä¾‹å¦‚ï¼š"p $xxx"ã€‚
+unused å’Œgdb_set_valä½œç”¨ç›¸åŒã€‚
+var å’Œgdb_set_valä½œç”¨ç›¸åŒã€‚
+val ç”¨æ¥è¿”å›žå€¼çš„æŒ‡é’ˆã€‚
+è¿”å›žå€¼ å’Œgdb_set_valä½œç”¨ç›¸åŒã€‚
+agent_set_val åœ¨tracepoint action(http://code.google.com/p/kgtp/wiki/HOWTOCN#teval_expr1,_expr2,_...)è®¾ç½®TSVçš„æ—¶å€™è°ƒç”¨ã€‚
+gts æ˜¯æŒ‡å‘tracepointä¼šè¯ç»“æž„çš„æŒ‡é’ˆã€‚
+var å’Œgdb_set_valä½œç”¨ç›¸åŒã€‚
+val actionè®¾ç½®çš„å€¼ã€‚
+è¿”å›žå€¼ å’Œgdb_set_valä½œç”¨ç›¸åŒã€‚
+agent_get_val will be called when tracepoint action(http://code.google.com/p/kgtp/wiki/HOWTOCN#collect_expr1,_expr2,_... æˆ–è€… HOWTO#teval_expr1,_expr2,_...) get the TSV.
+gts å’Œagent_set_valä½œç”¨ç›¸åŒã€‚
+var å’Œgdb_set_valä½œç”¨ç›¸åŒã€‚
+val å’Œgdb_get_valä½œç”¨ç›¸åŒã€‚
+è¿”å›žå€¼ å’Œgdb_set_valä½œç”¨ç›¸åŒã€‚
+
+
+extern int gtp_plugin_var_del(struct gtp_var *var);
+å½“rmmodæ’ä»¶æ¨¡å—çš„æ—¶å€™ï¼Œç”¨è¿™ä¸ªå‡½æ•°åˆ é™¤gtp_plugin_var_addå¢žåŠ çš„TSVã€‚ 
+
+ä¾‹å­
+KGTPç›®å½•é‡Œçš„plugin_example.cæ˜¯KGTP pluginçš„ä¾‹å­ï¼Œå¯ä»¥ç”¨"make P=1"ç›´æŽ¥ç¼–è¯‘å…¶ã€‚å…¶å°†å¢žåŠ å››ä¸ªTSVåˆ°KGTPä¸­ã€‚
+
+$test1 ä»€ä¹ˆä¹Ÿä¸æ”¯æŒã€‚
+$test2 æ”¯æŒè¢«GDBæˆ–è€…tracepoint actionè¯»å†™ã€‚
+$test3 åªæ”¯æŒtracepoint actionå†™ï¼Œå½“è®¾ç½®ä¸€ä¸ªå€¼åˆ°é‡Œé¢çš„æ—¶å€™ï¼Œå…¶å°†æ‰¾åˆ°è¿™ä¸ªå€¼å¯¹åº”çš„ç¬¦å·å¹¶æ‰“å°å‡ºæ¥ã€‚ä¾‹å¦‚ "teval $test3=(int64_t)$rip"ã€‚
+$test4 åªæ”¯æŒtracepoint actionå†™ï¼Œå½“è®¾ç½®å€¼çš„æ—¶å€™å…¶å°†æ‰“å°å½“å‰tracepointçš„åœ°å€çš„ç¬¦å·ã€‚
+å¦‚ä½•ä½¿ç”¨
+å®‰è£…KGTPæ¨¡å— http://code.google.com/p/kgtp/wiki/HOWTOCN#æ‰§è¡Œ
+insmod plugin_example.ko
+è®©GDBè¿žä¸ŠKGTPå¹¶ä½¿ç”¨å…¶ã€‚
+æ–­å¼€GDB. å¦‚æžœ http://code.google.com/p/kgtp/wiki/HOWTOCN#GDBæ–­å¼€çš„æ—¶å€™ä¸è¦åœæ­¢tracepoint ä¸­çš„é€‰é¡¹è®¾ç½®ä¸ºæ‰“å¼€ï¼Œåˆ™è®¾ç½®å…¶ä¸ºå…³é—­ã€‚
+rmmod plugin_example.ko
+è¯· æ³¨æ„ KGTPæ”¯æŒåŠ å…¥å¤šä¸ªæ’ä»¶ã€‚
+
+å¦‚ä½•ä½¿ç”¨æ€§èƒ½è®¡æ•°å™¨
+æ€§èƒ½è®¡æ•°å™¨æ˜¯å¤§éƒ¨åˆ†çŽ°ä»£CPUéƒ½æœ‰çš„ç‰¹æ®Šç¡¬ä»¶å¯„å­˜å™¨ã€‚è¿™äº›å¯„å­˜å™¨å¯¹ä¸€äº›ç¡¬ä»¶äº‹ä»¶è¿›è¡Œè®¡æ•°ï¼šä¾‹å¦‚æŒ‡ä»¤æ‰§è¡Œæ•°é‡ï¼Œcachemissesæ•°é‡ï¼Œåˆ†æ”¯é¢„æµ‹å¤±è´¥æ•°ï¼Œè€Œä¸”è¿™äº›è®¡æ•°ä¸ä¼šè®©åº”ç”¨ç¨‹åºæˆ–è€…å†…æ ¸å˜æ…¢ã€‚å…¶è¿˜å¯ä»¥è®¾ç½®åˆ°è¾¾ä¸€å®šçš„å€¼çš„æ—¶å€™å‘ç”Ÿä¸­æ–­ï¼Œè¿™äº›å°±å¯ä»¥ç”¨æ¥åˆ†æžåœ¨æŸCPUä¸Šæ‰§è¡Œç¨‹åºçš„æ€§èƒ½ã€‚
+Linuxæ€§èƒ½è®¡æ•°å™¨å­ç³»ç»Ÿperf eventå¯ä»¥ç”¨æ¥å–å¾—æ€§èƒ½è®¡æ•°å™¨çš„å€¼ã€‚ä½ å¯ä»¥ç”¨KGTP perf event traceçŠ¶æ€å˜é‡è®¿é—®è¿™äº›å€¼ã€‚
+è¯·è¯»å†…æ ¸ç›®å½•é‡Œçš„tools/perf/design.txtæ–‡ä»¶å–å¾—perf eventçš„æ›´å¤šä¿¡æ¯ã€‚
+
+å®šä¹‰ä¸€ä¸ªperf event traceçŠ¶æ€å˜é‡
+è®¿é—®ä¸€ä¸ªæ€§èƒ½è®¡æ•°å™¨éœ€è¦å®šä¹‰ä¸‹é¢çš„traceçŠ¶æ€å˜é‡ï¼š
+
+"pe_cpu_"+tv_name       å®šä¹‰æ€§èƒ½è®¡æ•°å™¨çš„CPU IDã€‚
+"pe_type_"+tv_name      å®šä¹‰æ€§èƒ½è®¡æ•°å™¨çš„ç±»åž‹ã€‚
+"pe_config_"+tv_name    å®šä¹‰æ€§èƒ½è®¡æ•°å™¨çš„é…ç½®ã€‚
+"pe_en_"+tv_name        å®šä¹‰æ€§èƒ½è®¡æ•°å™¨çš„å¯åŠ¨å¼€å…³ã€‚
+                        é»˜è®¤æƒ…å†µä¸‹æ€§èƒ½è®¡æ•°å™¨æ˜¯å…³é—­çš„ã€‚
+"pe_val_"+tv_name       è®¿é—®è¿™ä¸ªå˜é‡èƒ½å–å¾—æ€§èƒ½è®¡æ•°å™¨çš„å€¼ã€‚
+å®šä¹‰ä¸€ä¸ªper_cpu perf event traceçŠ¶æ€å˜é‡
+å®šä¹‰ä¸€ä¸ªper_cpu perf event traceçŠ¶æ€å˜é‡å’Œhttp://code.google.com/p/kgtp/wiki/HOWTOCN#Per_cpu_traceçŠ¶æ€å˜é‡ä¸€æ ·ã€‚
+
+"p_pe_"+perf_event type+string+CPU_id
+è¯· æ³¨æ„ å¦‚æžœå®šä¹‰ä¸€ä¸ªper_cpu perf event traceçŠ¶æ€å˜é‡ï¼Œå°±ä¸éœ€è¦åœ¨å®šä¹‰cpu id("pe_cpu")å› ä¸ºKGTPå·²ç»å–å¾—äº†CPUçš„IDã€‚
+
+perf eventçš„ç±»åž‹å’Œé…ç½®
+ç±»åž‹å¯ä»¥æ˜¯ï¼š
+
+0       PERF_TYPE_HARDWARE
+1       PERF_TYPE_SOFTWARE
+2       PERF_TYPE_TRACEPOINT
+3       PERF_TYPE_HW_CACHE
+4       PERF_TYPE_RAW
+5       PERF_TYPE_BREAKPOINT
+å¦‚æžœç±»åž‹æ˜¯0(PERF_TYPE_HARDWARE)ï¼Œé…ç½®å¯ä»¥æ˜¯ï¼š
+
+0       PERF_COUNT_HW_CPU_CYCLES
+1       PERF_COUNT_HW_INSTRUCTIONS
+2       PERF_COUNT_HW_CACHE_REFERENCES
+3       PERF_COUNT_HW_CACHE_MISSES
+4       PERF_COUNT_HW_BRANCH_INSTRUCTIONS
+5       PERF_COUNT_HW_BRANCH_MISSES
+6       PERF_COUNT_HW_BUS_CYCLES
+7       PERF_COUNT_HW_STALLED_CYCLES_FRONTEND
+8       PERF_COUNT_HW_STALLED_CYCLES_BACKEND
+
+å¦‚æžœç±»åž‹æ˜¯3(PERF_TYPE_HW_CACHE)ï¼Œé…ç½®è¦åˆ†ä¸º3éƒ¨åˆ†ï¼š ç¬¬ä¸€éƒ¨åˆ†æ˜¯cache idï¼Œå…¶åœ¨è®¾ç½®è¿›é…ç½®çš„æ—¶å€™éœ€è¦ << 0ï¼š
+
+0       PERF_COUNT_HW_CACHE_L1D
+1       PERF_COUNT_HW_CACHE_L1I
+2       PERF_COUNT_HW_CACHE_LL
+3       PERF_COUNT_HW_CACHE_DTLB
+4       PERF_COUNT_HW_CACHE_ITLB
+5       PERF_COUNT_HW_CACHE_BPU
+ç¬¬äºŒéƒ¨åˆ†æ˜¯cache op idï¼Œå…¶åœ¨è®¾ç½®è¿›é…ç½®çš„æ—¶å€™éœ€è¦ << 8ï¼š
+
+0       PERF_COUNT_HW_CACHE_OP_READ
+1       PERF_COUNT_HW_CACHE_OP_WRITE
+2       PERF_COUNT_HW_CACHE_OP_PREFETCH
+ç¬¬ä¸‰éƒ¨åˆ†æ˜¯cache op result idï¼Œå…¶åœ¨è®¾ç½®è¿›é…ç½®çš„æ—¶å€™éœ€è¦ << 16ï¼š
+
+0       PERF_COUNT_HW_CACHE_RESULT_ACCESS
+1       PERF_COUNT_HW_CACHE_RESULT_MISS
+å¦‚æžœä½ æƒ³å–å¾—PERF_COUNT_HW_CACHE_L1I(1), PERF_COUNT_HW_CACHE_OP_WRITE(1) and PERF_COUNT_HW_CACHE_RESULT_MISS(1)ä½ éœ€è¦ä½¿ç”¨ï¼š
+
+(gdb) tvariable $pe_config_cache=1 | (1 << 8) | (1 << 16)
+å†…æ ¸ç›®å½•ä¸­çš„tools/perf/design.txtæ˜¯å…³äºŽperf eventçš„ç±»åž‹å’Œé…ç½®ã€‚
+
+ç”¨$p_pe_enæ‰“å¼€å’Œå…³é—­ä¸€ä¸ªCPUä¸Šæ‰€æœ‰çš„perf event
+æˆ‘è®¤ä¸ºå–å¾—ä¸€æ®µä»£ç çš„æ€§èƒ½è®¡æ•°å™¨ä¿¡æ¯æ¯”è¾ƒå¥½çš„åŠžæ³•æ˜¯åœ¨å‡½æ•°å¼€å¤´æ‰“å¼€è®¡æ•°å™¨åœ¨å‡½æ•°ç»“æŸçš„æ—¶å€™å…³é—­è®¡æ•°å™¨ã€‚ä½ å¯ä»¥ç”¨"pe_en"è®¾ç½®ä»–ä»¬ï¼Œä½†æ˜¯å¦‚æžœä½ æœ‰å¤šä¸ªperf event traceçŠ¶æ€å˜é‡çš„æ—¶å€™ï¼Œè¿™æ ·ä¼šè®©tracepoint actionå¾ˆå¤§ã€‚$p_pe_enå°±æ˜¯å¤„ç†è¿™ç§é—®é¢˜çš„ã€‚ ä½ å¯ä»¥æ‰“å¼€æ‰€æœ‰perf event traceçŠ¶æ€å˜é‡åœ¨å½“å‰CPUä¸Šç”¨ä¸‹é¢çš„actionï¼š
+
+>teval $p_pe_en=1
+è®¾ç½®$p_pe_enä¸º0æ¥å…³é—­ä»–ä»¬ã€‚
+
+>teval $p_pe_en=0
+ç”¨æ¥å¸®åŠ©è®¾ç½®å’Œå–å¾—perf event traceçŠ¶æ€å˜é‡çš„GDBè„šæœ¬
+ä¸‹é¢è¿™ä¸ªGDBè„šæœ¬å®šä¹‰äº†2ä¸ªå‘½ä»¤dpeå’Œspeæ¥å¸®åŠ©å®šä¹‰å’Œæ˜¾ç¤ºperf event traceçŠ¶æ€å˜é‡ã€‚
+ä½ å¯ä»¥æŠŠä»–ä»¬å­˜åœ¨~/.gdbinitæˆ–è€…ä½ è‡ªå·±çš„tracepointè„šæœ¬ä¸­ã€‚äºŽæ˜¯ä½ å°±å¯ä»¥åœ¨GDBä¸­ç›´æŽ¥ä½¿ç”¨è¿™2ä¸ªå‘½ä»¤ã€‚
+
+define dpe
+  if ($argc < 2)
+    printf "Usage: dpe pe_type pe_config [enable]\n"
+  end
+  if ($argc >= 2)
+    eval "tvariable $p_pe_val_%d%d_c",$arg0, $arg1
+    eval "tvariable $p_pe_en_%d%d_c",$arg0, $arg1
+    set $tmp=0
+    while $tmp<$cpu_number
+      eval "tvariable $p_pe_type_%d%d_c%d=%d",$arg0, $arg1, $tmp, $arg0
+      eval "tvariable $p_pe_config_%d%d_c%d=%d",$arg0, $arg1, $tmp, $arg1
+      eval "tvariable $p_pe_val_%d%d_c%d=0",$arg0, $arg1, $tmp
+      if ($argc >= 3)
+        eval "tvariable $p_pe_en_%d%d_c%d=%d",$arg0, $arg1, $tmp, $arg2
+      end
+      set $tmp=$tmp+1
+    end
+  end
+end
+
+document dpe
+Usage: dpe pe_type pe_config [enable]
+end
+
+define spe
+  if ($argc != 2 && $argc != 3)
+    printf "Usage: spe pe_type pe_config [cpu_id]\n"
+  end
+  if ($argc == 2)
+    set $tmp=0
+    while $tmp<$cpu_number
+      eval "printf \"$p_pe_val_%%d%%d_c%%d=%%ld\\n\",$arg0, $arg1, $tmp, $p_pe_val_%d%d_c%d", $arg0, $arg1, $tmp
+      set $tmp=$tmp+1
+    end
+  end
+  if ($argc == 3)
+    eval "printf \"$p_pe_val_%%d%%d_c%%d=%%ld\\n\",$arg0, $arg1, $tmp, $p_pe_val_%d%d_c%d", $arg0, $arg1, $arg2
+  end
+end
+
+document spe
+Usage: spe pe_type pe_config [cpu_id]
+end
+ä¸‹é¢æ˜¯ä¸€ä¸ªå–å¾—å‡½æ•°tcp_v4_rcvæ€§èƒ½è®¡æ•°å™¨çš„ä¾‹å­ï¼š
+
+#è¿žæŽ¥KGTP
+(gdb) target remote /sys/kernel/debug/gtp
+#å®šä¹‰3ä¸ªperf event traceçŠ¶æ€å˜é‡PERF_COUNT_HW_CPU_CYCLESï¼ŒPERF_COUNT_HW_CACHE_MISSESå’ŒPERF_COUNT_HW_BRANCH_MISSESã€‚
+(gdb) dpe 0 0
+(gdb) dpe 0 3
+(gdb) dpe 0 5
+#åœ¨å‡½æ•°å¼€å¤´æ‰“å¼€è¿™ä¸ªCPUçš„æ€§èƒ½å¯„å­˜å™¨
+(gdb) trace tcp_v4_rcv
+(gdb) action
+>teval $p_pe_en=1
+>end
+#$kret è®©æˆ‘ä»¬å¯ä»¥å¤„ç†åˆ°å‡½æ•°tcp_v4_rcvçš„ç»“å°¾ï¼š
+(gdb) trace *(tcp_v4_rcv)
+(gdb) action
+>teval $kret=0
+#å…³é—­è¿™ä¸ªCPUä¸Šçš„æ‰€æœ‰æ€§èƒ½è®¡æ•°å™¨
+>teval $p_pe_en=0
+#è®¿é—®è¿™äº›perf event traceçŠ¶æ€å˜é‡å°†å–å¾—ä»–ä»¬çš„å€¼
+>collect $p_pe_val_00_0
+>collect $p_pe_val_03_0
+>collect $p_pe_val_05_0
+#è®¾ç½®è¿™äº›perf event traceçŠ¶æ€å˜é‡ä¸º0
+>teval $p_pe_val_00_0=0
+>teval $p_pe_val_03_0=0
+>teval $p_pe_val_05_0=0
+>end
+tstart
+#ç­‰ä¸€ä¼šè®©æ¯ä¸ªCPUæ”¶ä¸€äº›TCPåŒ…
+(gdb) tstop
+(gdb) tfind
+(gdb) spe 0 0 $cpu_id
+$p_pe_val_00_2=12676
+(gdb) spe 0 3 $cpu_id
+$p_pe_val_03_2=7
+(gdb) spe 0 5 $cpu_id
+$p_pe_val_05_2=97
--- /dev/null
+++ b/Documentation/gtp/quickstart.txt
@@ -0,0 +1,250 @@
+		Linux Kernel GDB tracepoint module (KGTP) quick start
+		=====================================================
+		By Hui Zhu <teawater@gmail.com>
+		https://code.google.com/p/kgtp/wiki/Quickstart
+		2011-09-12
+
+Table of contents
+-----------------
+Ubuntu
+Fedora
+
+
+
+
+Ubuntu
+------
+
+Install GDB for KGTP
+--------------------
+
+This GDB's filename is different with the current GDB that you are using.
+So please don't worry that it affect current GDB that your are using.
+
+For the Ubuntu 10.04 or later, running the following line at a terminal:
+sudo add-apt-repository ppa:teawater/gdb-$(lsb_release -rs)
+sudo apt-get update
+sudo apt-get install gdb-release
+
+For the Ubuntu older than 10.04, please go to https://code.google.com/p/gdbt/
+get howto install GDB for KGTP from source.
+
+
+
+Install Linux kernel packages that KGTP need
+--------------------------------------------
+
+Please ignore this section if the Linux kernel of your system is built by
+yourself.
+
+Install the Linux kernel debug image
+------------------------------------
+
+Add debug source to the sources list of Ubuntu
+----------------------------------------------
+
+Create an /etc/apt/sources.list.d/ddebs.list by running the following line at
+a terminal:
+echo "deb http://ddebs.ubuntu.com $(lsb_release -cs) main restricted universe multiverse" | \
+sudo tee -a /etc/apt/sources.list.d/ddebs.list
+
+Stable releases (not alphas and betas) require three more lines adding to the
+same file, which is done by the following terminal command:
+echo "deb http://ddebs.ubuntu.com $(lsb_release -cs)-updates main restricted universe multiverse
+deb http://ddebs.ubuntu.com $(lsb_release -cs)-security main restricted universe multiverse
+deb http://ddebs.ubuntu.com $(lsb_release -cs)-proposed main restricted universe multiverse" | \
+sudo tee -a /etc/apt/sources.list.d/ddebs.list
+
+Import the debug symbol archive signing key:
+sudo apt-key adv --keyserver keyserver.ubuntu.com --recv-keys 428D7C01
+
+Then run:
+sudo apt-get update
+
+Get Linux kernel debug image
+----------------------------
+sudo apt-get install linux-image-$(uname -r)-dbgsym
+
+
+Install the Linux kernel headers
+--------------------------------
+
+Please ignore this section if the Linux kernel of your system is built by
+yourself.
+sudo apt-get install linux-headers-generic
+
+
+Install the Linux kernel source
+-------------------------------
+
+Install the source package:
+sudo apt-get install linux-source
+
+Uncompress the source package:
+sudo mkdir -p /build/buildd/
+sudo tar vxjf /usr/src/linux-source-$(uname -r | sed 's/-.*//').tar.bz2 -C /build/buildd/
+sudo mv /build/buildd/linux-source-$(uname -r | sed 's/-.*//') /build/buildd/linux-$(uname -r | sed 's/-.*//')
+
+
+
+Install GCC
+-----------
+
+sudo apt-get install gcc
+
+
+
+Get and build KGTP
+------------------
+
+Install subversion:
+sudo apt-get install subversion
+
+Get the source of KGTP with subversion and put it to directory "kgtp":
+svn checkout https://kgtp.googlecode.com/svn/trunk kgtp
+
+Build KGTP:
+cd kgtp
+make
+
+
+
+Use KGTP
+--------
+
+Mount the sysfs and debugfs:
+sudo mount -t sysfs none /sys/
+sudo mount -t debugfs none /sys/kernel/debug/
+
+Insert the KGTP module to the current Linux Kernel:
+cd kgtp
+sudo insmod gtp.ko
+
+Use GDB connect to KGTP:
+sudo gdb-release /usr/lib/debug/boot/vmlinux-$(uname -r)
+(gdb) target remote /sys/kernel/debug/gtp
+
+Do a very simple trace:
+(gdb) trace vfs_readdir
+Tracepoint 1 at 0xc02289f0: file /build/buildd/linux-2.6.35/fs/readdir.c, line 23.
+(gdb) actions
+Enter actions for tracepoint 1, one per line.
+End with a line saying just "end".
+>collect $reg
+>end
+(gdb) tstart
+(gdb) shell ls
+vmlinux-2.6.35-30-generic
+(gdb) tstop
+(gdb) tfind
+Found trace frame 0, tracepoint 1
+#0  vfs_readdir (file=0x0, filler=0x163d8ae3, buf=0x18c0) at readdir.c:23
+23      {
+
+
+
+End
+---
+
+Now, you can begin to rock and roll your Linux kernel with KGTP and GDB.
+Please go to see gtp.txt to get more message about howto use KGTP.
+
+
+
+
+Fedora
+------
+
+Install GDB for KGTP
+--------------------
+
+Please go to https://code.google.com/p/gdbt/ get howto install GDB for KGTP
+from source.
+
+
+
+Install Linux kernel packages that KGTP need
+--------------------------------------------
+
+Please ignore this section if the Linux kernel of your system is built
+by yourself.
+
+
+Install the Linux kernel debug image
+------------------------------------
+
+sudo yum --enablerepo=fedora-debuginfo install kernel-debuginfo
+
+
+Install the Linux kernel devel package
+--------------------------------------
+
+sudo yum install kernel-devel-$(uname -r)
+
+
+
+Install GCC
+-----------
+
+sudo yum install gcc
+
+
+
+Get and build KGTP
+------------------
+
+Install subversion:
+sudo yum install subversion
+
+Get the source of KGTP with subversion and put it to directory "kgtp":
+svn checkout https://kgtp.googlecode.com/svn/trunk kgtp
+
+Build KGTP:
+cd kgtp
+make
+
+
+
+Use KGTP
+--------
+
+Mount the sysfs and debug fs:
+sudo mount -t sysfs none /sys/
+sudo mount -t debugfs none /sys/kernel/debug/
+
+Insert the KGTP module to the current Linux Kernel:
+cd kgtp
+sudo insmod gtp.ko
+
+Use GDB connect to KGTP:
+sudo gdb-release /usr/lib/debug/lib/modules/$(uname -r)/vmlinux
+(gdb) target remote /sys/kernel/debug/gtp
+
+Do a very simple trace:
+(gdb) trace vfs_readdir
+Tracepoint 1 at 0xffffffff8110ec9b: file fs/readdir.c, line 23.
+(gdb) actions
+Enter actions for tracepoint 1, one per line.
+End with a line saying just "end".
+>collect $reg
+>end
+(gdb) tstart
+(gdb) shell ls
+co.patch                  getframe      getmod.c   gtp.mod.c  gtp.txt         perf_event.c
+dkms.conf                 getframe.c    getmod.py  gtp.mod.o  Makefile        ring_buffer.c
+dkms_others_install.sh    getgtprsp.pl  gtp.c      gtp.o      modules.order   ring_buffer.h
+dkms_others_uninstall.sh  getmod        gtp.ko     gtp.patch  Module.symvers
+(gdb) tstop
+(gdb) tfind
+Found trace frame 0, tracepoint 1
+#0  vfs_readdir (file=0xffff880019d3df00, filler=0xffffffff8110eb16 <filldir>, buf=0xffff880003b39f38)
+    at fs/readdir.c:23
+23      {
+
+
+
+End
+---
+
+Now, you can begin to rock and roll your Linux kernel with KGTP and GDB.
+Please go to HOWTO to get more message about howto use KGTP.
--- a/arch/arm/mm/flush.c
+++ b/arch/arm/mm/flush.c
@@ -343,3 +343,4 @@ void __flush_anon_page(struct vm_area_st
 	 */
 	__cpuc_flush_dcache_area(page_address(page), PAGE_SIZE);
 }
+EXPORT_SYMBOL(__flush_anon_page);
--- a/include/linux/perf_event.h
+++ b/include/linux/perf_event.h
@@ -1176,5 +1176,13 @@ do {								\
 	register_cpu_notifier(&fn##_nb);			\
 } while (0)
 
+#ifdef CONFIG_PERF_EVENTS
+extern void perf_event_set(struct perf_event *event, u64 val);
+extern void local_perf_event_enable(void *info);
+extern void local_perf_event_disable(void *info);
+#endif
+
+#define KGTP_API_VERSION	20120917
+
 #endif /* __KERNEL__ */
 #endif /* _LINUX_PERF_EVENT_H */
--- a/kernel/perf_event.c
+++ b/kernel/perf_event.c
@@ -730,6 +730,7 @@ static void __perf_event_disable(void *i
 
 	raw_spin_unlock(&ctx->lock);
 }
+EXPORT_SYMBOL_GPL(perf_event_disable);
 
 /*
  * Disable a event.
@@ -1215,6 +1216,7 @@ retry:
 out:
 	raw_spin_unlock_irq(&ctx->lock);
 }
+EXPORT_SYMBOL_GPL(perf_event_enable);
 
 static int perf_event_refresh(struct perf_event *event, int refresh)
 {
@@ -2588,6 +2590,24 @@ static void perf_event_reset(struct perf
 	perf_event_update_userpage(event);
 }
 
+#include <linux/version.h>
+#ifndef RHEL_RELEASE_VERSION
+#define RHEL_RELEASE_VERSION(a,b)	(((a) << 8) + (b))
+#define RHEL_RELEASE_CODE		0
+#endif
+void perf_event_set(struct perf_event *event, u64 val)
+{
+	(void)perf_event_read(event);
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2,6,35)) \
+    || (RHEL_RELEASE_CODE >= RHEL_RELEASE_VERSION(6,1))
+	local64_set(&event->count, val);
+#else
+	atomic64_set(&event->count, val);
+#endif
+	perf_event_update_userpage(event);
+}
+EXPORT_SYMBOL_GPL(perf_event_set);
+
 /*
  * Holding the top-level event's child_mutex means that any
  * descendant process that has inherited this event will block
@@ -6732,3 +6752,15 @@ unlock:
 	return ret;
 }
 device_initcall(perf_event_sysfs_init);
+
+void local_perf_event_enable(void *info)
+{
+	__perf_event_enable(info);
+}
+EXPORT_SYMBOL_GPL(local_perf_event_enable);
+
+void local_perf_event_disable(void *info)
+{
+	return __perf_event_disable(info);
+}
+EXPORT_SYMBOL_GPL(local_perf_event_disable);
--- a/lib/Kconfig.debug
+++ b/lib/Kconfig.debug
@@ -1231,6 +1231,16 @@ config ASYNC_RAID6_TEST
 
 	  If unsure, say N.
 
+config GTP
+	tristate "GDB tracepoint support"
+	depends on X86 || ARM || MIPS
+	select KPROBES
+	select DEBUG_FS
+	---help---
+	  Supply GDB tracepoint interface in /sys/kernel/debug/gtp.
+	  See Documentation/trace/gtp.txt or
+	  https://code.google.com/p/kgtp/wiki/HOWTO for more info.
+
 source "samples/Kconfig"
 
 source "lib/Kconfig.kgdb"
--- a/lib/Makefile
+++ b/lib/Makefile
@@ -110,6 +110,8 @@ obj-$(CONFIG_ATOMIC64_SELFTEST) += atomi
 
 obj-$(CONFIG_AVERAGE) += average.o
 
+obj-$(CONFIG_GTP) += gtp.o
+
 hostprogs-y	:= gen_crc32table
 clean-files	:= crc32table.h
 
--- /dev/null
+++ b/lib/gtp.c
@@ -0,0 +1,13045 @@
+/*
+ * Kernel GDB tracepoint module.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ *
+ * Copyright(C) KGTP team (https://code.google.com/p/kgtp/), 2010-2013
+ *
+ */
+
+/* If "* 10" means that this is not a release version.  */
+#define GTP_VERSION			(20130915)
+
+#include <linux/version.h>
+#ifndef RHEL_RELEASE_VERSION
+#define RHEL_RELEASE_VERSION(a,b)	(((a) << 8) + (b))
+#define RHEL_RELEASE_CODE		0
+#endif
+
+/* Sepcial config ------------------------------------------------ */
+#define GTP_RB
+
+#ifdef GTP_FRAME_SIMPLE
+/* This is a debug option.
+   This define is for simple frame alloc record, then we can get how many
+   memory are weste by FRAME_ALIGN. */
+/* #define FRAME_ALLOC_RECORD */
+#undef GTP_RB
+#endif
+
+#ifdef GTP_FTRACE_RING_BUFFER
+#undef GTP_RB
+#endif
+
+/* If define USE_PROC, KGTP will use ProcFS instead DebugFS.  */
+#ifndef GTP_NO_AUTO_BUILD
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,11))
+#define USE_PROC
+#endif
+#endif
+#ifndef USE_PROC
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,11))
+#warning If got some build error about debugfs, you can use "USE_PROC=1" handle it.
+#endif
+#endif
+
+#ifdef GTP_FTRACE_RING_BUFFER
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,30))
+#warning If got some build error about ring buffer, you can use "FRAME_SIMPLE=1" handle it.
+#endif
+#endif
+
+/* If define GTP_CLOCK_CYCLE, $clock will return rdtscll.  */
+#ifndef GTP_NO_AUTO_BUILD
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,24))
+#define GTP_CLOCK_CYCLE
+#endif
+#endif
+#ifndef GTP_CLOCK_CYCLE
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,24))
+#warning If got some build error about cpu_clock or local_clock, you can use "CLOCK_CYCLE=1" handle it.
+#endif
+#endif
+
+#ifdef CONFIG_LOCKDEP
+#warning Current kernel open the runtime locking correctness validator (CONFIG_LOCKDEP) that will make KGTP trace functions about locks get deadlock.  Please DO NOT trace function about locks.
+#endif
+
+#ifdef GTP_FTRACE_RING_BUFFER
+#ifndef CONFIG_RING_BUFFER
+#define CONFIG_RING_BUFFER
+#include "ring_buffer.h"
+#include "ring_buffer.c"
+#define GTP_SELF_RING_BUFFER
+#warning Use the ring buffer inside KGTP.
+#endif
+#endif
+/* Sepcial config ------------------------------------------------ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/uaccess.h>
+#include <linux/vmalloc.h>
+#include <linux/poll.h>
+#include <linux/kprobes.h>
+#include <linux/interrupt.h>
+#include <linux/proc_fs.h>
+#include <linux/debugfs.h>
+#include <linux/highmem.h>
+#include <linux/pagemap.h>
+#include <linux/mm.h>
+#include <linux/slab.h>
+#include <linux/ctype.h>
+#include <asm/atomic.h>
+#ifdef CONFIG_X86
+#include <asm/debugreg.h>
+#endif
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,22))
+#include <linux/kdebug.h>
+#else
+#include <asm/kdebug.h>
+#endif
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3,0,0))
+#include <linux/hw_breakpoint.h>
+#endif
+#include "gtp.h"
+
+#ifdef GTP_FTRACE_RING_BUFFER
+#ifndef GTP_SELF_RING_BUFFER
+#include <linux/ring_buffer.h>
+#endif
+#endif
+#ifdef CONFIG_PERF_EVENTS
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,33)) \
+    && (RHEL_RELEASE_CODE < RHEL_RELEASE_VERSION(6,1))
+#warning "Current Kernel is too old.  Function of performance counters is not available."
+#else
+#include <linux/perf_event.h>
+#define GTP_PERF_EVENTS
+#endif
+#else
+#warning "Current Kernel doesn't open CONFIG_PERF_EVENTS.  Function of performance counters is not available."
+#endif
+
+/* Handle KGTP_API_VERSION for the special kernel that include KGTP_API.  */
+#ifdef KGTP_API_VERSION
+#define KGTP_API_VERSION_LOCAL	KGTP_API_VERSION
+#else
+#define KGTP_API_VERSION_LOCAL	0
+#endif
+
+#ifndef __percpu
+#define __percpu
+#endif
+
+#ifndef this_cpu_ptr
+#define this_cpu_ptr(v)	per_cpu_ptr(v, smp_processor_id())
+#endif
+
+#define KERN_NULL
+
+/* check ---------------------------------------------------------- */
+#ifndef CONFIG_KPROBES
+#error "Linux Kernel doesn't support KPROBES.  Please open it in 'General setup->Kprobes'."
+#endif
+
+#ifdef USE_PROC
+#ifndef CONFIG_PROC_FS
+#error "Linux Kernel doesn't support procfs."
+#endif
+#else
+#ifndef CONFIG_DEBUG_FS
+#error "Linux Kernel doesn't support debugfs."
+#endif
+#endif
+
+#if !defined CONFIG_X86 && !defined CONFIG_MIPS && !defined CONFIG_ARM
+#error "KGTP support X86_32, X86_64, MIPS and ARM."
+#endif
+/* ---------------------------------------------------------------- */
+
+/* Following part is to support old Linux kernel ------------------ */
+#ifndef DEFINE_SEMAPHORE
+#define DEFINE_SEMAPHORE(name)	DECLARE_MUTEX(name)
+#endif
+
+#ifndef list_first_entry
+#define list_first_entry(ptr, type, member) \
+	list_entry((ptr)->next, type, member)
+#endif
+
+/* ---------------------------------------------------------------- */
+
+#ifdef GTPDEBUG
+#define GTP_DEBUG		KERN_WARNING
+#endif
+
+/* #define GTP_DEBUG_V */
+
+#define GTP_RW_MAX		16384
+#define GTP_RW_BUFP_MAX		(GTP_RW_MAX - 4 - gtp_rw_size)
+
+#define FID_TYPE		unsigned int
+#define FID_SIZE		sizeof(FID_TYPE)
+#define FID(x)			(*((FID_TYPE *)x))
+enum {
+	FID_HEAD = 0,
+	FID_REG,
+	FID_MEM,
+	FID_VAR,
+	FID_END,
+	FID_PAGE_BEGIN,
+	FID_PAGE_END,
+};
+
+/* GTP_FRAME_SIZE must align with FRAME_ALIGN_SIZE if use GTP_FRAME_SIMPLE.  */
+#define GTP_FRAME_SIZE		5242880
+#if defined(GTP_FRAME_SIMPLE) || defined(GTP_RB)
+#define FRAME_ALIGN_SIZE	sizeof(unsigned int)
+#define FRAME_ALIGN(x)		((x + FRAME_ALIGN_SIZE - 1) \
+				 & (~(FRAME_ALIGN_SIZE - 1)))
+#endif
+#ifdef GTP_FRAME_SIMPLE
+#define GTP_FRAME_HEAD_SIZE	(FID_SIZE + sizeof(char *) + sizeof(ULONGEST))
+#define GTP_FRAME_REG_SIZE	(FID_SIZE + sizeof(char *) \
+				 + sizeof(struct pt_regs))
+#define GTP_FRAME_MEM_SIZE	(FID_SIZE + sizeof(char *) \
+				 + sizeof(struct gtp_frame_mem))
+#define GTP_FRAME_VAR_SIZE	(FID_SIZE + sizeof(char *) \
+				 + sizeof(struct gtp_frame_var))
+#endif
+#ifdef GTP_RB
+/* The frame head size: FID_HEAD + count id + frame number + pointer to prev frem */
+#define GTP_FRAME_HEAD_SIZE	(FID_SIZE + sizeof(u64) + sizeof(ULONGEST) + sizeof(void *))
+/* The frame head size: FID_PAGE_BEGIN + count id */
+#define GTP_FRAME_PAGE_BEGIN_SIZE	(FID_SIZE + sizeof(u64))
+#endif
+#ifdef GTP_FTRACE_RING_BUFFER
+#define GTP_FRAME_HEAD_SIZE	(FID_SIZE + sizeof(ULONGEST))
+#endif
+#if defined(GTP_FTRACE_RING_BUFFER) || defined(GTP_RB)
+#define GTP_FRAME_REG_SIZE	(FID_SIZE + sizeof(struct pt_regs))
+#define GTP_FRAME_MEM_SIZE	(FID_SIZE + sizeof(struct gtp_frame_mem))
+#define GTP_FRAME_VAR_SIZE	(FID_SIZE + sizeof(struct gtp_frame_var))
+#endif
+
+#define INT2CHAR(h)		((h) > 9 ? (h) + 'a' - 10 : (h) + '0')
+
+enum {
+	op_check_add = 0xe0,
+	op_check_sub,
+	op_check_mul,
+	op_check_div_signed,
+	op_check_div_unsigned,
+	op_check_rem_signed,
+	op_check_rem_unsigned,
+	op_check_lsh,
+	op_check_rsh_signed,
+	op_check_rsh_unsigned,
+	op_check_trace,
+	op_check_bit_and,
+	op_check_bit_or,
+	op_check_bit_xor,
+	op_check_equal,
+	op_check_less_signed,
+	op_check_less_unsigned,
+	op_check_pop,
+	op_check_swap,
+	op_check_if_goto,
+	op_check_printf,	/* XXX: still not used.  */
+
+	op_trace_printk = 0xfd,
+	op_trace_quick_printk,
+	op_tracev_printk,
+};
+
+struct action_agent_exp {
+	unsigned int	size;
+	uint8_t		*buf;
+	int		need_var_lock;
+};
+
+struct action_m {
+	int		regnum;
+	CORE_ADDR	offset;
+	size_t		size;
+};
+
+struct action {
+	struct list_head	node;
+	unsigned char		type;
+	union {
+		ULONGEST		reg_mask;
+		struct action_agent_exp	exp;
+		struct action_m		m;
+	} u;
+};
+
+struct gtpsrc {
+	struct gtpsrc	*next;
+	char		*src;
+};
+
+enum gtp_stop_type {
+	gtp_stop_normal = 0,
+	gtp_stop_frame_full,
+	gtp_stop_efault,
+	gtp_stop_access_wrong_reg,
+	gtp_stop_agent_expr_code_error,
+	gtp_stop_agent_expr_stack_overflow,
+};
+
+/* See $current.  */
+#define GTP_ENTRY_FLAGS_CURRENT_TASK	1
+/* This gtp entry is registered inside the system.  */
+#define GTP_ENTRY_FLAGS_REG		2
+/* See $no_self_trace.  */
+#define GTP_ENTRY_FLAGS_SELF_TRACE	4
+/* This gtp entry has passcount.  */
+#define GTP_ENTRY_FLAGS_HAVE_PASS	8
+/* See $printk_level.  */
+#define GTP_ENTRY_FLAGS_HAVE_PRINTK	16
+/* See $kret.  */
+#define GTP_ENTRY_FLAGS_IS_KRETPROBE	32
+
+enum gtp_entry_type {
+	/* Normal tracepoint.  */
+	gtp_entry_kprobe = 0,
+
+	/* Watch.  */
+	gtp_entry_watch_static,
+	gtp_entry_watch_dynamic,
+};
+
+enum gtp_watch_type {
+	gtp_watch_exec		= 0,
+	gtp_watch_write		= 1,
+	gtp_watch_read_write	= 2,
+};
+
+struct gtp_entry {
+	union gtp_entry_u {
+		/* For gtp_entry_kprobe.  */
+		struct gtp_kp {
+			struct kretprobe	kpret;
+			struct tasklet_struct	stop_tasklet;
+			struct work_struct	stop_work;
+		} kp;
+
+		/* For gtp_entry_watch_static and gtp_entry_watch_dynamic.  */
+		struct {
+			int type;
+			int size;
+		} watch;
+	} u;
+	unsigned long		flags;
+	enum gtp_entry_type	type;
+	ULONGEST		num;
+	ULONGEST		addr;
+
+	/* The actions that set $current help tracepoint get right regs.  */
+	struct action		*get_regs;
+	/* The actions for the condition.  */
+	struct action		*cond;
+	struct list_head	action_list;
+	int			step;
+	struct list_head	step_action_list;
+
+	atomic_t		current_pass;
+	struct gtpsrc		*printk_str;
+
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,30))
+	/* This is to enable and disable an tracepoint.  */
+	struct tasklet_struct	enable_tasklet;
+	struct work_struct	enable_work;
+	struct tasklet_struct	disable_tasklet;
+	struct work_struct	disable_work;
+#endif
+	enum gtp_stop_type	reason;
+
+	struct gtp_entry	*next;
+
+	int			disable;
+	ULONGEST		pass;
+	struct gtpsrc		*src;
+	/* Sometime, it will not same with action
+	   because action will be deleted.  */
+	struct gtpsrc		*action_cmd;
+};
+
+struct gtp_frame_mem {
+	CORE_ADDR	addr;
+	size_t		size;
+};
+
+struct gtp_frame_var {
+	unsigned int	num;
+	int64_t		val;
+};
+
+struct gtpro_entry {
+	struct gtpro_entry	*next;
+	CORE_ADDR		start;
+	CORE_ADDR		end;
+};
+
+static pid_t			gtp_gtp_pid;
+static unsigned int		gtp_gtp_pid_count;
+static pid_t			gtp_gtpframe_pid;
+static unsigned int		gtp_gtpframe_pid_count;
+#if defined(GTP_FTRACE_RING_BUFFER) || defined(GTP_RB)
+static pid_t			gtp_gtpframe_pipe_pid;
+#endif
+
+static struct gtp_entry		*gtp_list;
+static struct gtp_entry		*current_gtp;
+static struct gtpsrc		*current_gtp_action_cmd;
+static struct gtpsrc		*current_gtp_src;
+
+static struct workqueue_struct	*gtp_wq;
+
+static int			gtp_read_ack;
+static char			*gtp_rw_buf;
+static char			*gtp_rw_bufp;
+static size_t			gtp_rw_size;
+
+static int			gtp_start;
+
+static int			gtp_disconnected_tracing;
+static int			gtp_circular;
+#if defined(GTP_FTRACE_RING_BUFFER)			\
+    && (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,39))	\
+    && !defined(GTP_SELF_RING_BUFFER)
+static int			gtp_circular_is_changed;
+#endif
+
+static int			gtp_cpu_number;
+
+/* Current number in the frame.  */
+static int			gtp_frame_current_num;
+/* Current tracepoint id.  */
+static ULONGEST			gtp_frame_current_tpe;
+static atomic_t			gtp_frame_create;
+static char			*gtp_frame_file;
+static size_t			gtp_frame_file_size;
+static DECLARE_WAIT_QUEUE_HEAD(gtpframe_wq);
+#ifdef GTP_FRAME_SIMPLE
+static DEFINE_SPINLOCK(gtp_frame_lock);
+static char			*gtp_frame;
+static char			*gtp_frame_r_start;
+static char			*gtp_frame_w_start;
+static char			*gtp_frame_end;
+static int			gtp_frame_is_circular;
+static char			*gtp_frame_current;
+#endif
+#ifdef GTP_FTRACE_RING_BUFFER
+static struct ring_buffer	*gtp_frame;
+static struct ring_buffer_iter	*gtp_frame_iter[NR_CPUS];
+static int			gtp_frame_current_cpu;
+static u64			gtp_frame_current_clock;
+#endif
+
+#if defined(GTP_FTRACE_RING_BUFFER) || defined(GTP_RB)
+static DECLARE_WAIT_QUEUE_HEAD(gtpframe_pipe_wq);
+static atomic_t			gtpframe_pipe_wq_v;
+static struct tasklet_struct	gtpframe_pipe_wq_tasklet;
+#endif
+
+static struct gtpro_entry	*gtpro_list;
+
+#define GTP_PRINTF_MAX		256
+static DEFINE_PER_CPU(char[GTP_PRINTF_MAX], gtp_printf);
+
+#ifdef CONFIG_X86
+static DEFINE_PER_CPU(u64, rdtsc_current);
+static DEFINE_PER_CPU(u64, rdtsc_offset);
+#endif
+static DEFINE_PER_CPU(u64, local_clock_current);
+static DEFINE_PER_CPU(u64, local_clock_offset);
+
+static uint64_t			gtp_start_last_errno;
+static int			gtp_start_ignore_error;
+
+static int			gtp_pipe_trace;
+
+static int			gtp_bt_size;
+
+static int			gtp_noack_mode;
+
+static pid_t			gtp_current_pid;
+
+#ifdef CONFIG_X86
+/* Following part is for while-stepping.  */
+struct gtp_step_s {
+	spinlock_t		lock;
+	int			step;
+	int			irq_need_open;
+	struct gtp_entry	*tpe;
+};
+static DEFINE_PER_CPU(struct gtp_step_s, gtp_step);
+#endif
+
+#ifdef CONFIG_X86
+static int	gtp_have_watch_tracepoint;
+static int	gtp_have_step;
+#endif
+
+#ifdef CONFIG_X86
+/* Following part is for watch tracepoint.  */
+/* This part is X86 special.  */
+#define HWB_NUM			4
+
+static unsigned long		gtp_hwb_drx[HWB_NUM];
+static unsigned long		gtp_hwb_dr7;
+
+#define GTP_HWB_DR7_DEF		(0x400UL)
+#define GTP_HWB_DR6_MASK	(0xe00fUL)
+
+/* This part is for all the arch.  */
+struct gtp_hwb_s {
+	struct list_head	node;
+
+	/* This is the number of this hardware breakpoint.  */
+	int			num;
+
+	/* This is the address, size and type of this
+	   hardware breakpoint.  */
+	CORE_ADDR		addr;
+	int			size;
+	int			type;
+
+	/* The previous of the address that this watch tracepoint
+	   watch on.  */
+	int64_t			prev_val;
+
+	/* This is the num and address that setup this hardware
+	   breakpoints.
+	   For the static watch, this is the num and address of this
+	   tracepoint.
+	   For the dynamic watch, this is the num and address of
+	   the tracepoint that call $watch_start.  */
+	ULONGEST		trace_num;
+	ULONGEST		trace_addr;
+
+	unsigned int		count;
+
+	/* Point to the watchpoint struct.
+	   If NULL, this hardware breakpoint is not used.  */
+	struct gtp_entry	*watch;
+};
+
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3,0,0))
+static struct hw_breakpoint {
+	int			num;
+	struct perf_event	* __percpu *pev;
+} breakinfo[HWB_NUM];
+#endif
+
+static struct gtp_hwb_s	gtp_hwb[HWB_NUM];
+
+static LIST_HEAD(gtp_hwb_used_list);
+static LIST_HEAD(gtp_hwb_unused_list);
+
+static DEFINE_RWLOCK(gtp_hwb_lock);
+
+static unsigned int	gtp_hwb_sync_count;
+static DEFINE_PER_CPU(unsigned int, gtp_hwb_sync_count_local);
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,27))
+static DEFINE_PER_CPU(struct cpumask, gtp_hwb_sync_cpu_mask);
+#endif
+
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,25))
+#define gtp_get_debugreg(val, reg)	get_debugreg(val, reg)
+#define gtp_set_debugreg(val, reg)	set_debugreg(val, reg)
+#else
+#define gtp_get_debugreg(val, reg)		\
+	do {					\
+		switch(reg) {			\
+		case 0:				\
+			get_debugreg(val, 0);	\
+			break;			\
+		case 1:				\
+			get_debugreg(val, 1);	\
+			break;			\
+		case 2:				\
+			get_debugreg(val, 2);	\
+			break;			\
+		case 3:				\
+			get_debugreg(val, 3);	\
+			break;			\
+		}				\
+	} while (0)
+
+static void
+gtp_set_debugreg(unsigned long val, int reg)
+{
+	switch(reg) {
+	case 0:
+		gtp_set_debugreg(val, 0);
+		break;
+	case 1:
+		gtp_set_debugreg(val, 1);
+		break;
+	case 2:
+		gtp_set_debugreg(val, 2);
+		break;
+	case 3:
+		gtp_set_debugreg(val, 3);
+		break;
+	}
+}
+#endif
+
+static void
+gtp_hwb_stop(void *data)
+{
+	read_lock(&gtp_hwb_lock);
+	__get_cpu_var(gtp_hwb_sync_count_local) = gtp_hwb_sync_count;
+	gtp_set_debugreg(0UL, 0);
+	gtp_set_debugreg(0UL, 1);
+	gtp_set_debugreg(0UL, 2);
+	gtp_set_debugreg(0UL, 3);
+	gtp_set_debugreg(GTP_HWB_DR7_DEF, 7);
+	read_unlock(&gtp_hwb_lock);
+}
+
+static void
+gtp_hwb_sync_local(void)
+{
+	__get_cpu_var(gtp_hwb_sync_count_local) = gtp_hwb_sync_count;
+	gtp_set_debugreg(gtp_hwb_drx[0], 0);
+	gtp_set_debugreg(gtp_hwb_drx[1], 1);
+	gtp_set_debugreg(gtp_hwb_drx[2], 2);
+	gtp_set_debugreg(gtp_hwb_drx[3], 3);
+	gtp_set_debugreg(gtp_hwb_dr7, 7);
+}
+
+static void
+gtp_hwb_sync(void *data)
+{
+	gtp_hwb_sync_local();
+}
+
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,27))
+static int
+gtp_ipi_handler(struct kprobe *p, struct pt_regs *regs)
+{
+	read_lock(&gtp_hwb_lock);
+
+	if (__get_cpu_var(gtp_hwb_sync_count_local) != gtp_hwb_sync_count)
+		gtp_hwb_sync_local();
+
+	read_unlock(&gtp_hwb_lock);
+
+	return 0;
+}
+#endif
+
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,27))
+static struct kprobe gtp_ipi_kp;
+#endif
+#endif
+
+static char *
+string2hex(char *pkg, char *out)
+{
+	char	*ret = out;
+
+	while (pkg[0]) {
+		sprintf(out, "%02x", pkg[0]);
+		pkg++;
+		out += 2;
+	}
+	out[0] = '\0';
+
+	return ret;
+}
+
+/* Strdup begin.  If end is not NULL, it point to the end of this dup.  */
+
+static char *
+gtp_strdup(char *begin, char *end)
+{
+	int	len;
+	char	*ret;
+
+	if (end)
+		len = end - begin;
+	else
+		len = strlen(begin);
+
+	ret = kmalloc(len + 1, GFP_KERNEL);
+	if (ret == NULL)
+		return NULL;
+
+	strncpy(ret, begin, len);
+	ret[len] = '\0';
+
+	return ret;
+}
+
+/* Following part is for GTP_LOCAL_CLOCK.  */
+
+#define GTP_LOCAL_CLOCK	gtp_local_clock()
+#ifdef GTP_CLOCK_CYCLE
+static unsigned long long
+gtp_local_clock(void)
+{
+#ifdef CONFIG_X86
+	unsigned long long a;
+	rdtscll(a);
+	return a;
+#else
+#error "This ARCH cannot get cycle."
+#endif
+}
+#else
+static unsigned long long
+gtp_local_clock(void)
+{
+#ifdef CONFIG_HAVE_UNSTABLE_SCHED_CLOCK
+	unsigned long flags;
+	unsigned int cpu;
+
+	local_irq_save(flags);
+	cpu = smp_processor_id();
+	local_irq_restore(flags);
+
+	return cpu_clock(cpu);
+#else
+	return cpu_clock(0);
+#endif	/* CONFIG_HAVE_UNSTABLE_SCHED_CLOCK */
+}
+#endif
+
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,26))
+static long
+probe_kernel_read(void *dst, void *src, size_t size)
+{
+	long ret;
+	mm_segment_t old_fs = get_fs();
+
+	set_fs(KERNEL_DS);
+
+	/* pagefault_disable();*/
+	inc_preempt_count();
+	barrier();
+
+	ret = __copy_from_user_inatomic(dst,
+			(__force const void __user *)src, size);
+
+	/* pagefault_enable(); */
+	barrier();
+	dec_preempt_count();
+	barrier();
+	preempt_check_resched();
+
+	set_fs(old_fs);
+
+	return ret ? -EFAULT : 0;
+}
+#endif
+
+#ifdef GTP_RB
+#include "gtp_rb.c"
+#endif
+
+/* Following part is for TSV.  */
+
+/* getgtprsp.pl need the ID of TSV.  */
+
+enum {
+	GTP_VAR_VERSION_ID			= 1,
+	GTP_VAR_CPU_ID				= 2,
+	GTP_VAR_CURRENT_TASK_ID			= 3,
+	GTP_VAR_CURRENT_THREAD_INFO_ID		= 4,
+	GTP_VAR_CLOCK_ID			= 5,
+	GTP_VAR_COOKED_CLOCK_ID			= 6,
+#ifdef CONFIG_X86
+	GTP_VAR_RDTSC_ID			= 7,
+	GTP_VAR_COOKED_RDTSC_ID			= 8,
+#endif
+#ifdef GTP_RB
+	GTP_VAR_GTP_RB_DISCARD_PAGE_NUMBER	= 9,
+#endif
+	GTP_VAR_PRINTK_TMP_ID			= 10,
+	GTP_VAR_PRINTK_LEVEL_ID			= 11,
+	GTP_VAR_PRINTK_FORMAT_ID		= 12,
+	GTP_VAR_DUMP_STACK_ID			= 13,
+	GTP_VAR_SELF_TRACE_ID			= 14,
+	GTP_VAR_CPU_NUMBER_ID			= 15,
+	GTP_VAR_PC_PE_EN_ID			= 16,
+	GTP_VAR_KRET_ID				= 17,
+	GTP_VAR_XTIME_SEC_ID			= 18,
+	GTP_VAR_XTIME_NSEC_ID			= 19,
+	GTP_VAR_IGNORE_ERROR_ID			= 20,
+	GTP_VAR_LAST_ERRNO_ID			= 21,
+	GTP_VAR_HARDIRQ_COUNT_ID		= 22,
+	GTP_VAR_SOFTIRQ_COUNT_ID		= 23,
+	GTP_VAR_IRQ_COUNT_ID			= 24,
+	GTP_VAR_PIPE_TRACE_ID			= 25,
+	GTP_VAR_CURRENT_TASK_PID_ID		= 26,
+	GTP_VAR_CURRENT_TASK_USER_ID		= 27,
+	GTP_VAR_CURRENT_ID			= 28,
+	GTP_VAR_BT_ID				= 29,
+
+	GTP_VAR_ENABLE_ID			= 30,
+	GTP_VAR_DISABLE_ID			= 31,
+
+	GTP_WATCH_STATIC_ID			= 32,
+	GTP_WATCH_TYPE_ID			= 33,
+	GTP_WATCH_SIZE_ID			= 34,
+	GTP_WATCH_SET_ID_ID			= 35,
+	GTP_WATCH_SET_ADDR_ID			= 36,
+	GTP_WATCH_START_ID			= 37,
+	GTP_WATCH_STOP_ID			= 38,
+	GTP_WATCH_TRACE_NUM_ID			= 39,
+	GTP_WATCH_TRACE_ADDR_ID			= 40,
+	GTP_WATCH_ADDR_ID			= 41,
+	GTP_WATCH_VAL_ID			= 42,
+	GTP_WATCH_PREV_VAL_ID			= 46,
+	GTP_WATCH_COUNT_ID			= 43,
+
+	GTP_STEP_COUNT_ID			= 44,
+	GTP_STEP_ID_ID				= 45,
+
+	GTP_VAR_SPECIAL_MIN			= GTP_VAR_VERSION_ID,
+	GTP_VAR_SPECIAL_MAX			= GTP_WATCH_PREV_VAL_ID,
+};
+
+enum pe_tv_id {
+	pe_tv_unknown = 0,
+	pe_tv_cpu,
+	pe_tv_type,
+	pe_tv_config,
+	pe_tv_en,
+	pe_tv_val,
+	pe_tv_enabled,
+	pe_tv_running,
+};
+
+enum {
+	gtp_var_normal = 0,
+#ifdef GTP_PERF_EVENTS
+	gtp_var_perf_event,
+	gtp_var_perf_event_per_cpu,
+#endif
+	gtp_var_per_cpu,
+	gtp_var_special,
+};
+
+struct gtp_var;
+
+#ifdef GTP_PERF_EVENTS
+struct gtp_var_perf_event	{
+	struct gtp_var_perf_event	*pc_next;
+	int				en;
+	struct perf_event		*event;
+	int				cpu;
+	u64				val;
+	u64				enabled;	/* The perf inside timer */
+	u64				running;	/* The perf inside timer */
+	char				*name;
+	struct perf_event_attr		attr;
+};
+
+struct gtp_var_pe	{
+	enum pe_tv_id			ptid;
+	struct gtp_var_perf_event	*pe;
+};
+#endif
+
+struct gtp_var_per_cpu {
+	union {
+		int64_t			val;
+#ifdef GTP_PERF_EVENTS
+		struct gtp_var_pe	pe;
+#endif
+	} u;
+};
+
+struct gtp_var_pc {
+	int				cpu;
+	struct gtp_var_per_cpu __percpu	*pc;
+};
+
+struct gtp_var {
+	struct list_head	node;
+	unsigned int		type;
+	unsigned int		num;
+	int64_t			initial_val;
+	char			*src;
+	union {
+		int64_t			val;
+		struct gtp_var_pc	pc;
+#ifdef GTP_PERF_EVENTS
+		struct gtp_var_pe	pe;
+#endif
+		struct gtp_var_hooks	*hooks;
+	} u;
+};
+
+#define gtp_var_get_pc(var)	((struct gtp_var_per_cpu *)((var)->u.pc.cpu < 0 ?  \
+				                            this_cpu_ptr(var->u.pc.pc)  \
+				                            : per_cpu_ptr((var)->u.pc.pc, (var)->u.pc.cpu)))
+#ifdef GTP_PERF_EVENTS
+#define gtp_var_get_pc_pe(var)	(&(gtp_var_get_pc(var)->u.pe))
+#define gtp_var_get_pe(var)	((var)->type == gtp_var_perf_event_per_cpu  \
+				 ? gtp_var_get_pc_pe(var) : &((var)->u.pe))
+#endif
+
+static DEFINE_SPINLOCK(gtp_var_lock);
+static LIST_HEAD(gtp_var_list);
+static unsigned int	gtp_var_num;
+static struct gtp_var	*current_gtp_var;
+static struct gtp_var	**gtp_var_array;
+
+static struct gtp_var *
+gtp_var_find_num(unsigned int num)
+{
+	struct gtp_var		*var;
+	struct list_head	*cur;
+
+	list_for_each(cur, &gtp_var_list) {
+		var = list_entry(cur, struct gtp_var, node);
+		if (var->num == num)
+			return var;
+	}
+
+	return NULL;
+}
+
+static struct gtp_var *
+gtp_var_find_src(char *src)
+{
+	struct gtp_var		*var;
+	struct list_head	*cur;
+
+	list_for_each(cur, &gtp_var_list) {
+		var = list_entry(cur, struct gtp_var, node);
+		if (strcmp (var->src + 2, src + 2) == 0)
+			return var;
+	}
+
+	return NULL;
+}
+
+static int
+gtp_var_array_find_num(struct gtp_var *var)
+{
+	int	i;
+
+	for (i = 0; i < gtp_var_num; i++) {
+		if (gtp_var_array[i] == var)
+			return i;
+	}
+
+	return -1;
+}
+
+static struct gtp_var *
+gtp_var_alloc(int cpu_id, unsigned int num, int num_not_set,
+	      int64_t initial_val, char *src)
+{
+	struct gtp_var	*var;
+
+	if (!num_not_set && gtp_var_find_num(num)) {
+		printk(KERN_WARNING "KGTP: TSV number %d already exist.\n",
+		       num);
+		return ERR_PTR(-EINVAL);
+	}
+	if (strlen(src) < 4) {
+		printk(KERN_WARNING "KGTP: TSV %d's src %s is too short.\n",
+		       num, src);
+		return ERR_PTR(-EINVAL);
+	}
+	if (gtp_var_find_src(src)) {
+		printk(KERN_WARNING "KGTP: TSV src %s already exist.\n",
+		       src);
+		return ERR_PTR(-EINVAL);
+	}
+
+	if (cpu_id < 0)
+		var = kzalloc(sizeof(struct gtp_var), GFP_KERNEL);
+	else
+		var = kmalloc_node(sizeof(struct gtp_var),
+				   GFP_KERNEL | __GFP_ZERO,
+				   cpu_to_node(cpu_id));
+	if (var == NULL)
+		return ERR_PTR(-ENOMEM);
+	var->src = gtp_strdup(src, NULL);
+	if (var->src == NULL) {
+		kfree(var);
+		return ERR_PTR(-ENOMEM);
+	}
+
+	var->initial_val = initial_val;
+	if (num_not_set) {
+		num = GTP_VAR_SPECIAL_MAX + 1;
+		while (1) {
+			struct gtp_var		*var;
+			struct list_head	*cur;
+
+			list_for_each(cur, &gtp_var_list) {
+				var = list_entry(cur, struct gtp_var, node);
+				if (var->num == num)
+					break;
+			}
+			if (cur == &gtp_var_list)
+				break;
+			num++;
+		}
+	}
+	var->num = num;
+
+	return var;
+}
+
+static struct gtp_var *
+gtp_var_special_add(unsigned int num, int num_not_set,
+		    int64_t initial_val, char *name,
+		    struct gtp_var_hooks *hooks)
+{
+	int		name_len = strlen(name);
+	char		src[3 + name_len * 2];
+	struct gtp_var	*var;
+
+	if (name_len == 0) {
+		printk(KERN_WARNING "KGTP: TSV name %s len cannot be zero.\n",
+		       name);
+		return ERR_PTR(-EINVAL);
+	}
+
+	strcpy(src, "1:");
+	string2hex (name, src + 2);
+
+	var = gtp_var_alloc(-1, num, num_not_set, initial_val, src);
+	if (IS_ERR(var))
+		return var;
+
+	var->type = gtp_var_special;
+	var->u.hooks = hooks;
+
+	list_add(&var->node, &gtp_var_list);
+	gtp_var_num++;
+
+	return var;
+}
+
+static void
+gtp_var_release(int include_special)
+{
+	struct gtp_var		*var;
+	struct list_head	*cur, *tmp;
+
+#ifdef GTP_PERF_EVENTS
+	/* Remove all data of pe.  */
+	while (1) {
+		struct gtp_var_perf_event	*pe = NULL;
+
+		list_for_each(cur, &gtp_var_list) {
+			var = list_entry(cur, struct gtp_var, node);
+			if ((var->type == gtp_var_perf_event
+			     || var->type == gtp_var_perf_event_per_cpu)
+			    && gtp_var_get_pe(var)->pe) {
+				pe = gtp_var_get_pe(var)->pe;
+				break;
+			}
+		}
+		if (pe == NULL)
+			break;
+		if (pe->event)
+			perf_event_release_kernel(pe->event);
+		kfree(pe->name);
+		kfree(pe);
+		list_for_each(cur, &gtp_var_list) {
+			var = list_entry(cur, struct gtp_var, node);
+			if ((var->type == gtp_var_perf_event
+			     || var->type == gtp_var_perf_event_per_cpu)
+			    && gtp_var_get_pe(var)->pe == pe) {
+				gtp_var_get_pe(var)->pe = NULL;
+				if (var->type == gtp_var_perf_event_per_cpu)
+					var->type = gtp_var_per_cpu;
+			}
+		}
+	}
+#endif
+
+	/* Remove all data of pc.  */
+	while (1) {
+		struct gtp_var_per_cpu	*pc = NULL;
+
+		list_for_each(cur, &gtp_var_list) {
+			var = list_entry(cur, struct gtp_var, node);
+			if (var->type == gtp_var_per_cpu && var->u.pc.pc) {
+				pc = var->u.pc.pc;
+				break;
+			}
+		}
+		if (pc == NULL)
+			break;
+		free_percpu(pc);
+		list_for_each(cur, &gtp_var_list) {
+			var = list_entry(cur, struct gtp_var, node);
+			if ((var->type == gtp_var_per_cpu)
+			    && var->u.pc.pc == pc) {
+				var->u.pc.pc = NULL;
+			}
+		}
+	}
+
+	list_for_each_safe(cur, tmp, &gtp_var_list) {
+		var = list_entry(cur, struct gtp_var, node);
+		if (!include_special && var->type == gtp_var_special)
+			continue;
+
+		list_del(&var->node);
+		gtp_var_num--;
+		kfree(var->src);
+		kfree(var);
+	}
+}
+
+static int
+gtp_version_hooks_get_val(struct gtp_trace_s *unused1, struct gtp_var *unused2,
+			  int64_t *val)
+{
+	*val = GTP_VERSION;
+	return 0;
+}
+
+static struct gtp_var_hooks	gtp_version_hooks = {
+	.gdb_get_val = gtp_version_hooks_get_val,
+	.agent_get_val = gtp_version_hooks_get_val,
+};
+
+static int
+gtp_cpu_id_hooks_get_val(struct gtp_trace_s *unused1, struct gtp_var *unused2,
+			  int64_t *val)
+{
+	*val = smp_processor_id();
+	return 0;
+}
+
+static struct gtp_var_hooks	gtp_cpu_id_hooks = {
+	.gdb_get_val = gtp_cpu_id_hooks_get_val,
+	.agent_get_val = gtp_cpu_id_hooks_get_val,
+};
+
+static int
+gtp_current_task_hooks_get_val(struct gtp_trace_s *gts,
+			       struct gtp_var *unused, int64_t *val)
+{
+	if (gts->ri)
+		*val = (int64_t)(CORE_ADDR)gts->ri->task;
+	else
+		*val = (int64_t)(CORE_ADDR)get_current();
+
+	return 0;
+}
+
+static struct gtp_var_hooks	gtp_current_task_hooks = {
+	.agent_get_val = gtp_current_task_hooks_get_val,
+};
+
+static int
+gtp_current_task_pid_hooks_get_val(struct gtp_trace_s *gts,
+				   struct gtp_var *unused2, int64_t *val)
+{
+	if (gts->ri)
+		*val = (uint64_t)(CORE_ADDR)gts->ri->task->pid;
+	else
+		*val = (uint64_t)(CORE_ADDR)get_current()->pid;
+
+	return 0;
+}
+
+static struct gtp_var_hooks	gtp_current_task_pid_hooks = {
+	.agent_get_val = gtp_current_task_pid_hooks_get_val,
+};
+
+static int
+gtp_current_thread_info_hooks_get_val(struct gtp_trace_s *unused1,
+				      struct gtp_var *unused2, int64_t *val)
+{
+	*val = (int64_t)(CORE_ADDR)current_thread_info();
+
+	return 0;
+}
+
+static struct gtp_var_hooks	gtp_current_thread_info_hooks = {
+	.agent_get_val = gtp_current_thread_info_hooks_get_val,
+};
+
+static int
+gtp_current_task_user_hooks_get_val(struct gtp_trace_s *unused1,
+				    struct gtp_var *unused2, int64_t *val)
+{
+	*val = (int64_t)user_mode(task_pt_regs(get_current()));
+
+	return 0;
+}
+
+static struct gtp_var_hooks	gtp_current_task_user_hooks = {
+	.agent_get_val = gtp_current_task_user_hooks_get_val,
+};
+
+static int
+gtp_current_hooks_set_val(struct gtp_trace_s *gts, struct gtp_var *gtv,
+			  int64_t val)
+{
+	if (gts->tmp_regs == NULL)
+		gts->tmp_regs = (struct pt_regs *)(unsigned long)val;
+	else {
+		printk(KERN_WARNING "KGTP: $current cannot be set twice.");
+		return -1;
+	}
+
+	return 0;
+}
+
+static struct gtp_var_hooks	gtp_current_hooks = {
+	.agent_set_val = gtp_current_hooks_set_val,
+};
+
+static int
+gtp_clock_hooks_get_val(struct gtp_trace_s *unused1,
+			struct gtp_var *unused2, int64_t *val)
+{
+	*val = (int64_t)GTP_LOCAL_CLOCK;
+
+	return 0;
+}
+
+static struct gtp_var_hooks	gtp_clock_hooks = {
+	.gdb_get_val = gtp_clock_hooks_get_val,
+	.agent_get_val = gtp_clock_hooks_get_val,
+};
+
+static int
+gtp_cooked_clock_hooks_get_val(struct gtp_trace_s *unused1,
+			       struct gtp_var *unused2, int64_t *val)
+{
+	*val = (int64_t)(__get_cpu_var(local_clock_current)
+				- __get_cpu_var(local_clock_offset));
+
+	return 0;
+}
+
+static struct gtp_var_hooks	gtp_cooked_clock_hooks = {
+	.agent_get_val = gtp_cooked_clock_hooks_get_val,
+};
+
+#ifdef CONFIG_X86
+static int
+gtp_rdtsc_hooks_get_val(struct gtp_trace_s *unused1,
+			struct gtp_var *unused2, int64_t *val)
+{
+	unsigned long long a;
+
+	rdtscll(a);
+	*val = (int64_t)a;
+
+	return 0;
+}
+
+static struct gtp_var_hooks	gtp_rdtsc_hooks = {
+	.gdb_get_val = gtp_rdtsc_hooks_get_val,
+	.agent_get_val = gtp_rdtsc_hooks_get_val,
+};
+
+static int
+gtp_cooked_rdtsc_hooks_get_val(struct gtp_trace_s *unused1,
+			       struct gtp_var *unused2, int64_t *val)
+{
+	*val = (int64_t)(__get_cpu_var(rdtsc_current)
+				- __get_cpu_var(rdtsc_offset));
+
+	return 0;
+}
+
+static struct gtp_var_hooks	gtp_cooked_rdtsc_hooks = {
+	.agent_get_val = gtp_cooked_rdtsc_hooks_get_val,
+};
+#endif
+
+#ifdef GTP_RB
+static int
+gtp_rb_discard_page_number_hooks_get_val(struct gtp_trace_s *unused1,
+					 struct gtp_var *unused2, int64_t *val)
+{
+	*val = (int64_t)atomic_read(&gtp_rb_discard_page_number);
+
+	return 0;
+}
+
+static struct gtp_var_hooks	gtp_rb_discard_page_number_hooks = {
+	.gdb_get_val = gtp_rb_discard_page_number_hooks_get_val,
+};
+#endif
+
+static int
+gtp_printk_tmp_hooks_get_val(struct gtp_trace_s *gts,
+			     struct gtp_var *unused, int64_t *val)
+{
+	*val = gts->printk_tmp;
+
+	return 0;
+}
+
+static int
+gtp_printk_tmp_hooks_set_val(struct gtp_trace_s *gts,
+			     struct gtp_var *unused, int64_t val)
+{
+	gts->printk_tmp = val;
+
+	return 0;
+}
+
+static struct gtp_var_hooks	gtp_printk_tmp_hooks = {
+	.agent_get_val = gtp_printk_tmp_hooks_get_val,
+	.agent_set_val = gtp_printk_tmp_hooks_set_val,
+};
+
+static int
+gtp_printk_level_hooks_set_val(struct gtp_trace_s *gts,
+			       struct gtp_var *unused, int64_t val)
+{
+	gts->printk_level = (unsigned int)val;
+
+	return 0;
+}
+
+static struct gtp_var_hooks	gtp_printk_level_hooks = {
+	.agent_set_val = gtp_printk_level_hooks_set_val,
+};
+
+static int
+gtp_printk_format_hooks_set_val(struct gtp_trace_s *gts,
+				struct gtp_var *unused, int64_t val)
+{
+	gts->printk_format = (unsigned int)val;
+
+	return 0;
+}
+
+static struct gtp_var_hooks	gtp_printk_format_hooks = {
+	.agent_set_val = gtp_printk_format_hooks_set_val,
+};
+
+static int
+gtp_dump_stack_hooks_get_val(struct gtp_trace_s *gts,
+			     struct gtp_var *unused1, int64_t *val)
+{
+	printk(KERN_NULL "CPU%d gtp %d %p:", smp_processor_id(),
+	       (int)gts->tpe->num, (void *)(CORE_ADDR)gts->tpe->addr);
+	dump_stack();
+	*val = 0;
+
+	return 0;
+}
+
+static struct gtp_var_hooks	gtp_dump_stack_hooks = {
+	.agent_get_val = gtp_dump_stack_hooks_get_val,
+};
+
+static int
+gtp_pipe_trace_hooks_get_val(struct gtp_trace_s *unused1,
+			     struct gtp_var *unused2, int64_t *val)
+{
+	*val = (int64_t)gtp_pipe_trace;
+
+	return 0;
+}
+
+static int
+gtp_pipe_trace_hooks_set_val(struct gtp_trace_s *unused1,
+			     struct gtp_var *unused2, int64_t val)
+{
+	gtp_pipe_trace = (int)val;
+
+	return 0;
+}
+
+static struct gtp_var_hooks	gtp_pipe_trace_hooks = {
+	.gdb_get_val = gtp_pipe_trace_hooks_get_val,
+	.gdb_set_val = gtp_pipe_trace_hooks_set_val,
+};
+
+static int
+gtp_cpu_number_hooks_get_val(struct gtp_trace_s *unused1,
+			     struct gtp_var *unused2, int64_t *val)
+{
+	*val = (int64_t)gtp_cpu_number;
+
+	return 0;
+}
+
+static struct gtp_var_hooks	gtp_cpu_number_hooks = {
+	.gdb_get_val = gtp_cpu_number_hooks_get_val,
+	.agent_get_val = gtp_cpu_number_hooks_get_val,
+};
+
+static void	gtp_pc_pe_en(int enable);
+
+static int
+gtp_pc_pe_en_hooks_set_val(struct gtp_trace_s *unused1,
+			   struct gtp_var *unused2, int64_t val)
+{
+	gtp_pc_pe_en((int)val);
+
+	return 0;
+}
+
+static struct gtp_var_hooks	gtp_pc_pe_en_hooks = {
+	.agent_set_val = gtp_pc_pe_en_hooks_set_val,
+};
+
+static int
+gtp_xtime_hooks_agent_get_val(struct gtp_trace_s *gts,
+			      struct gtp_var *gtv, int64_t *val)
+{
+	if (gts->xtime.tv_sec == 0 && gts->xtime.tv_nsec == 0)
+		getnstimeofday(&gts->xtime);
+
+	if (gtv->num == GTP_VAR_XTIME_SEC_ID)
+		*val = (int64_t)gts->xtime.tv_sec;
+	else
+		*val = (int64_t)gts->xtime.tv_nsec;
+
+	return 0;
+}
+
+static int
+gtp_xtime_hooks_gdb_get_val(struct gtp_trace_s *gts,
+			    struct gtp_var *gtv, int64_t *val)
+{
+	struct timespec	time;
+
+	getnstimeofday(&time);
+	if (gtv->num == GTP_VAR_XTIME_SEC_ID)
+		*val = (int64_t)time.tv_sec;
+	else
+		*val = (int64_t)time.tv_nsec;
+
+	return 0;
+}
+
+static struct gtp_var_hooks	gtp_xtime_hooks = {
+	.agent_get_val = gtp_xtime_hooks_agent_get_val,
+	.gdb_get_val = gtp_xtime_hooks_gdb_get_val,
+};
+
+static int
+gtp_ignore_error_hooks_get_val(struct gtp_trace_s *unused1,
+			       struct gtp_var *unused2, int64_t *val)
+{
+	*val = (int64_t)gtp_start_ignore_error;
+
+	return 0;
+}
+
+static int
+gtp_ignore_error_hooks_set_val(struct gtp_trace_s *unused1,
+			       struct gtp_var *unused2, int64_t val)
+{
+	gtp_start_ignore_error = (int)val;
+
+	return 0;
+}
+
+static struct gtp_var_hooks	gtp_ignore_error_hooks = {
+	.gdb_get_val = gtp_ignore_error_hooks_get_val,
+	.gdb_set_val = gtp_ignore_error_hooks_set_val,
+};
+
+static int
+gtp_last_errno_hooks_get_val(struct gtp_trace_s *unused1,
+			     struct gtp_var *unused2, int64_t *val)
+{
+	*val = (int64_t)gtp_start_last_errno;
+
+	return 0;
+}
+
+static struct gtp_var_hooks	gtp_last_errno_hooks = {
+	.gdb_get_val = gtp_last_errno_hooks_get_val,
+};
+
+static int
+gtp_hardirq_count_hooks_get_val(struct gtp_trace_s *unused1,
+				struct gtp_var *unused2, int64_t *val)
+{
+	*val = (int64_t)hardirq_count();
+
+	return 0;
+}
+
+static struct gtp_var_hooks	gtp_hardirq_count_hooks = {
+	.agent_get_val = gtp_hardirq_count_hooks_get_val,
+};
+
+static int
+gtp_softirq_count_hooks_get_val(struct gtp_trace_s *unused1,
+				struct gtp_var *unused2, int64_t *val)
+{
+	*val = (int64_t)softirq_count();
+
+	return 0;
+}
+
+static struct gtp_var_hooks	gtp_softirq_count_hooks = {
+	.agent_get_val = gtp_softirq_count_hooks_get_val,
+};
+
+static int
+gtp_irq_count_hooks_get_val(struct gtp_trace_s *unused1,
+			    struct gtp_var *unused2, int64_t *val)
+{
+	*val = (int64_t)irq_count();
+
+	return 0;
+}
+
+static struct gtp_var_hooks	gtp_irq_count_hooks = {
+	.agent_get_val = gtp_irq_count_hooks_get_val,
+};
+
+static int
+gtp_bt_hooks_get_val(struct gtp_trace_s *unused1,
+		     struct gtp_var *unused2, int64_t *val)
+{
+	*val = (int64_t)gtp_bt_size;
+
+	return 0;
+}
+
+static int
+gtp_bt_hooks_set_val(struct gtp_trace_s *unused1,
+		     struct gtp_var *unused2, int64_t val)
+{
+	gtp_bt_size = (int)val;
+
+	return 0;
+}
+
+static struct gtp_var_hooks	gtp_bt_hooks = {
+	.gdb_get_val = gtp_bt_hooks_get_val,
+	.gdb_set_val = gtp_bt_hooks_set_val,
+};
+
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,30))
+
+static void	gtp_handler_enable_disable(struct gtp_trace_s *gts,
+					   ULONGEST val, int enable);
+
+static int
+gtp_enable_disable_hooks_set_val(struct gtp_trace_s *gts,
+				 struct gtp_var *gtv, int64_t val)
+{
+	gtp_handler_enable_disable(gts, val,
+				   (gtv->num == GTP_VAR_ENABLE_ID));
+
+	return 0;
+}
+
+static struct gtp_var_hooks	gtp_enable_disable_hooks = {
+	.agent_set_val = gtp_enable_disable_hooks_set_val,
+};
+#endif
+
+#ifdef CONFIG_X86
+static int
+gtp_watch_type_hooks_set_val(struct gtp_trace_s *gts,
+			     struct gtp_var *gtv, int64_t val)
+{
+	if (gts->tpe->type != gtp_entry_kprobe) {
+		printk(KERN_WARNING "Cannot set $watch_type in hardware breakpoint handler.\n");
+		return -1;
+	}
+	if (val != gtp_watch_exec && val != gtp_watch_write
+	    && val != gtp_watch_read_write) {
+		printk(KERN_WARNING "$watch_type just support set to 0, 1 or 2.\n");
+		return -1;
+	}
+
+	gts->watch_type = val;
+
+	return 0;
+}
+
+static int
+gtp_watch_type_hooks_get_val(struct gtp_trace_s *gts,
+			     struct gtp_var *gtv, int64_t *val)
+{
+	if (gts->tpe->type == gtp_entry_kprobe)
+		*val = gts->watch_type;
+	else
+		*val = gts->hwb->type;
+
+	return 0;
+}
+
+static struct gtp_var_hooks	gtp_watch_type_hooks = {
+	.agent_set_val = gtp_watch_type_hooks_set_val,
+	.agent_get_val = gtp_watch_type_hooks_get_val,
+};
+
+static int
+gtp_watch_size_hooks_set_val(struct gtp_trace_s *gts,
+			     struct gtp_var *gtv, int64_t val)
+{
+	if (gts->tpe->type != gtp_entry_kprobe) {
+		printk(KERN_WARNING "Cannot set $watch_size in hardware breakpoint handler.\n");
+		return -1;
+	}
+	if (val != 1 && val != 2 && val != 4 && val != 8) {
+		printk(KERN_WARNING "$watch_size just support set to 1, 2, 4 or 8.\n");
+		return -1;
+	}
+
+	gts->watch_size = val;
+
+	return 0;
+}
+
+static int
+gtp_watch_size_hooks_get_val(struct gtp_trace_s *gts,
+			     struct gtp_var *gtv, int64_t *val)
+{
+	if (gts->tpe->type == gtp_entry_kprobe)
+		*val = gts->watch_size;
+	else
+		*val = gts->hwb->size;
+
+	return 0;
+}
+
+static struct gtp_var_hooks	gtp_watch_size_hooks = {
+	.agent_set_val = gtp_watch_size_hooks_set_val,
+	.agent_get_val = gtp_watch_size_hooks_get_val,
+};
+
+static struct gtp_entry *
+gtp_list_find_watch_num(ULONGEST num)
+{
+	struct gtp_entry	*tpe;
+
+	for (tpe = gtp_list; tpe; tpe = tpe->next) {
+		if (tpe->type == gtp_entry_watch_dynamic
+		    && tpe->num == num)
+			return tpe;
+	}
+
+	return NULL;
+}
+
+static struct gtp_entry *
+gtp_list_find_watch_addr(ULONGEST addr)
+{
+	struct gtp_entry	*tpe;
+
+	for (tpe = gtp_list; tpe; tpe = tpe->next) {
+		if (tpe->type == gtp_entry_watch_dynamic
+		    && tpe->addr == addr)
+			return tpe;
+	}
+
+	return NULL;
+}
+
+static int
+gtp_watch_set_hooks_set_val(struct gtp_trace_s *gts,
+			    struct gtp_var *gtv, int64_t val)
+{
+	struct gtp_entry	*tpe;
+
+	if (gts->tpe->type != gtp_entry_kprobe) {
+		printk(KERN_WARNING "Cannot set $watch_id in hardware breakpoint handler.\n");
+		return -1;
+	}
+
+	if (gtv->num == GTP_WATCH_SET_ID_ID)
+		tpe = gtp_list_find_watch_num(val);
+	else
+		tpe = gtp_list_find_watch_addr(val);
+	if (!tpe) {
+		printk(KERN_WARNING "Cannot find dynamic watch tracepoint %s is %lld.\n",
+		       (gtv->num == GTP_WATCH_SET_ID_ID) ? "id" : "address", val);
+		return -1;
+	}
+
+	gts->watch_tpe = tpe;
+	gts->watch_type = gtp_watch_write;
+	gts->watch_size = 1;
+
+	return 0;
+}
+
+static struct gtp_var_hooks	gtp_watch_set_hooks = {
+	.agent_set_val = gtp_watch_set_hooks_set_val,
+};
+
+static int gtp_register_hwb(const struct gtp_hwb_s *arg, int nowait);
+static int gtp_unregister_hwb(CORE_ADDR addr, int sync);
+
+static int
+gtp_watch_start_hooks_set_val(struct gtp_trace_s *gts,
+			      struct gtp_var *gtv, int64_t val)
+{
+	struct gtp_hwb_s	arg;
+
+	if (gts->watch_tpe == NULL) {
+		printk(KERN_WARNING "Cannot set $watch_id in hardware breakpoint handler.\n");
+		return -1;
+	}
+
+	arg.addr = val;
+	arg.size = gts->watch_size;
+	arg.type = gts->watch_type;
+	arg.trace_num = gts->tpe->num;
+	arg.trace_addr = gts->tpe->addr;
+	arg.watch = gts->watch_tpe;
+	gts->watch_start_ret = gtp_register_hwb(&arg, 1);
+
+	return 0;
+}
+
+static int
+gtp_watch_start_hooks_get_val(struct gtp_trace_s *gts,
+			      struct gtp_var *gtv, int64_t *val)
+{
+	*val = gts->watch_start_ret;
+
+	return 0;
+}
+
+static struct gtp_var_hooks	gtp_watch_start_hooks = {
+	.agent_set_val = gtp_watch_start_hooks_set_val,
+	.agent_get_val = gtp_watch_start_hooks_get_val,
+};
+
+static int
+gtp_watch_stop_hooks_set_val(struct gtp_trace_s *gts,
+			     struct gtp_var *gtv, int64_t val)
+{
+	gts->watch_stop_ret = gtp_unregister_hwb(val, 1);
+
+	return 0;
+}
+
+static int
+gtp_watch_stop_hooks_get_val(struct gtp_trace_s *gts,
+			      struct gtp_var *gtv, int64_t *val)
+{
+	*val = gts->watch_stop_ret;
+
+	return 0;
+}
+
+static struct gtp_var_hooks	gtp_watch_stop_hooks = {
+	.agent_set_val = gtp_watch_stop_hooks_set_val,
+	.agent_get_val = gtp_watch_stop_hooks_get_val,
+};
+
+static int
+gtp_watch_get_val(struct gtp_trace_s *gts, struct gtp_var *gtv,
+		  int64_t *val)
+{
+	if (gts->tpe->type == gtp_entry_kprobe)
+		return -1;
+
+	switch (gtv->num) {
+	case GTP_WATCH_TRACE_NUM_ID:
+		*val = gts->hwb->trace_num;
+		break;
+	case GTP_WATCH_TRACE_ADDR_ID:
+		*val = gts->hwb->trace_addr;
+		break;
+	case GTP_WATCH_ADDR_ID:
+		*val = gts->hwb->addr;
+		break;
+	case GTP_WATCH_COUNT_ID:
+		*val = gts->hwb->count;
+		break;
+	default:
+		return -1;
+		break;
+	}
+
+	return 0;
+}
+
+static struct gtp_var_hooks	gtp_watch_get_hooks = {
+	.agent_get_val = gtp_watch_get_val,
+};
+
+static int	gtp_get_addr_val(CORE_ADDR addr, int size, int64_t *val);
+
+static int
+gtp_watch_val_get_val(struct gtp_trace_s *gts, struct gtp_var *gtv,
+		      int64_t *val)
+{
+	int	ret;
+
+	if (gts->tpe->type == gtp_entry_kprobe)
+		return -EINVAL;
+
+	if (gts->hwb_current_val_gotten) {
+		*val = gts->hwb_current_val;
+		return 0;
+	}
+
+	ret = gtp_get_addr_val(gts->hwb->addr, gts->hwb->size, val);
+	if (ret == 0) {
+		gts->hwb_current_val = *val;
+		gts->hwb_current_val_gotten = 1;
+	}
+
+	return ret;
+}
+
+static struct gtp_var_hooks	gtp_watch_val_hooks = {
+	.agent_get_val = gtp_watch_val_get_val,
+};
+
+static int
+gtp_watch_prev_val_get_val(struct gtp_trace_s *gts, struct gtp_var *gtv,
+			   int64_t *val)
+{
+	if (gts->tpe->type == gtp_entry_kprobe)
+		return -EINVAL;
+
+	*val = gts->hwb->prev_val;
+	return 0;
+}
+
+static struct gtp_var_hooks	gtp_watch_prev_val_hooks = {
+	.agent_get_val = gtp_watch_prev_val_get_val,
+};
+#endif
+
+#ifdef CONFIG_X86
+static int
+gtp_get_addr_val(CORE_ADDR addr, int size, int64_t *val)
+{
+	int	ret = -EINVAL;
+
+	union {
+		union {
+			uint8_t	bytes[1];
+			uint8_t	val;
+		} u8;
+		union {
+			uint8_t	bytes[2];
+			uint16_t val;
+		} u16;
+		union {
+			uint8_t bytes[4];
+			uint32_t val;
+		} u32;
+		union {
+			uint8_t bytes[8];
+			ULONGEST val;
+		} u64;
+	} cnv;
+
+	switch (size) {
+	case 1:
+		ret = probe_kernel_read(cnv.u8.bytes, (void *)addr, 1);
+		if (ret)
+			goto error;
+		*val = (int64_t) cnv.u8.val;
+		break;
+	case 2:
+		ret = probe_kernel_read(cnv.u16.bytes, (void *)addr, 2);
+		if (ret)
+			goto error;
+		*val = (int64_t) cnv.u16.val;
+		break;
+	case 4:
+		ret = probe_kernel_read(cnv.u32.bytes, (void *)addr, 4);
+		if (ret)
+			goto error;
+		*val = (int64_t) cnv.u32.val;
+		break;
+	case 8:
+		ret = probe_kernel_read(cnv.u64.bytes, (void *)addr, 8);
+		if (ret)
+			goto error;
+		*val = (int64_t) cnv.u64.val;
+		break;
+	default:
+		goto error;
+		break;
+	}
+
+	return 0;
+
+error:
+	printk(KERN_WARNING "KGTP: fail get value from address %p size %d.\n",
+	       (void *)addr, size);
+	return ret;
+}
+#endif
+
+#ifdef GTP_RB
+static int
+gtp_step_count_hooks_get_val(struct gtp_trace_s *gts, struct gtp_var *gtv,
+			     int64_t *val)
+{
+	if (gts->step)
+		*val = gts->tpe->step - gts->step + 1;
+	else
+		*val = 0;
+
+	return 0;
+}
+
+static struct gtp_var_hooks	gtp_step_count_hooks = {
+	.agent_get_val = gtp_step_count_hooks_get_val,
+};
+
+static DEFINE_PER_CPU(int64_t, gtp_step_id);
+
+static int
+gtp_step_id_hooks_get_val(struct gtp_trace_s *gts, struct gtp_var *gtv,
+			  int64_t *val)
+{
+	if (!gts->step) {
+		if (++ __get_cpu_var(gtp_step_id) == 0)
+			__get_cpu_var(gtp_step_id) = 1;
+	}
+
+	*val = __get_cpu_var(gtp_step_id);
+
+	return 0;
+}
+
+static struct gtp_var_hooks	gtp_step_id_hooks = {
+	.agent_get_val = gtp_step_id_hooks_get_val,
+};
+#endif
+
+static int
+gtp_var_special_add_all(void)
+{
+	struct gtp_var	*var;
+
+	var = gtp_var_special_add(GTP_VAR_VERSION_ID, 0, GTP_VERSION,
+				  "gtp_version", &gtp_version_hooks);
+	if (IS_ERR(var))
+		return PTR_ERR(var);
+
+	var = gtp_var_special_add(GTP_VAR_CPU_ID, 0, 0, "cpu_id",
+				  &gtp_cpu_id_hooks);
+	if (IS_ERR(var))
+		return PTR_ERR(var);
+
+	var = gtp_var_special_add(GTP_VAR_CURRENT_TASK_ID, 0, 0,
+				  "current_task", &gtp_current_task_hooks);
+	if (IS_ERR(var))
+		return PTR_ERR(var);
+
+	var = gtp_var_special_add(GTP_VAR_CURRENT_TASK_PID_ID, 0, 0,
+				  "current_task_pid",
+				  &gtp_current_task_pid_hooks);
+	if (IS_ERR(var))
+		return PTR_ERR(var);
+
+	var = gtp_var_special_add(GTP_VAR_CURRENT_THREAD_INFO_ID, 0, 0,
+				  "current_thread_info",
+				  &gtp_current_thread_info_hooks);
+	if (IS_ERR(var))
+		return PTR_ERR(var);
+
+	var = gtp_var_special_add(GTP_VAR_CURRENT_TASK_USER_ID, 0, 0,
+				  "current_task_user",
+				  &gtp_current_task_user_hooks);
+	if (IS_ERR(var))
+		return PTR_ERR(var);
+
+	var = gtp_var_special_add(GTP_VAR_CURRENT_ID, 0, 0, "current",
+				  &gtp_current_hooks);
+	if (IS_ERR(var))
+		return PTR_ERR(var);
+
+	var = gtp_var_special_add(GTP_VAR_CLOCK_ID, 0, 0, "clock",
+				  &gtp_clock_hooks);
+	if (IS_ERR(var))
+		return PTR_ERR(var);
+
+	var = gtp_var_special_add(GTP_VAR_COOKED_CLOCK_ID, 0, 0,
+				  "cooked_clock", &gtp_cooked_clock_hooks);
+	if (IS_ERR(var))
+		return PTR_ERR(var);
+
+#ifdef CONFIG_X86
+	var = gtp_var_special_add(GTP_VAR_RDTSC_ID, 0, 0, "rdtsc",
+				  &gtp_rdtsc_hooks);
+	if (IS_ERR(var))
+		return PTR_ERR(var);
+
+	var = gtp_var_special_add(GTP_VAR_COOKED_RDTSC_ID, 0, 0,
+				  "cooked_rdtsc", &gtp_cooked_rdtsc_hooks);
+	if (IS_ERR(var))
+		return PTR_ERR(var);
+#endif
+
+#ifdef GTP_RB
+	var = gtp_var_special_add(GTP_VAR_GTP_RB_DISCARD_PAGE_NUMBER, 0, 0,
+				  "gtp_rb_discard_page_number", 
+				  &gtp_rb_discard_page_number_hooks);
+	if (IS_ERR(var))
+		return PTR_ERR(var);
+#endif
+
+	var = gtp_var_special_add(GTP_VAR_PRINTK_TMP_ID, 0, 0,
+				  "printk_tmp", &gtp_printk_tmp_hooks);
+	if (IS_ERR(var))
+		return PTR_ERR(var);
+
+	var = gtp_var_special_add(GTP_VAR_PRINTK_LEVEL_ID, 0, 8,
+				  "printk_level", &gtp_printk_level_hooks);
+	if (IS_ERR(var))
+		return PTR_ERR(var);
+
+	var = gtp_var_special_add(GTP_VAR_PRINTK_FORMAT_ID, 0, 0,
+				  "printk_format", &gtp_printk_format_hooks);
+	if (IS_ERR(var))
+		return PTR_ERR(var);
+
+	var = gtp_var_special_add(GTP_VAR_DUMP_STACK_ID, 0, 0,
+				  "dump_stack", &gtp_dump_stack_hooks);
+	if (IS_ERR(var))
+		return PTR_ERR(var);
+
+	var = gtp_var_special_add(GTP_VAR_SELF_TRACE_ID, 0, 0,
+				  "self_trace", NULL);
+	if (IS_ERR(var))
+		return PTR_ERR(var);
+
+	var = gtp_var_special_add(GTP_VAR_PIPE_TRACE_ID, 0, 0,
+				  "pipe_trace", &gtp_pipe_trace_hooks);
+	if (IS_ERR(var))
+		return PTR_ERR(var);
+
+	var = gtp_var_special_add(GTP_VAR_CPU_NUMBER_ID, 0, 0,
+				  "cpu_number", &gtp_cpu_number_hooks);
+	if (IS_ERR(var))
+		return PTR_ERR(var);
+
+	var = gtp_var_special_add(GTP_VAR_PC_PE_EN_ID, 0, 0,
+				  "p_pe_en", &gtp_pc_pe_en_hooks);
+	if (IS_ERR(var))
+		return PTR_ERR(var);
+
+	var = gtp_var_special_add(GTP_VAR_KRET_ID, 0, 0,
+				  "kret", NULL);
+	if (IS_ERR(var))
+		return PTR_ERR(var);
+
+	var = gtp_var_special_add(GTP_VAR_XTIME_SEC_ID, 0, 0,
+				  "xtime_sec", &gtp_xtime_hooks);
+	if (IS_ERR(var))
+		return PTR_ERR(var);
+
+	var = gtp_var_special_add(GTP_VAR_XTIME_NSEC_ID, 0, 0,
+				  "xtime_nsec", &gtp_xtime_hooks);
+	if (IS_ERR(var))
+		return PTR_ERR(var);
+
+	var = gtp_var_special_add(GTP_VAR_IGNORE_ERROR_ID, 0, 0,
+				  "ignore_error", &gtp_ignore_error_hooks);
+	if (IS_ERR(var))
+		return PTR_ERR(var);
+
+	var = gtp_var_special_add(GTP_VAR_LAST_ERRNO_ID, 0, 0,
+				  "last_errno", &gtp_last_errno_hooks);
+	if (IS_ERR(var))
+		return PTR_ERR(var);
+
+	var = gtp_var_special_add(GTP_VAR_HARDIRQ_COUNT_ID, 0, 0,
+				  "hardirq_count", &gtp_hardirq_count_hooks);
+	if (IS_ERR(var))
+		return PTR_ERR(var);
+
+	var = gtp_var_special_add(GTP_VAR_SOFTIRQ_COUNT_ID, 0, 0,
+				  "softirq_count", &gtp_softirq_count_hooks);
+	if (IS_ERR(var))
+		return PTR_ERR(var);
+
+	var = gtp_var_special_add(GTP_VAR_IRQ_COUNT_ID, 0, 0,
+				  "irq_count", &gtp_irq_count_hooks);
+	if (IS_ERR(var))
+		return PTR_ERR(var);
+
+	var = gtp_var_special_add(GTP_VAR_BT_ID, 0, 512, "bt",
+				  &gtp_bt_hooks);
+	if (IS_ERR(var))
+		return PTR_ERR(var);
+
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,30))
+	var = gtp_var_special_add(GTP_VAR_ENABLE_ID, 0, 0,
+				  "enable", &gtp_enable_disable_hooks);
+	if (IS_ERR(var))
+		return PTR_ERR(var);
+
+	var = gtp_var_special_add(GTP_VAR_DISABLE_ID, 0, 0,
+				  "disable", &gtp_enable_disable_hooks);
+	if (IS_ERR(var))
+		return PTR_ERR(var);
+#endif
+
+#ifdef CONFIG_X86
+	var = gtp_var_special_add(GTP_WATCH_STATIC_ID, 0, 0,
+				  "watch_static", NULL);
+	if (IS_ERR(var))
+		return PTR_ERR(var);
+	var = gtp_var_special_add(GTP_WATCH_TYPE_ID, 0, 0,
+				  "watch_type", &gtp_watch_type_hooks);
+	if (IS_ERR(var))
+		return PTR_ERR(var);
+	var = gtp_var_special_add(GTP_WATCH_SIZE_ID, 0, 1,
+				  "watch_size", &gtp_watch_size_hooks);
+	if (IS_ERR(var))
+		return PTR_ERR(var);
+	var = gtp_var_special_add(GTP_WATCH_SET_ID_ID, 0, 0,
+				  "watch_set_id", &gtp_watch_set_hooks);
+	if (IS_ERR(var))
+		return PTR_ERR(var);
+	var = gtp_var_special_add(GTP_WATCH_SET_ADDR_ID, 0, 0,
+				  "watch_set_addr", &gtp_watch_set_hooks);
+	if (IS_ERR(var))
+		return PTR_ERR(var);
+	var = gtp_var_special_add(GTP_WATCH_START_ID, 0, 0,
+				  "watch_start", &gtp_watch_start_hooks);
+	if (IS_ERR(var))
+		return PTR_ERR(var);
+	var = gtp_var_special_add(GTP_WATCH_STOP_ID, 0, 0,
+				  "watch_stop", &gtp_watch_stop_hooks);
+	if (IS_ERR(var))
+		return PTR_ERR(var);
+	var = gtp_var_special_add(GTP_WATCH_TRACE_NUM_ID, 0, 0,
+				  "watch_trace_num", &gtp_watch_get_hooks);
+	if (IS_ERR(var))
+		return PTR_ERR(var);
+	var = gtp_var_special_add(GTP_WATCH_TRACE_ADDR_ID, 0, 0,
+				  "watch_trace_addr", &gtp_watch_get_hooks);
+	if (IS_ERR(var))
+		return PTR_ERR(var);
+	var = gtp_var_special_add(GTP_WATCH_ADDR_ID, 0, 0,
+				  "watch_addr", &gtp_watch_get_hooks);
+	if (IS_ERR(var))
+		return PTR_ERR(var);
+	var = gtp_var_special_add(GTP_WATCH_VAL_ID, 0, 0,
+				  "watch_val", &gtp_watch_val_hooks);
+	if (IS_ERR(var))
+		return PTR_ERR(var);
+	var = gtp_var_special_add(GTP_WATCH_PREV_VAL_ID, 0, 0,
+				  "watch_prev_val", &gtp_watch_prev_val_hooks);
+	if (IS_ERR(var))
+		return PTR_ERR(var);
+	var = gtp_var_special_add(GTP_WATCH_COUNT_ID, 0, 0,
+				  "watch_count", &gtp_watch_get_hooks);
+	if (IS_ERR(var))
+		return PTR_ERR(var);
+#endif
+	var = gtp_var_special_add(GTP_STEP_COUNT_ID, 0, 0,
+				  "step_count", &gtp_step_count_hooks);
+	if (IS_ERR(var))
+		return PTR_ERR(var);
+#ifdef GTP_RB
+	var = gtp_var_special_add(GTP_STEP_ID_ID, 0, 0,
+				  "step_id", &gtp_step_id_hooks);
+	if (IS_ERR(var))
+		return PTR_ERR(var);
+#endif
+
+	return 0;
+}
+
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,22)) \
+    || (RHEL_RELEASE_CODE != 0 && RHEL_RELEASE_CODE < RHEL_RELEASE_VERSION(5,6))
+#ifndef __HAVE_ARCH_STRCASECMP
+int strcasecmp(const char *s1, const char *s2)
+{
+	int c1, c2;
+
+	do {
+		c1 = tolower(*s1++);
+		c2 = tolower(*s2++);
+	} while (c1 == c2 && c1 != 0);
+	return c1 - c2;
+}
+#endif
+
+#ifndef __HAVE_ARCH_STRNCASECMP
+int strncasecmp(const char *s1, const char *s2, size_t n)
+{
+	int c1, c2;
+
+	do {
+		c1 = tolower(*s1++);
+		c2 = tolower(*s2++);
+	} while ((--n > 0) && c1 == c2 && c1 != 0);
+	return c1 - c2;
+}
+#endif
+#endif
+
+struct gtp_realloc_s {
+	char	*buf;
+	size_t	size;
+	size_t	real_size;
+};
+
+static int
+gtp_realloc_alloc(struct gtp_realloc_s *grs, size_t size)
+{
+	if (size) {
+		grs->buf = vmalloc(size);
+		if (!grs->buf)
+			return -ENOMEM;
+	} else
+		grs->buf = NULL;
+
+	grs->size = 0;
+	grs->real_size = size;
+
+	return 0;
+}
+
+static char *
+gtp_realloc(struct gtp_realloc_s *grs, size_t size, int is_end)
+{
+	char	*tmp;
+
+	if (unlikely((grs->real_size < grs->size + size)
+		     || (is_end && grs->real_size != grs->size + size))) {
+		grs->real_size = grs->size + size;
+		if (!is_end)
+			grs->real_size += 100;
+
+		tmp = vmalloc(grs->real_size);
+		if (!tmp) {
+			vfree(grs->buf);
+			memset(grs, 0, sizeof(struct gtp_realloc_s));
+			return NULL;
+		}
+
+		memcpy(tmp, grs->buf, grs->size);
+		if (grs->buf)
+			vfree(grs->buf);
+		grs->buf = tmp;
+	}
+
+	grs->size += size;
+	return grs->buf + grs->size - size;
+}
+
+static int
+gtp_realloc_str(struct gtp_realloc_s *grs, char *str, int is_end)
+{
+	char	*wbuf;
+	int	str_len = strlen(str);
+
+	wbuf = gtp_realloc(grs, str_len, is_end);
+	if (wbuf == NULL)
+		return -ENOMEM;
+
+	memcpy(wbuf, str, str_len);
+
+	return 0;
+}
+
+static inline void
+gtp_realloc_reset(struct gtp_realloc_s *grs)
+{
+	grs->size = 0;
+}
+
+static inline int
+gtp_realloc_is_alloced(struct gtp_realloc_s *grs)
+{
+	return (grs->buf != NULL);
+}
+
+static inline int
+gtp_realloc_is_empty(struct gtp_realloc_s *grs)
+{
+	return (grs->size == 0);
+}
+
+static inline void
+gtp_realloc_sub_size(struct gtp_realloc_s *grs, size_t size)
+{
+	grs->size -= size;
+}
+
+#ifdef CONFIG_X86
+ULONGEST
+gtp_action_reg_read(struct gtp_trace_s *gts, int num)
+{
+	ULONGEST	ret;
+
+	switch (num) {
+#ifdef CONFIG_X86_32
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,25))
+	case 0:
+		ret = gts->regs->ax;
+		break;
+	case 1:
+		ret = gts->regs->cx;
+		break;
+	case 2:
+		ret = gts->regs->dx;
+		break;
+	case 3:
+		ret = gts->regs->bx;
+		break;
+	case 4:
+		ret = gts->x86_32_sp;
+		break;
+	case 5:
+		ret = gts->regs->bp;
+		break;
+	case 6:
+		ret = gts->regs->si;
+		break;
+	case 7:
+		ret = gts->regs->di;
+		break;
+	case 8:
+		if (GTP_X86_NEED_ADJUST_PC(gts))
+			ret = gts->regs->ip - 1;
+		else
+			ret = gts->regs->ip;
+		break;
+	case 9:
+		ret = gts->regs->flags;
+		break;
+	case 10:
+		ret = gts->regs->cs;
+		break;
+	case 11:
+		ret = gts->regs->ss;
+		break;
+	case 12:
+		ret = gts->regs->ds;
+		break;
+	case 13:
+		ret = gts->regs->es;
+		break;
+	case 14:
+		ret = gts->regs->fs;
+		break;
+	case 15:
+		ret = gts->regs->gs;
+		break;
+#else
+	case 0:
+		ret = gts->regs->eax;
+		break;
+	case 1:
+		ret = gts->regs->ecx;
+		break;
+	case 2:
+		ret = gts->regs->edx;
+		break;
+	case 3:
+		ret = gts->regs->ebx;
+		break;
+	case 4:
+		ret = gts->x86_32_sp;
+		break;
+	case 5:
+		ret = gts->regs->ebp;
+		break;
+	case 6:
+		ret = gts->regs->esi;
+		break;
+	case 7:
+		ret = gts->regs->edi;
+		break;
+	case 8:
+		if (GTP_X86_NEED_ADJUST_PC(gts))
+			ret = gts->regs->eip - 1;
+		else
+			ret = gts->regs->eip;
+		break;
+	case 9:
+		ret = gts->regs->eflags;
+		break;
+	case 10:
+		ret = gts->regs->xcs;
+		break;
+	case 11:
+		ret = gts->regs->xss;
+		break;
+	case 12:
+		ret = gts->regs->xds;
+		break;
+	case 13:
+		ret = gts->regs->xes;
+		break;
+	case 14:
+		/* ret = gts->regs->xfs; */
+		ret = 0;
+		break;
+	case 15:
+		/* ret = gts->regs->xgs; */
+		ret = 0;
+		break;
+#endif
+#else
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,25))
+	case 0:
+		ret = gts->regs->ax;
+		break;
+	case 1:
+		ret = gts->regs->bx;
+		break;
+	case 2:
+		ret = gts->regs->cx;
+		break;
+	case 3:
+		ret = gts->regs->dx;
+		break;
+	case 4:
+		ret = gts->regs->si;
+		break;
+	case 5:
+		ret = gts->regs->di;
+		break;
+	case 6:
+		ret = gts->regs->bp;
+		break;
+	case 7:
+		ret = gts->regs->sp;
+		break;
+	case 16:
+		if (GTP_X86_NEED_ADJUST_PC(gts))
+			ret = gts->regs->ip - 1;
+		else
+			ret = gts->regs->ip;
+		break;
+	case 17:
+		ret = gts->regs->flags;
+		break;
+#else
+	case 0:
+		ret = gts->regs->rax;
+		break;
+	case 1:
+		ret = gts->regs->rbx;
+		break;
+	case 2:
+		ret = gts->regs->rcx;
+		break;
+	case 3:
+		ret = gts->regs->rdx;
+		break;
+	case 4:
+		ret = gts->regs->rsi;
+		break;
+	case 5:
+		ret = gts->regs->rdi;
+		break;
+	case 6:
+		ret = gts->regs->rbp;
+		break;
+	case 7:
+		ret = gts->regs->rsp;
+		break;
+	case 16:
+		if (GTP_X86_NEED_ADJUST_PC(gts))
+			ret = gts->regs->rip - 1;
+		else
+			ret = gts->regs->rip;
+		break;
+	case 17:
+		ret = gts->regs->eflags;
+		break;
+#endif
+	case 8:
+		ret = gts->regs->r8;
+		break;
+	case 9:
+		ret = gts->regs->r9;
+		break;
+	case 10:
+		ret = gts->regs->r10;
+		break;
+	case 11:
+		ret = gts->regs->r11;
+		break;
+	case 12:
+		ret = gts->regs->r12;
+		break;
+	case 13:
+		ret = gts->regs->r13;
+		break;
+	case 14:
+		ret = gts->regs->r14;
+		break;
+	case 15:
+		ret = gts->regs->r15;
+		break;
+	case 18:
+		ret = gts->regs->cs;
+		break;
+	case 19:
+		ret = gts->regs->ss;
+		break;
+#endif
+	default:
+		ret = 0;
+		gts->tpe->reason = gtp_stop_access_wrong_reg;
+		break;
+	}
+
+	return ret;
+}
+EXPORT_SYMBOL(gtp_action_reg_read);
+
+static void
+gtp_regs2ascii(struct pt_regs *regs, char *buf)
+{
+#ifdef CONFIG_X86_32
+#ifdef GTP_DEBUG_V
+	printk(GTP_DEBUG_V "gtp_regs2ascii: ax = 0x%x\n",
+		(unsigned int) regs->ax);
+	printk(GTP_DEBUG_V "gtp_regs2ascii: cx = 0x%x\n",
+		(unsigned int) regs->cx);
+	printk(GTP_DEBUG_V "gtp_regs2ascii: dx = 0x%x\n",
+		(unsigned int) regs->dx);
+	printk(GTP_DEBUG_V "gtp_regs2ascii: bx = 0x%x\n",
+		(unsigned int) regs->bx);
+	printk(GTP_DEBUG_V "gtp_regs2ascii: sp = 0x%x\n",
+		(unsigned int) regs->sp);
+	printk(GTP_DEBUG_V "gtp_regs2ascii: bp = 0x%x\n",
+		(unsigned int) regs->bp);
+	printk(GTP_DEBUG_V "gtp_regs2ascii: si = 0x%x\n",
+		(unsigned int) regs->si);
+	printk(GTP_DEBUG_V "gtp_regs2ascii: di = 0x%x\n",
+		(unsigned int) regs->di);
+	printk(GTP_DEBUG_V "gtp_regs2ascii: ip = 0x%x\n",
+		(unsigned int) regs->ip);
+	printk(GTP_DEBUG_V "gtp_regs2ascii: flags = 0x%x\n",
+		(unsigned int) regs->flags);
+	printk(GTP_DEBUG_V "gtp_regs2ascii: cs = 0x%x\n",
+		(unsigned int) regs->cs);
+	printk(GTP_DEBUG_V "gtp_regs2ascii: ss = 0x%x\n",
+		(unsigned int) regs->ss);
+	printk(GTP_DEBUG_V "gtp_regs2ascii: ds = 0x%x\n",
+		(unsigned int) regs->ds);
+	printk(GTP_DEBUG_V "gtp_regs2ascii: es = 0x%x\n",
+		(unsigned int) regs->es);
+	printk(GTP_DEBUG_V "gtp_regs2ascii: fs = 0x%x\n",
+		(unsigned int) regs->fs);
+	printk(GTP_DEBUG_V "gtp_regs2ascii: gs = 0x%x\n",
+		(unsigned int) regs->gs);
+#endif
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,25))
+	sprintf(buf, "%08x", (unsigned int) swab32(regs->ax));
+	buf += 8;
+	sprintf(buf, "%08x", (unsigned int) swab32(regs->cx));
+	buf += 8;
+	sprintf(buf, "%08x", (unsigned int) swab32(regs->dx));
+	buf += 8;
+	sprintf(buf, "%08x", (unsigned int) swab32(regs->bx));
+	buf += 8;
+	sprintf(buf, "%08x", (unsigned int) swab32(regs->sp));
+	buf += 8;
+	sprintf(buf, "%08x", (unsigned int) swab32(regs->bp));
+	buf += 8;
+	sprintf(buf, "%08x", (unsigned int) swab32(regs->si));
+	buf += 8;
+	sprintf(buf, "%08x", (unsigned int) swab32(regs->di));
+	buf += 8;
+	sprintf(buf, "%08x", (unsigned int) swab32(regs->ip));
+	buf += 8;
+	sprintf(buf, "%08x", (unsigned int) swab32(regs->flags));
+	buf += 8;
+	sprintf(buf, "%08x", (unsigned int) swab32(regs->cs));
+	buf += 8;
+	sprintf(buf, "%08x", (unsigned int) swab32(regs->ss));
+	buf += 8;
+	sprintf(buf, "%08x", (unsigned int) swab32(regs->ds));
+	buf += 8;
+	sprintf(buf, "%08x", (unsigned int) swab32(regs->es));
+	buf += 8;
+	sprintf(buf, "%08x", (unsigned int) swab32(regs->fs));
+	buf += 8;
+	sprintf(buf, "%08x", (unsigned int) swab32(regs->gs));
+	buf += 8;
+#else
+	sprintf(buf, "%08x", (unsigned int) swab32(regs->eax));
+	buf += 8;
+	sprintf(buf, "%08x", (unsigned int) swab32(regs->ecx));
+	buf += 8;
+	sprintf(buf, "%08x", (unsigned int) swab32(regs->edx));
+	buf += 8;
+	sprintf(buf, "%08x", (unsigned int) swab32(regs->ebx));
+	buf += 8;
+	sprintf(buf, "%08x", (unsigned int) swab32(regs->esp));
+	buf += 8;
+	sprintf(buf, "%08x", (unsigned int) swab32(regs->ebp));
+	buf += 8;
+	sprintf(buf, "%08x", (unsigned int) swab32(regs->esi));
+	buf += 8;
+	sprintf(buf, "%08x", (unsigned int) swab32(regs->edi));
+	buf += 8;
+	sprintf(buf, "%08x", (unsigned int) swab32(regs->eip));
+	buf += 8;
+	sprintf(buf, "%08x", (unsigned int) swab32(regs->eflags));
+	buf += 8;
+	sprintf(buf, "%08x", (unsigned int) swab32(regs->xcs));
+	buf += 8;
+	sprintf(buf, "%08x", (unsigned int) swab32(regs->xss));
+	buf += 8;
+	sprintf(buf, "%08x", (unsigned int) swab32(regs->xds));
+	buf += 8;
+	sprintf(buf, "%08x", (unsigned int) swab32(regs->xes));
+	buf += 8;
+	/* sprintf(buf, "%08x", (unsigned int) swab32(regs->xfs)); */
+	sprintf(buf, "00000000");
+	buf += 8;
+	/* sprintf(buf, "%08x", (unsigned int) swab32(regs->xgs)); */
+	sprintf(buf, "00000000");
+	buf += 8;
+#endif
+#else
+#ifdef GTP_DEBUG_V
+	printk(GTP_DEBUG_V "gtp_regs2ascii: ax = 0x%lx\n", regs->ax);
+	printk(GTP_DEBUG_V "gtp_regs2ascii: bx = 0x%lx\n", regs->bx);
+	printk(GTP_DEBUG_V "gtp_regs2ascii: cx = 0x%lx\n", regs->cx);
+	printk(GTP_DEBUG_V "gtp_regs2ascii: dx = 0x%lx\n", regs->dx);
+	printk(GTP_DEBUG_V "gtp_regs2ascii: si = 0x%lx\n", regs->si);
+	printk(GTP_DEBUG_V "gtp_regs2ascii: di = 0x%lx\n", regs->di);
+	printk(GTP_DEBUG_V "gtp_regs2ascii: bp = 0x%lx\n", regs->bp);
+	printk(GTP_DEBUG_V "gtp_regs2ascii: sp = 0x%lx\n", regs->sp);
+	printk(GTP_DEBUG_V "gtp_regs2ascii: r8 = 0x%lx\n", regs->r8);
+	printk(GTP_DEBUG_V "gtp_regs2ascii: r9 = 0x%lx\n", regs->r9);
+	printk(GTP_DEBUG_V "gtp_regs2ascii: r10 = 0x%lx\n", regs->r10);
+	printk(GTP_DEBUG_V "gtp_regs2ascii: r11 = 0x%lx\n", regs->r11);
+	printk(GTP_DEBUG_V "gtp_regs2ascii: r12 = 0x%lx\n", regs->r12);
+	printk(GTP_DEBUG_V "gtp_regs2ascii: r13 = 0x%lx\n", regs->r13);
+	printk(GTP_DEBUG_V "gtp_regs2ascii: r14 = 0x%lx\n", regs->r14);
+	printk(GTP_DEBUG_V "gtp_regs2ascii: r15 = 0x%lx\n", regs->r15);
+	printk(GTP_DEBUG_V "gtp_regs2ascii: ip = 0x%lx\n", regs->ip);
+	printk(GTP_DEBUG_V "gtp_regs2ascii: flags = 0x%lx\n", regs->flags);
+	printk(GTP_DEBUG_V "gtp_regs2ascii: cs = 0x%lx\n", regs->cs);
+	printk(GTP_DEBUG_V "gtp_regs2ascii: ss = 0x%lx\n", regs->ss);
+#endif
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,25))
+	sprintf(buf, "%016lx", (unsigned long) swab64(regs->ax));
+	buf += 16;
+	sprintf(buf, "%016lx", (unsigned long) swab64(regs->bx));
+	buf += 16;
+	sprintf(buf, "%016lx", (unsigned long) swab64(regs->cx));
+	buf += 16;
+	sprintf(buf, "%016lx", (unsigned long) swab64(regs->dx));
+	buf += 16;
+	sprintf(buf, "%016lx", (unsigned long) swab64(regs->si));
+	buf += 16;
+	sprintf(buf, "%016lx", (unsigned long) swab64(regs->di));
+	buf += 16;
+	sprintf(buf, "%016lx", (unsigned long) swab64(regs->bp));
+	buf += 16;
+	sprintf(buf, "%016lx", (unsigned long) swab64(regs->sp));
+	buf += 16;
+#else
+	sprintf(buf, "%016lx", (unsigned long) swab64(regs->rax));
+	buf += 16;
+	sprintf(buf, "%016lx", (unsigned long) swab64(regs->rbx));
+	buf += 16;
+	sprintf(buf, "%016lx", (unsigned long) swab64(regs->rcx));
+	buf += 16;
+	sprintf(buf, "%016lx", (unsigned long) swab64(regs->rdx));
+	buf += 16;
+	sprintf(buf, "%016lx", (unsigned long) swab64(regs->rsi));
+	buf += 16;
+	sprintf(buf, "%016lx", (unsigned long) swab64(regs->rdi));
+	buf += 16;
+	sprintf(buf, "%016lx", (unsigned long) swab64(regs->rbp));
+	buf += 16;
+	sprintf(buf, "%016lx", (unsigned long) swab64(regs->rsp));
+	buf += 16;
+#endif
+	sprintf(buf, "%016lx", (unsigned long) swab64(regs->r8));
+	buf += 16;
+	sprintf(buf, "%016lx", (unsigned long) swab64(regs->r9));
+	buf += 16;
+	sprintf(buf, "%016lx", (unsigned long) swab64(regs->r10));
+	buf += 16;
+	sprintf(buf, "%016lx", (unsigned long) swab64(regs->r11));
+	buf += 16;
+	sprintf(buf, "%016lx", (unsigned long) swab64(regs->r12));
+	buf += 16;
+	sprintf(buf, "%016lx", (unsigned long) swab64(regs->r13));
+	buf += 16;
+	sprintf(buf, "%016lx", (unsigned long) swab64(regs->r14));
+	buf += 16;
+	sprintf(buf, "%016lx", (unsigned long) swab64(regs->r15));
+	buf += 16;
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,25))
+	sprintf(buf, "%016lx", (unsigned long) swab64(regs->ip));
+	buf += 16;
+	sprintf(buf, "%08x",
+		(unsigned int) swab32((unsigned int)regs->flags));
+	buf += 8;
+#else
+	sprintf(buf, "%016lx", (unsigned long) swab64(regs->rip));
+	buf += 16;
+	sprintf(buf, "%08x",
+		(unsigned int) swab32((unsigned int)regs->eflags));
+	buf += 8;
+#endif
+	sprintf(buf, "%08x",
+		(unsigned int) swab32((unsigned int)regs->cs));
+	buf += 8;
+	sprintf(buf, "%08x",
+		(unsigned int) swab32((unsigned int)regs->ss));
+	buf += 8;
+#endif
+}
+
+static void
+gtp_regs2bin(struct pt_regs *regs, char *buf)
+{
+#ifdef CONFIG_X86_32
+#ifdef GTP_DEBUG_V
+	printk(GTP_DEBUG_V "gtp_regs2ascii: ax = 0x%x\n",
+		(unsigned int) regs->ax);
+	printk(GTP_DEBUG_V "gtp_regs2ascii: cx = 0x%x\n",
+		(unsigned int) regs->cx);
+	printk(GTP_DEBUG_V "gtp_regs2ascii: dx = 0x%x\n",
+		(unsigned int) regs->dx);
+	printk(GTP_DEBUG_V "gtp_regs2ascii: bx = 0x%x\n",
+		(unsigned int) regs->bx);
+	printk(GTP_DEBUG_V "gtp_regs2ascii: sp = 0x%x\n",
+		(unsigned int) regs->sp);
+	printk(GTP_DEBUG_V "gtp_regs2ascii: bp = 0x%x\n",
+		(unsigned int) regs->bp);
+	printk(GTP_DEBUG_V "gtp_regs2ascii: si = 0x%x\n",
+		(unsigned int) regs->si);
+	printk(GTP_DEBUG_V "gtp_regs2ascii: di = 0x%x\n",
+		(unsigned int) regs->di);
+	printk(GTP_DEBUG_V "gtp_regs2ascii: ip = 0x%x\n",
+		(unsigned int) regs->ip);
+	printk(GTP_DEBUG_V "gtp_regs2ascii: flags = 0x%x\n",
+		(unsigned int) regs->flags);
+	printk(GTP_DEBUG_V "gtp_regs2ascii: cs = 0x%x\n",
+		(unsigned int) regs->cs);
+	printk(GTP_DEBUG_V "gtp_regs2ascii: ss = 0x%x\n",
+		(unsigned int) regs->ss);
+	printk(GTP_DEBUG_V "gtp_regs2ascii: ds = 0x%x\n",
+		(unsigned int) regs->ds);
+	printk(GTP_DEBUG_V "gtp_regs2ascii: es = 0x%x\n",
+		(unsigned int) regs->es);
+	printk(GTP_DEBUG_V "gtp_regs2ascii: fs = 0x%x\n",
+		(unsigned int) regs->fs);
+	printk(GTP_DEBUG_V "gtp_regs2ascii: gs = 0x%x\n",
+		(unsigned int) regs->gs);
+#endif
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,25))
+	memcpy(buf, &regs->ax, 4);
+	buf += 4;
+	memcpy(buf, &regs->cx, 4);
+	buf += 4;
+	memcpy(buf, &regs->dx, 4);
+	buf += 4;
+	memcpy(buf, &regs->bx, 4);
+	buf += 4;
+	memcpy(buf, &regs->sp, 4);
+	buf += 4;
+	memcpy(buf, &regs->bp, 4);
+	buf += 4;
+	memcpy(buf, &regs->si, 4);
+	buf += 4;
+	memcpy(buf, &regs->di, 4);
+	buf += 4;
+	memcpy(buf, &regs->ip, 4);
+	buf += 4;
+	memcpy(buf, &regs->flags, 4);
+	buf += 4;
+	memcpy(buf, &regs->cs, 4);
+	buf += 4;
+	memcpy(buf, &regs->ss, 4);
+	buf += 4;
+	memcpy(buf, &regs->ds, 4);
+	buf += 4;
+	memcpy(buf, &regs->es, 4);
+	buf += 4;
+	memcpy(buf, &regs->fs, 4);
+	buf += 4;
+	memcpy(buf, &regs->gs, 4);
+	buf += 4;
+#else
+	memcpy(buf, &regs->eax, 4);
+	buf += 4;
+	memcpy(buf, &regs->ecx, 4);
+	buf += 4;
+	memcpy(buf, &regs->edx, 4);
+	buf += 4;
+	memcpy(buf, &regs->ebx, 4);
+	buf += 4;
+	memcpy(buf, &regs->esp, 4);
+	buf += 4;
+	memcpy(buf, &regs->ebp, 4);
+	buf += 4;
+	memcpy(buf, &regs->esi, 4);
+	buf += 4;
+	memcpy(buf, &regs->edi, 4);
+	buf += 4;
+	memcpy(buf, &regs->eip, 4);
+	buf += 4;
+	memcpy(buf, &regs->eflags, 4);
+	buf += 4;
+	memcpy(buf, &regs->xcs, 4);
+	buf += 4;
+	memcpy(buf, &regs->xss, 4);
+	buf += 4;
+	memcpy(buf, &regs->xds, 4);
+	buf += 4;
+	memcpy(buf, &regs->xes, 4);
+	buf += 4;
+	/* memcpy(buf, &regs->xfs, 4); */
+	memset(buf, '\0', 4);
+	buf += 4;
+	/* memcpy(buf, &regs->xgs, 4); */
+	memset(buf, '\0', 4);
+	buf += 4;
+#endif
+#else
+#ifdef GTP_DEBUG_V
+	printk(GTP_DEBUG_V "gtp_regs2ascii: ax = 0x%lx\n", regs->ax);
+	printk(GTP_DEBUG_V "gtp_regs2ascii: bx = 0x%lx\n", regs->bx);
+	printk(GTP_DEBUG_V "gtp_regs2ascii: cx = 0x%lx\n", regs->cx);
+	printk(GTP_DEBUG_V "gtp_regs2ascii: dx = 0x%lx\n", regs->dx);
+	printk(GTP_DEBUG_V "gtp_regs2ascii: si = 0x%lx\n", regs->si);
+	printk(GTP_DEBUG_V "gtp_regs2ascii: di = 0x%lx\n", regs->di);
+	printk(GTP_DEBUG_V "gtp_regs2ascii: bp = 0x%lx\n", regs->bp);
+	printk(GTP_DEBUG_V "gtp_regs2ascii: sp = 0x%lx\n", regs->sp);
+	printk(GTP_DEBUG_V "gtp_regs2ascii: r8 = 0x%lx\n", regs->r8);
+	printk(GTP_DEBUG_V "gtp_regs2ascii: r9 = 0x%lx\n", regs->r9);
+	printk(GTP_DEBUG_V "gtp_regs2ascii: r10 = 0x%lx\n", regs->r10);
+	printk(GTP_DEBUG_V "gtp_regs2ascii: r11 = 0x%lx\n", regs->r11);
+	printk(GTP_DEBUG_V "gtp_regs2ascii: r12 = 0x%lx\n", regs->r12);
+	printk(GTP_DEBUG_V "gtp_regs2ascii: r13 = 0x%lx\n", regs->r13);
+	printk(GTP_DEBUG_V "gtp_regs2ascii: r14 = 0x%lx\n", regs->r14);
+	printk(GTP_DEBUG_V "gtp_regs2ascii: r15 = 0x%lx\n", regs->r15);
+	printk(GTP_DEBUG_V "gtp_regs2ascii: ip = 0x%lx\n", regs->ip);
+	printk(GTP_DEBUG_V "gtp_regs2ascii: flags = 0x%lx\n", regs->flags);
+	printk(GTP_DEBUG_V "gtp_regs2ascii: cs = 0x%lx\n", regs->cs);
+	printk(GTP_DEBUG_V "gtp_regs2ascii: ss = 0x%lx\n", regs->ss);
+#endif
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,25))
+	memcpy(buf, &regs->ax, 8);
+	buf += 8;
+	memcpy(buf, &regs->bx, 8);
+	buf += 8;
+	memcpy(buf, &regs->cx, 8);
+	buf += 8;
+	memcpy(buf, &regs->dx, 8);
+	buf += 8;
+	memcpy(buf, &regs->si, 8);
+	buf += 8;
+	memcpy(buf, &regs->di, 8);
+	buf += 8;
+	memcpy(buf, &regs->bp, 8);
+	buf += 8;
+	memcpy(buf, &regs->sp, 8);
+	buf += 8;
+#else
+	memcpy(buf, &regs->rax, 8);
+	buf += 8;
+	memcpy(buf, &regs->rbx, 8);
+	buf += 8;
+	memcpy(buf, &regs->rcx, 8);
+	buf += 8;
+	memcpy(buf, &regs->rdx, 8);
+	buf += 8;
+	memcpy(buf, &regs->rsi, 8);
+	buf += 8;
+	memcpy(buf, &regs->rdi, 8);
+	buf += 8;
+	memcpy(buf, &regs->rbp, 8);
+	buf += 8;
+	memcpy(buf, &regs->rsp, 8);
+	buf += 8;
+#endif
+	memcpy(buf, &regs->r8, 8);
+	buf += 8;
+	memcpy(buf, &regs->r9, 8);
+	buf += 8;
+	memcpy(buf, &regs->r10, 8);
+	buf += 8;
+	memcpy(buf, &regs->r11, 8);
+	buf += 8;
+	memcpy(buf, &regs->r12, 8);
+	buf += 8;
+	memcpy(buf, &regs->r13, 8);
+	buf += 8;
+	memcpy(buf, &regs->r14, 8);
+	buf += 8;
+	memcpy(buf, &regs->r15, 8);
+	buf += 8;
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,25))
+	memcpy(buf, &regs->ip, 8);
+	buf += 8;
+	memcpy(buf, &regs->flags, 4);
+	buf += 4;
+#else
+	memcpy(buf, &regs->rip, 8);
+	buf += 8;
+	memcpy(buf, &regs->eflags, 4);
+	buf += 4;
+#endif
+	memcpy(buf, &regs->cs, 4);
+	buf += 4;
+	memcpy(buf, &regs->ss, 4);
+	buf += 4;
+#endif
+}
+#endif
+
+#ifdef CONFIG_MIPS
+static ULONGEST
+gtp_action_reg_read(struct gtp_trace_s *gts, int num)
+{
+	ULONGEST	ret;
+
+	if (num > 90) {
+		/* GDB convert the reg number to a GDB
+		   [1 * gdbarch_num_regs .. 2 * gdbarch_num_regs) REGNUM
+		   in function mips_dwarf_dwarf2_ecoff_reg_to_regnum.  */
+		num -= 90;
+	}
+
+	if (num >= 0 && num <= 31) {
+		ret = gts->regs->regs[num];
+	} else {
+		switch (num) {
+		case 32:
+			ret = gts->regs->cp0_status;
+			break;
+		case 33:
+			ret = gts->regs->lo;
+			break;
+		case 34:
+			ret = gts->regs->hi;
+			break;
+		case 35:
+			ret = gts->regs->cp0_badvaddr;
+			break;
+		case 36:
+			ret = gts->regs->cp0_cause;
+			break;
+		case 37:
+			ret = gts->regs->cp0_epc;
+			break;
+		default:
+			ret = 0;
+			gts->tpe->reason = gtp_stop_access_wrong_reg;
+			break;
+		}
+	}
+
+	return ret;
+};
+EXPORT_SYMBOL(gtp_action_reg_read);
+
+static void
+gtp_regs2ascii(struct pt_regs *regs, char *buf)
+{
+#ifdef GTP_DEBUG_V
+	{
+		int	i;
+
+		for (i = 0; i < 32; i++)
+			printk(GTP_DEBUG_V "gtp_gdbrsp_g: r%d = 0x%lx\n", i,
+			       regs->regs[i]);
+	}
+	printk(GTP_DEBUG_V "gtp_gdbrsp_g: status = 0x%lx\n",
+	       regs->cp0_status);
+	printk(GTP_DEBUG_V "gtp_gdbrsp_g: lo = 0x%lx\n", regs->lo);
+	printk(GTP_DEBUG_V "gtp_gdbrsp_g: hi = 0x%lx\n", regs->hi);
+	printk(GTP_DEBUG_V "gtp_gdbrsp_g: badvaddr = 0x%lx\n",
+	       regs->cp0_badvaddr);
+	printk(GTP_DEBUG_V "gtp_gdbrsp_g: cause = 0x%lx\n", regs->cp0_cause);
+	printk(GTP_DEBUG_V "gtp_gdbrsp_g: pc = 0x%lx\n", regs->cp0_epc);
+#endif
+
+#ifdef CONFIG_32BIT
+#define OUTFORMAT	"%08lx"
+#define REGSIZE		8
+#ifdef __LITTLE_ENDIAN
+#define SWAB(a)		swab32(a)
+#else
+#define SWAB(a)		(a)
+#endif
+#else
+#define OUTFORMAT	"%016lx"
+#define REGSIZE		16
+#ifdef __LITTLE_ENDIAN
+#define SWAB(a)		swab64(a)
+#else
+#define SWAB(a)		(a)
+#endif
+#endif
+	{
+		int	i;
+
+		for (i = 0; i < 32; i++) {
+			sprintf(buf, OUTFORMAT,
+				 (unsigned long) SWAB(regs->regs[i]));
+			buf += REGSIZE;
+		}
+	}
+
+	sprintf(buf, OUTFORMAT,
+		 (unsigned long) SWAB(regs->cp0_status));
+	buf += REGSIZE;
+	sprintf(buf, OUTFORMAT,
+		 (unsigned long) SWAB(regs->lo));
+	buf += REGSIZE;
+	sprintf(buf, OUTFORMAT,
+		 (unsigned long) SWAB(regs->hi));
+	buf += REGSIZE;
+	sprintf(buf, OUTFORMAT,
+		 (unsigned long) SWAB(regs->cp0_badvaddr));
+	buf += REGSIZE;
+	sprintf(buf, OUTFORMAT,
+		 (unsigned long) SWAB(regs->cp0_cause));
+	buf += REGSIZE;
+	sprintf(buf, OUTFORMAT,
+		 (unsigned long) SWAB(regs->cp0_epc));
+	buf += REGSIZE;
+#undef OUTFORMAT
+#undef REGSIZE
+#undef SWAB
+}
+
+static void
+gtp_regs2bin(struct pt_regs *regs, char *buf)
+{
+#ifdef GTP_DEBUG_V
+	{
+		int	i;
+
+		for (i = 0; i < 32; i++)
+			printk(GTP_DEBUG_V "gtp_gdbrsp_g: r%d = 0x%lx\n", i,
+			       regs->regs[i]);
+	}
+	printk(GTP_DEBUG_V "gtp_gdbrsp_g: status = 0x%lx\n",
+	       regs->cp0_status);
+	printk(GTP_DEBUG_V "gtp_gdbrsp_g: lo = 0x%lx\n", regs->lo);
+	printk(GTP_DEBUG_V "gtp_gdbrsp_g: hi = 0x%lx\n", regs->hi);
+	printk(GTP_DEBUG_V "gtp_gdbrsp_g: badvaddr = 0x%lx\n",
+	       regs->cp0_badvaddr);
+	printk(GTP_DEBUG_V "gtp_gdbrsp_g: cause = 0x%lx\n", regs->cp0_cause);
+	printk(GTP_DEBUG_V "gtp_gdbrsp_g: pc = 0x%lx\n", regs->cp0_epc);
+#endif
+
+#ifdef CONFIG_32BIT
+#define REGSIZE		4
+#else
+#define REGSIZE		8
+#endif
+	{
+		int	i;
+
+		for (i = 0; i < 32; i++) {
+			memcpy(buf, &regs->regs[i], REGSIZE);
+			buf += REGSIZE;
+		}
+	}
+	memcpy(buf, &regs->cp0_status, REGSIZE);
+	buf += REGSIZE;
+	memcpy(buf, &regs->lo, REGSIZE);
+	buf += REGSIZE;
+	memcpy(buf, &regs->hi, REGSIZE);
+	buf += REGSIZE;
+	memcpy(buf, &regs->cp0_badvaddr, REGSIZE);
+	buf += REGSIZE;
+	memcpy(buf, &regs->cp0_cause, REGSIZE);
+	buf += REGSIZE;
+	memcpy(buf, &regs->cp0_epc, REGSIZE);
+	buf += REGSIZE;
+#undef REGSIZE
+}
+#endif
+
+#ifdef CONFIG_ARM
+ULONGEST
+gtp_action_reg_read(struct gtp_trace_s *gts, int num)
+{
+	if (num >= 0 && num < 16)
+		return gts->regs->uregs[num];
+	else if (num == 25)
+		return gts->regs->uregs[16];
+
+	gts->tpe->reason = gtp_stop_access_wrong_reg;
+	return 0;
+}
+EXPORT_SYMBOL(gtp_action_reg_read);
+
+static void
+gtp_regs2ascii(struct pt_regs *regs, char *buf)
+{
+#ifdef __LITTLE_ENDIAN
+#define SWAB(a)		swab32(a)
+#else
+#define SWAB(a)		(a)
+#endif
+	int	i;
+
+	for (i = 0; i < 16; i++) {
+#ifdef GTP_DEBUG_V
+		printk(GTP_DEBUG_V "gtp_gdbrsp_g: r%d = 0x%lx\n",
+		       i, regs->uregs[i]);
+#endif
+		sprintf(buf, "%08lx", (unsigned long) SWAB(regs->uregs[i]));
+		buf += 8;
+	}
+
+	/* f0-f7 fps */
+	memset(buf, '0', 200);
+	buf += 200;
+
+#ifdef GTP_DEBUG_V
+	printk(GTP_DEBUG_V "gtp_gdbrsp_g: cpsr = 0x%lx\n", regs->uregs[16]);
+#endif
+	sprintf(buf, "%08lx",
+		 (unsigned long) SWAB(regs->uregs[16]));
+	buf += 8;
+#undef SWAB
+}
+
+static void
+gtp_regs2bin(struct pt_regs *regs, char *buf)
+{
+	int	i;
+
+	for (i = 0; i < 16; i++) {
+#ifdef GTP_DEBUG_V
+		printk(GTP_DEBUG_V "gtp_gdbrsp_g: r%d = 0x%lx\n",
+		       i, regs->uregs[i]);
+#endif
+		memcpy(buf, &regs->uregs[i], 4);
+		buf += 4;
+	}
+
+	/* f0-f7 fps */
+	memset(buf, '\0', 100);
+	buf += 100;
+
+#ifdef GTP_DEBUG_V
+	printk(GTP_DEBUG_V "gtp_gdbrsp_g: cpsr = 0x%lx\n", regs->uregs[16]);
+#endif
+	memcpy(buf, &regs->uregs[16], 4);
+	buf += 4;
+}
+#endif
+
+#ifdef GTP_PERF_EVENTS
+#if KGTP_API_VERSION_LOCAL < 20120808
+#include "perf_event.c"
+#endif
+
+static DEFINE_PER_CPU(int, pc_pe_list_all_disabled);
+static DEFINE_PER_CPU(struct gtp_var_perf_event *, pc_pe_list);
+
+static void
+pc_pe_list_disable(void)
+{
+	struct gtp_var_perf_event *ppl;
+
+	if (__get_cpu_var(pc_pe_list_all_disabled))
+		return;
+
+	for (ppl = __get_cpu_var(pc_pe_list); ppl; ppl = ppl->pc_next) {
+		if (ppl->en)
+#if (KGTP_API_VERSION_LOCAL < 20120808)
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(3,3,0))
+			__gtp_perf_event_disable(ppl->event);
+#else
+			perf_event_disable(ppl->event);
+#endif
+#else
+			local_perf_event_disable(ppl->event);
+#endif
+	}
+}
+
+static void
+pc_pe_list_enable(void)
+{
+	struct gtp_var_perf_event *ppl;
+
+	if (__get_cpu_var(pc_pe_list_all_disabled))
+		return;
+
+	for (ppl = __get_cpu_var(pc_pe_list); ppl; ppl = ppl->pc_next) {
+		if (ppl->en)
+#if (KGTP_API_VERSION_LOCAL < 20120808)
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(3,3,0))
+			__gtp_perf_event_enable(ppl->event);
+#else
+			perf_event_enable(ppl->event);
+#endif
+#else
+			local_perf_event_enable(ppl->event);
+#endif
+	}
+}
+
+static void
+gtp_pc_pe_en(int enable)
+{
+	struct gtp_var_perf_event *ppl = __get_cpu_var(pc_pe_list);
+
+	for (ppl = __get_cpu_var(pc_pe_list); ppl; ppl = ppl->pc_next)
+		ppl->en = enable;
+
+	__get_cpu_var(pc_pe_list_all_disabled) = !enable;
+}
+
+static void
+gtp_pe_set_en(struct gtp_var_perf_event *pts, int enable)
+{
+	if (pts->event->cpu != smp_processor_id()) {
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(3,3,0)	\
+     && KGTP_API_VERSION_LOCAL < 20120808)
+		if (enable)
+			gtp_perf_event_enable(pts->event);
+		else
+			gtp_perf_event_disable(pts->event);
+#else
+		if (enable)
+			perf_event_enable(pts->event);
+		else
+			perf_event_disable(pts->event);
+#endif
+	}
+	pts->en = enable;
+}
+#else
+static void
+gtp_pc_pe_en(int enable)
+{
+}
+#endif	/* GTP_PERF_EVENTS */
+
+/* Following part is for gtp_task_read.  */
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(3,0,0))
+static inline int is_cow_mapping(unsigned int flags)
+#else
+static inline int is_cow_mapping(vm_flags_t flags)
+#endif
+{
+	return (flags & (VM_SHARED | VM_MAYWRITE)) == VM_MAYWRITE;
+}
+
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,26))
+#ifdef __HAVE_ARCH_PTE_SPECIAL
+# define HAVE_PTE_SPECIAL 1
+#else
+# define HAVE_PTE_SPECIAL 0
+#endif
+#endif
+struct page *
+gtp_vm_normal_page(struct vm_area_struct *vma, unsigned long addr,
+				pte_t pte)
+{
+	unsigned long pfn = pte_pfn(pte);
+
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,26))
+	if (HAVE_PTE_SPECIAL) {
+		if (likely(!pte_special(pte)))
+			goto check_pfn;
+		/* XXX: not support is_zero_pfn.  */
+
+		return NULL;
+	}
+#endif
+
+	/* !HAVE_PTE_SPECIAL case follows: */
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,26))
+	if (unlikely(vma->vm_flags & (VM_PFNMAP|VM_MIXEDMAP))) {
+#else
+	if (unlikely(vma->vm_flags & (VM_PFNMAP))) {
+#endif
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,26))
+		if (vma->vm_flags & VM_MIXEDMAP) {
+			if (!pfn_valid(pfn))
+				return NULL;
+			goto out;
+		} else {
+#endif
+			unsigned long off;
+			off = (addr - vma->vm_start) >> PAGE_SHIFT;
+			if (pfn == vma->vm_pgoff + off)
+				return NULL;
+			if (!is_cow_mapping(vma->vm_flags))
+				return NULL;
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,26))
+		}
+#endif
+	}
+
+	/* XXX: is_zero_pfn is not support.
+	if (is_zero_pfn(pfn))
+		return NULL;
+	*/
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,26))
+check_pfn:
+#endif
+	/* XXX: highest_memmap_pfn is not support.
+	if (unlikely(pfn > highest_memmap_pfn)) {
+		print_bad_pte(vma, addr, pte, NULL);
+		return NULL;
+	}
+	*/
+
+	/*
+	 * NOTE! We still have PageReserved() pages in the page tables.
+	 * eg. VDSO mappings can cause them to exist.
+	 */
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,26))
+out:
+#endif
+	return pfn_to_page(pfn);
+}
+
+/* Example: follow_page */
+
+struct page *
+gtp_follow_page(struct vm_area_struct *vma, unsigned long address,
+		unsigned int flags)
+{
+	pgd_t *pgd;
+	pud_t *pud;
+	pmd_t *pmd;
+	pte_t *ptep, pte;
+	spinlock_t *ptl;
+	struct page *page;
+	struct mm_struct *mm = vma->vm_mm;
+
+	/* XXX: not support follow_huge_addr.  */
+
+	page = NULL;
+	pgd = pgd_offset(mm, address);
+	if (pgd_none(*pgd) || unlikely(pgd_bad(*pgd)))
+		goto no_page_table;
+
+	pud = pud_offset(pgd, address);
+	if (pud_none(*pud))
+		goto no_page_table;
+
+	/* XXX: not support pud_huge. */
+
+	if (unlikely(pud_bad(*pud)))
+		goto no_page_table;
+
+	pmd = pmd_offset(pud, address);
+	if (pmd_none(*pmd))
+		goto no_page_table;
+
+	/* XXX: not support pmd_huge. */
+
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,38))
+	if (unlikely(pmd_bad(*pmd)))
+		goto no_page_table;
+#else
+	if (pmd_trans_huge(*pmd)) {
+		/* XXX: not support wait_split_huge_page.  */
+		goto no_page_table;
+	}
+#endif
+
+	if (unlikely(pmd_bad(*pmd)))
+		goto no_page_table;
+
+	ptep = pte_offset_map_lock(mm, pmd, address, &ptl);
+
+	pte = *ptep;
+	if (!pte_present(pte))
+		goto no_page;
+	if ((flags & FOLL_WRITE) && !pte_write(pte))
+		goto unlock;
+
+	page = gtp_vm_normal_page(vma, address, pte);
+	if (unlikely(!page)) {
+		/* XXX: not support is_zero_pfn.  */
+		goto bad_page;
+	}
+
+	if (flags & FOLL_GET) {
+		/* XXX: not support get_page_foll(page) */
+		get_page(page);
+	}
+unlock:
+	pte_unmap_unlock(ptep, ptl);
+	return page;
+
+bad_page:
+	pte_unmap_unlock(ptep, ptl);
+	return ERR_PTR(-EFAULT);
+
+no_page:
+	pte_unmap_unlock(ptep, ptl);
+	if (!pte_none(pte))
+		return page;
+
+no_page_table:
+	return page;
+}
+
+/* Example: __get_user_pages */
+
+static int
+gtp_get_user_page(struct mm_struct *mm, unsigned long start,
+		  struct page **pages, struct vm_area_struct **vmas)
+{
+	struct vm_area_struct	*vma;
+	struct page		*page;
+
+	/* XXX: not use find_extend_vma because cannot get
+	   find_vma_prev and expand_stack.  */
+	vma = find_vma(mm, start);
+	if (vma == NULL || vma->vm_flags & VM_LOCKED)
+		return 0;
+
+	/* XXX: not use get_gate_vma because not support vm_normal_page. */
+	if (!vma ||
+		    (vma->vm_flags & (VM_IO | VM_PFNMAP)) ||
+		    !(VM_MAYREAD & vma->vm_flags))
+			return -EFAULT;
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,36))
+	if (is_vm_hugetlb_page(vma)) {
+		/* XXX: not support follow_hugetlb_page.  */
+		return 0;
+	}
+#endif
+	page = gtp_follow_page(vma, start, FOLL_GET);
+	if (IS_ERR(page))
+		return PTR_ERR(page);
+	if (pages) {
+		pages[0] = page;
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2,6,19))
+#if defined(CONFIG_ARM) && (KGTP_API_VERSION_LOCAL < 20120917)
+		printk(KERN_WARNING "You use KGTP $current but your Kernel "
+				    "doesn't support flush_anon_page.  "
+				    "If you want use it, "
+				    "please patch the patch of KGTP "
+				    "(http://code.google.com/p/kgtp/wiki/HOWTO#Use_KGTP_patch_for_Linux_kernel).\n");
+#else
+		flush_anon_page(vma, page, start);
+#endif
+#else
+		flush_anon_page(page, start);
+#endif
+		flush_dcache_page(page);
+	}
+	if (vmas)
+		vmas[0] = vma;
+
+	return 1;
+}
+
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,39))
+static struct task_struct	gtp_fake_task;
+#ifdef CONFIG_IA32_EMULATION
+static struct thread_info	gtp_fake_thread;
+#endif
+#endif
+
+/* Example: access_remote_vm */
+
+static int
+gtp_task_read(pid_t pid, struct task_struct *tsk, unsigned long addr,
+	      void *buf, int len, int in_kprobe_handler)
+{
+	int			ret = -ESRCH;
+	struct mm_struct	*mm;
+	struct vm_area_struct	*vma;
+	void			*old_buf = buf;
+
+	if (in_kprobe_handler) {
+		/* The tsk cannot be NULL.  */
+		/* get_task_mm */
+		ret = -ENXIO;
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,27))
+		if (tsk->flags & PF_KTHREAD)
+#else
+		if (tsk->flags & PF_BORROWED_MM)
+#endif
+			return ret;
+		task_lock(tsk);
+		mm = tsk->mm;
+	} else {
+		/* Example: ptrace_get_task_struct
+		issue 131: For the Linux kernel 2.6.23 and older version,
+		it should use read_lock(&tasklist_lock) and
+		read_unlock(&tasklist_lock).
+		But tasklist_lock is not exported.
+		And find_task_by_pid use RCU.  So use rcu_read_lock and
+		rcu_read_unlock to handle it.  */
+		ret = -ESRCH;
+		rcu_read_lock();
+		if (!tsk) {
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,24))
+			tsk = pid_task(find_vpid(pid), PIDTYPE_PID);
+#else
+			tsk = find_task_by_pid(pid);
+#endif
+			if (!tsk) {
+				rcu_read_unlock();
+				return ret;
+			}
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,39))
+#ifdef CONFIG_IA32_EMULATION
+			/* This part for get_gate_vma.  */
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,22))
+#ifndef __HAVE_THREAD_FUNCTIONS
+			gtp_fake_task.thread_info = &gtp_fake_thread;
+#else
+			task_stack_page(&gtp_fake_task) = &gtp_fake_thread;
+#endif
+#else
+			task_stack_page(&gtp_fake_task) = &gtp_fake_thread;
+#endif
+			task_thread_info(&gtp_fake_task)->flags = task_thread_info(tsk)->flags;
+#endif
+#endif
+		}
+		mm = get_task_mm(tsk);
+		rcu_read_unlock();
+	}
+	if (!mm)
+		goto out;
+
+	if (in_kprobe_handler) {
+		if (!down_read_trylock(&mm->mmap_sem))
+			goto out;
+	} else
+		down_read(&mm->mmap_sem);
+
+	while (len) {
+		int bytes, offset;
+		void *maddr;
+		struct page *page = NULL;
+
+		if (in_kprobe_handler)
+			ret = gtp_get_user_page(mm, addr, &page, &vma);
+		else {
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,39))
+			ret = get_user_pages(&gtp_fake_task, mm, addr, 1, 0, 1, &page,
+				     &vma);
+#else
+			ret = get_user_pages(NULL, mm, addr, 1, 0, 1, &page, &vma);
+#endif
+		}
+		if (ret <= 0) {
+			/*
+			 * Check if this is a VM_IO | VM_PFNMAP VMA, which
+			 * we can access using slightly different code.
+			 */
+#ifdef CONFIG_HAVE_IOREMAP_PROT
+			vma = find_vma(mm, addr);
+			if (!vma || vma->vm_start > addr)
+				break;
+			if (vma->vm_ops && vma->vm_ops->access)
+				ret = vma->vm_ops->access(vma, addr, buf,
+							  len, 0);
+			if (ret <= 0)
+#endif
+				break;
+			bytes = ret;
+		} else {
+			bytes = len;
+			offset = addr & (PAGE_SIZE-1);
+			if (bytes > PAGE_SIZE-offset)
+				bytes = PAGE_SIZE-offset;
+
+			if (in_kprobe_handler)
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 0, 0))
+				maddr = kmap_atomic(page);
+#else
+				maddr = kmap_atomic(page, KM_IRQ1);
+#endif
+			else
+				maddr = kmap(page);
+			copy_from_user_page(vma, page, addr,
+					    buf, maddr + offset, bytes);
+			if (in_kprobe_handler)
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 0, 0))
+				kunmap_atomic(maddr);
+#else
+				kunmap_atomic(maddr, KM_IRQ1);
+#endif
+			else
+				kunmap(page);
+			page_cache_release(page);
+		}
+		len -= bytes;
+		buf += bytes;
+		addr += bytes;
+	}
+	ret = buf - old_buf;
+
+	up_read(&mm->mmap_sem);
+	if (!in_kprobe_handler)
+		mmput(mm);
+out:
+	if (in_kprobe_handler)
+		task_unlock(tsk);
+	return ret;
+}
+
+static long
+gtp_task_handler_read(void *dst, void *src, size_t size)
+{
+	if (gtp_task_read(0, get_current(),
+			  (unsigned long)src, dst, size, 1) != size)
+		return -EFAULT;
+
+	return 0;
+}
+
+#ifdef GTP_FRAME_SIMPLE
+static char *
+gtp_frame_next(char *frame)
+{
+	switch (FID(frame)) {
+	case FID_HEAD:
+		frame += FRAME_ALIGN(GTP_FRAME_HEAD_SIZE);
+		break;
+	case FID_REG:
+		frame += FRAME_ALIGN(GTP_FRAME_REG_SIZE);
+		break;
+	case FID_MEM: {
+			struct gtp_frame_mem	*gfm;
+
+			gfm = (struct gtp_frame_mem *) (frame + FID_SIZE
+							+ sizeof(char *));
+			frame += FRAME_ALIGN(GTP_FRAME_MEM_SIZE + gfm->size);
+		}
+		break;
+	case FID_VAR:
+		frame += FRAME_ALIGN(GTP_FRAME_VAR_SIZE);
+		break;
+	case FID_END:
+		frame = gtp_frame_end;
+		break;
+	default:
+		return NULL;
+		break;
+	}
+
+	return frame;
+}
+#endif
+
+#ifdef GTP_FRAME_SIMPLE
+#ifdef FRAME_ALLOC_RECORD
+ULONGEST	frame_alloc_size;
+ULONGEST	frame_alloc_size_hole;
+#endif
+
+static char *
+gtp_frame_alloc(size_t size)
+{
+	char	*ret = NULL;
+
+#ifdef FRAME_ALLOC_RECORD
+	frame_alloc_size += size;
+	frame_alloc_size_hole += (FRAME_ALIGN(size) - size);
+#endif
+
+	size = FRAME_ALIGN(size);
+
+	if (size > GTP_FRAME_SIZE)
+		return NULL;
+
+	spin_lock(&gtp_frame_lock);
+
+	if (gtp_frame_w_start + size > gtp_frame_end) {
+		if (gtp_circular) {
+			gtp_frame_is_circular = 1;
+#ifdef FRAME_ALLOC_RECORD
+			if (gtp_frame_w_start != gtp_frame_end
+			    && gtp_frame_end - gtp_frame_w_start < FID_SIZE) {
+				printk(KERN_WARNING "Frame align wrong."
+						    "start = %p end = %p\n",
+				       gtp_frame_w_start, gtp_frame_end);
+				goto out;
+			}
+#endif
+			if (gtp_frame_w_start != gtp_frame_end)
+				FID(gtp_frame_w_start) = FID_END;
+			gtp_frame_w_start = gtp_frame;
+			gtp_frame_r_start = gtp_frame;
+		} else
+			goto out;
+	}
+
+	if (gtp_frame_is_circular) {
+		while (gtp_frame_w_start <= gtp_frame_r_start
+		       && gtp_frame_w_start + size > gtp_frame_r_start) {
+			char *tmp = gtp_frame_next(gtp_frame_r_start);
+			if (tmp == NULL)
+				goto out;
+			if (tmp == gtp_frame_end)
+				gtp_frame_r_start = gtp_frame;
+			else
+				gtp_frame_r_start = tmp;
+		}
+	}
+
+	ret = gtp_frame_w_start;
+	gtp_frame_w_start += size;
+
+out:
+	spin_unlock(&gtp_frame_lock);
+	return ret;
+}
+#endif
+
+#define GTP_PRINTK_FORMAT_A	0
+#define GTP_PRINTK_FORMAT_D	1
+#define GTP_PRINTK_FORMAT_U	2
+#define GTP_PRINTK_FORMAT_X	3
+#define GTP_PRINTK_FORMAT_S	4
+#define GTP_PRINTK_FORMAT_B	5
+
+#ifdef GTP_FTRACE_RING_BUFFER
+#define GTP_FRAME_RINGBUFFER_ALLOC(size)				\
+	do {								\
+		rbe = ring_buffer_lock_reserve(gtp_frame, size);	\
+		if (rbe == NULL) {					\
+			gts->tpe->reason = gtp_stop_frame_full;		\
+			return -1;					\
+		}							\
+		tmp = ring_buffer_event_data(rbe);			\
+	} while (0)
+#endif
+
+static int	gtp_collect_var(struct gtp_trace_s *gts, int num);
+#ifdef GTP_RB
+static int	gtp_var_array_step_id_id = 0;
+#endif
+
+static int
+gtp_action_head(struct gtp_trace_s *gts)
+{
+	char				*tmp;
+	ULONGEST			*trace_nump;
+#ifdef GTP_FTRACE_RING_BUFFER
+	struct ring_buffer_event	*rbe;
+#endif
+
+#ifdef GTP_RB
+	gts->next = (struct gtp_rb_s *)this_cpu_ptr(gtp_rb);
+#endif
+
+	/* Get the head.  */
+#ifdef GTP_FTRACE_RING_BUFFER
+	GTP_FRAME_RINGBUFFER_ALLOC(GTP_FRAME_HEAD_SIZE);
+#endif
+#if defined(GTP_FRAME_SIMPLE) || defined(GTP_RB)
+#ifdef GTP_RB
+	GTP_RB_LOCK(gts->next);
+	tmp = gtp_rb_alloc(gts->next, GTP_FRAME_HEAD_SIZE, 0);
+#endif
+#ifdef GTP_FRAME_SIMPLE
+	tmp = gtp_frame_alloc(GTP_FRAME_HEAD_SIZE);
+#endif
+	if (!tmp) {
+		gts->tpe->reason = gtp_stop_frame_full;
+		return -1;
+	}
+#endif
+
+	FID(tmp) = FID_HEAD;
+	tmp += FID_SIZE;
+
+#ifdef GTP_RB
+	gts->id = gtp_rb_clock();
+	*(u64 *)tmp = gts->id;
+	tmp += sizeof(u64);
+#endif
+
+#ifdef GTP_FRAME_SIMPLE
+	gts->next = (char **)tmp;
+	*(gts->next) = NULL;
+	tmp += sizeof(char *);
+#endif
+
+	trace_nump = (ULONGEST *)tmp;
+	*trace_nump = gts->tpe->num;
+	tmp += sizeof(ULONGEST);
+
+#ifdef GTP_RB
+	*(void **)tmp = gtp_rb_prev_frame_get(gts->next);
+	gtp_rb_prev_frame_set(gts->next, (void *)(tmp + sizeof(void *)
+					          - GTP_FRAME_HEAD_SIZE));
+#endif
+
+#ifdef GTP_FTRACE_RING_BUFFER
+	ring_buffer_unlock_commit(gtp_frame, rbe);
+	gts->next = (char *)1;
+#endif
+
+	atomic_inc(&gtp_frame_create);
+
+#ifdef GTP_RB
+	/* Auto collect $step_id.  */
+	if (gts->tpe->step) {
+		if (gtp_collect_var(gts, gtp_var_array_step_id_id))
+			return -1;
+	}
+#endif
+
+	return 0;
+}
+
+static int
+gtp_action_printk(struct gtp_trace_s *gts, ULONGEST addr, size_t size)
+{
+	unsigned int	printk_format = gts->printk_format;
+	char		*pbuf = __get_cpu_var(gtp_printf);
+
+	if (gts->printk_str == NULL) {
+		gts->tpe->reason = gtp_stop_agent_expr_code_error;
+		printk(KERN_WARNING "gtp_action_printk: id:%d addr:%p "
+				    "printk doesn't have var name.  Please "
+				    "check actions of it.\n",
+			(int)gts->tpe->num, (void *)(CORE_ADDR)gts->tpe->addr);
+		return -1;
+	}
+
+	if (size) {
+		if (size > GTP_PRINTF_MAX - 1)
+			size = GTP_PRINTF_MAX - 1;
+		if (gts->printk_format != GTP_PRINTK_FORMAT_S
+		    && gts->printk_format != GTP_PRINTK_FORMAT_B
+		    && size > 8)
+			size = 8;
+		if (gts->read_memory(pbuf, (void *)(CORE_ADDR)addr, size)) {
+			gts->tpe->reason = gtp_stop_efault;
+			printk(KERN_WARNING "gtp_action_printk: id:%d addr:%p "
+					    "read %p %u get error.\n",
+			       (int)gts->tpe->num,
+			       (void *)(CORE_ADDR)gts->tpe->addr,
+			       (void *)(CORE_ADDR)addr,
+			       (unsigned int)size);
+			return -1;
+		}
+	} else {
+		size = sizeof(ULONGEST);
+		memcpy(pbuf, &addr, sizeof(ULONGEST));
+	}
+
+	if (printk_format == GTP_PRINTK_FORMAT_A) {
+		if (size == 1 || size == 2 || size == 4 || size == 8)
+			printk_format = GTP_PRINTK_FORMAT_U;
+		else
+			printk_format = GTP_PRINTK_FORMAT_B;
+	}
+
+	switch (printk_format) {
+	case GTP_PRINTK_FORMAT_D:
+		switch (size) {
+		case 1:
+			printk(KERN_NULL "<%d>CPU%d %s%d\n",
+			       gts->printk_level, smp_processor_id(),
+			       gts->printk_str->src, pbuf[0]);
+			break;
+		case 2:
+			printk(KERN_NULL "<%d>CPU%d %s%d\n",
+			       gts->printk_level, smp_processor_id(),
+			       gts->printk_str->src,
+			       (int)(*(short *)pbuf));
+			break;
+		case 4:
+			printk(KERN_NULL "<%d>CPU%d %s%d\n",
+			       gts->printk_level, smp_processor_id(),
+			       gts->printk_str->src, *(int *)pbuf);
+			break;
+		case 8:
+			printk(KERN_NULL "<%d>CPU%d %s%lld\n",
+			       gts->printk_level, smp_processor_id(),
+			       gts->printk_str->src, *(long long *)pbuf);
+			break;
+		default:
+			printk(KERN_WARNING "gtp_action_printk: id:%d addr:%p "
+					    "size %d cannot printk.\n",
+			       (int)gts->tpe->num,
+			       (void *)(CORE_ADDR)gts->tpe->addr,
+			       (unsigned int)size);
+			gts->tpe->reason = gtp_stop_agent_expr_code_error;
+			return -1;
+			break;
+		}
+		break;
+	case GTP_PRINTK_FORMAT_U:
+		switch (size) {
+		case 1:
+			printk(KERN_NULL "<%d>CPU%d %s%u\n",
+			       gts->printk_level, smp_processor_id(),
+			       gts->printk_str->src, pbuf[0]);
+			break;
+		case 2:
+			printk(KERN_NULL "<%d>CPU%d %s%u\n",
+			       gts->printk_level, smp_processor_id(),
+			       gts->printk_str->src, (int)(*(short *)pbuf));
+			break;
+		case 4:
+			printk(KERN_NULL "<%d>CPU%d %s%u\n",
+			       gts->printk_level, smp_processor_id(),
+			       gts->printk_str->src, *(int *)pbuf);
+			break;
+		case 8:
+			printk(KERN_NULL "<%d>CPU%d %s%llu\n",
+			       gts->printk_level, smp_processor_id(),
+			       gts->printk_str->src, *(long long *)pbuf);
+			break;
+		default:
+			printk(KERN_WARNING "gtp_action_printk: id:%d addr:%p"
+					    "size %d cannot printk.\n",
+			       (int)gts->tpe->num,
+			       (void *)(CORE_ADDR)gts->tpe->addr,
+			       (unsigned int)size);
+			gts->tpe->reason = gtp_stop_agent_expr_code_error;
+			return -1;
+			break;
+		}
+		break;
+	case GTP_PRINTK_FORMAT_X:
+		switch (size) {
+		case 1:
+			printk(KERN_NULL "<%d>CPU%d %s0x%x\n",
+			       gts->printk_level, smp_processor_id(),
+			       gts->printk_str->src, pbuf[0]);
+			break;
+		case 2:
+			printk(KERN_NULL "<%d>CPU%d %s0x%x\n",
+			       gts->printk_level, smp_processor_id(),
+			       gts->printk_str->src, (int)(*(short *)pbuf));
+			break;
+		case 4:
+			printk(KERN_NULL "<%d>CPU%d %s0x%x\n",
+			       gts->printk_level, smp_processor_id(),
+			       gts->printk_str->src, *(int *)pbuf);
+			break;
+		case 8:
+			printk(KERN_NULL "<%d>CPU%d %s0x%llx\n",
+			       gts->printk_level, smp_processor_id(),
+			       gts->printk_str->src, *(long long *)pbuf);
+			break;
+		default:
+			printk(KERN_WARNING "gtp_action_printk: id:%d addr:%p "
+					    "size %d cannot printk.\n",
+			       (int)gts->tpe->num,
+			       (void *)(CORE_ADDR)gts->tpe->addr,
+			       (unsigned int)size);
+			gts->tpe->reason = gtp_stop_agent_expr_code_error;
+			return -1;
+			break;
+		}
+		break;
+	case GTP_PRINTK_FORMAT_S:
+		pbuf[GTP_PRINTF_MAX - 1] = '\0';
+		printk("<%d>CPU%d %s%s\n", gts->printk_level,
+		       smp_processor_id(), gts->printk_str->src, pbuf);
+		break;
+	case GTP_PRINTK_FORMAT_B: {
+			size_t	i;
+
+			printk(KERN_NULL "<%d>CPU%d %s", gts->printk_level,
+			       smp_processor_id(), gts->printk_str->src);
+			for (i = 0; i < size; i++)
+				printk("%02x", (unsigned int)pbuf[i]);
+			printk("\n");
+		}
+		break;
+	default:
+		printk(KERN_WARNING "gtp_action_printk: id:%d addr:%p "
+				    "printk format %u is not support.\n",
+		       (int)gts->tpe->num, (void *)(CORE_ADDR)gts->tpe->addr,
+		       gts->printk_format);
+		gts->tpe->reason = gtp_stop_agent_expr_code_error;
+		return -1;
+		break;
+	}
+
+	gts->printk_str = gts->printk_str->next;
+
+	return 0;
+}
+
+static int
+gtp_action_memory_read(struct gtp_trace_s *gts, int reg, CORE_ADDR addr,
+		       size_t size)
+{
+	char				*tmp;
+	struct gtp_frame_mem		*fm;
+#ifdef GTP_FTRACE_RING_BUFFER
+	struct ring_buffer_event	*rbe;
+#endif
+
+	if (reg >= 0)
+		addr += (CORE_ADDR) gtp_action_reg_read(gts, reg);
+	if (gts->tpe->reason != gtp_stop_normal)
+		return -1;
+
+	if (gts->next == NULL) {
+		if (gtp_action_head(gts))
+			return -1;
+	}
+
+#ifdef GTP_FTRACE_RING_BUFFER
+	GTP_FRAME_RINGBUFFER_ALLOC(GTP_FRAME_MEM_SIZE + size);
+#endif
+#if defined(GTP_FRAME_SIMPLE) || defined(GTP_RB)
+#ifdef GTP_RB
+	tmp = gtp_rb_alloc(gts->next, GTP_FRAME_MEM_SIZE + size, gts->id);
+#endif
+#ifdef GTP_FRAME_SIMPLE
+	tmp = gtp_frame_alloc(GTP_FRAME_MEM_SIZE + size);
+#endif
+	if (!tmp) {
+		gts->tpe->reason = gtp_stop_frame_full;
+		return -1;
+	}
+#ifdef GTP_FRAME_SIMPLE
+	*gts->next = tmp;
+#endif
+#endif
+
+	FID(tmp) = FID_MEM;
+	tmp += FID_SIZE;
+
+#ifdef GTP_FRAME_SIMPLE
+	gts->next = (char **)tmp;
+	*gts->next = NULL;
+	tmp += sizeof(char *);
+#endif
+
+	fm = (struct gtp_frame_mem *)tmp;
+	fm->addr = addr;
+	fm->size = size;
+	tmp += sizeof(struct gtp_frame_mem);
+
+#ifdef GTP_DEBUG_V
+	printk(GTP_DEBUG_V "gtp_action_memory_read: id:%d addr:%p %p %u\n",
+	       (int)gts->tpe->num, (void *)(CORE_ADDR)gts->tpe->addr,
+	       (void *)addr, (unsigned int)size);
+#endif
+
+	if (gts->read_memory(tmp, (void *)addr, size)) {
+		gts->tpe->reason = gtp_stop_efault;
+#ifdef GTP_FRAME_SIMPLE
+		memset(tmp, 0, size);
+#endif
+#ifdef GTP_FTRACE_RING_BUFFER
+		ring_buffer_discard_commit(gtp_frame, rbe);
+#endif
+#ifdef GTP_RB
+		GTP_RB_RELEASE(gts->next);
+#endif
+		printk(KERN_WARNING "gtp_action_memory_read: id:%d addr:%p "
+				    "read %p %u get error.\n",
+		       (int)gts->tpe->num, (void *)(CORE_ADDR)gts->tpe->addr,
+		       (void *)addr, (unsigned int)size);
+		return -1;
+	}
+
+#ifdef GTP_FTRACE_RING_BUFFER
+	ring_buffer_unlock_commit(gtp_frame, rbe);
+#endif
+
+	return 0;
+}
+
+static int
+gtp_action_r(struct gtp_trace_s *gts, struct action *ae)
+{
+	struct pt_regs			*regs;
+	char				*tmp;
+#ifdef GTP_FTRACE_RING_BUFFER
+	struct ring_buffer_event	*rbe;
+#endif
+
+	if (gts->next == NULL) {
+		if (gtp_action_head(gts))
+			return -1;
+	}
+
+#ifdef GTP_FTRACE_RING_BUFFER
+	GTP_FRAME_RINGBUFFER_ALLOC(GTP_FRAME_REG_SIZE);
+#endif
+#if defined(GTP_FRAME_SIMPLE) || defined(GTP_RB)
+#ifdef GTP_RB
+	tmp = gtp_rb_alloc(gts->next, GTP_FRAME_REG_SIZE, gts->id);
+#endif
+#ifdef GTP_FRAME_SIMPLE
+	tmp = gtp_frame_alloc(GTP_FRAME_REG_SIZE);
+#endif
+	if (!tmp) {
+		gts->tpe->reason = gtp_stop_frame_full;
+		return -1;
+	}
+#ifdef GTP_FRAME_SIMPLE
+	*gts->next = tmp;
+#endif
+#endif
+
+	FID(tmp) = FID_REG;
+	tmp += FID_SIZE;
+
+#ifdef GTP_FRAME_SIMPLE
+	gts->next = (char **)tmp;
+	*gts->next = NULL;
+	tmp += sizeof(char *);
+#endif
+
+	regs = (struct pt_regs *)tmp;
+
+	memcpy(regs, gts->regs, sizeof(struct pt_regs));
+#ifdef CONFIG_X86_32
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,25))
+	regs->sp = gts->x86_32_sp;
+#else
+	regs->esp = gts->x86_32_sp;
+#endif
+#endif	/* CONFIG_X86_32 */
+
+	if (gts->ri)
+		GTP_REGS_PC(regs) = (CORE_ADDR)gts->ri->ret_addr;
+#ifdef CONFIG_X86
+	else if (GTP_X86_NEED_ADJUST_PC(gts))
+		GTP_REGS_PC(regs) -= 1;
+#endif	/* CONFIG_X86 */
+
+#ifdef GTP_FTRACE_RING_BUFFER
+	ring_buffer_unlock_commit(gtp_frame, rbe);
+#endif
+
+	return 0;
+}
+
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,30))
+static DEFINE_SPINLOCK(gtp_handler_enable_disable_loc);
+
+static void
+gtp_handler_enable_disable(struct gtp_trace_s *gts, ULONGEST val, int enable)
+{
+	struct gtp_entry	*tpe;
+
+	spin_lock(&gtp_handler_enable_disable_loc);
+	for (tpe = gtp_list; tpe; tpe = tpe->next) {
+		if (val == 0 || tpe->num == val || gts->tpe != tpe)  {
+			/* Following code can insert this task
+				into tasklet without wake up softirqd.  */
+			add_preempt_count(HARDIRQ_OFFSET);
+			if (enable && tpe->disable)
+				tasklet_schedule(&gts->tpe->enable_tasklet);
+			else if (!enable && !tpe->disable)
+				tasklet_schedule(&gts->tpe->disable_tasklet);
+			sub_preempt_count(HARDIRQ_OFFSET);
+			tpe->disable = !tpe->disable;
+		}
+	}
+	spin_unlock(&gtp_handler_enable_disable_loc);
+}
+#endif
+
+static int
+gtp_var_agent_get_val(struct gtp_trace_s *gts, int num, int64_t *val)
+{
+	int		ret = 0;
+	struct gtp_var	*var;
+
+	var = gtp_var_array[num];
+	switch (var->type) {
+	case gtp_var_special:
+		ret = var->u.hooks->agent_get_val(gts, var, val);
+		break;
+	case gtp_var_per_cpu:
+		*val = gtp_var_get_pc(var)->u.val;
+		break;
+	case gtp_var_normal:
+		*val = var->u.val;
+		break;
+#ifdef GTP_PERF_EVENTS
+	case gtp_var_perf_event_per_cpu:
+	case gtp_var_perf_event: {
+			struct gtp_var_pe	*pe = gtp_var_get_pe(var);
+			pe->pe->val = perf_event_read_value(pe->pe->event,
+							    &(pe->pe->enabled),
+							    &(pe->pe->running));
+			switch (pe->ptid) {
+			case pe_tv_val:
+				*val = (int64_t)(pe->pe->val);
+				break;
+			case pe_tv_enabled:
+				*val = (int64_t)(pe->pe->enabled);
+				break;
+			case pe_tv_running:
+				*val = (int64_t)(pe->pe->running);
+				break;
+			default:
+				/* This just to handle warning of gcc.  */
+				break;
+			}
+		}
+		break;
+#endif
+	}
+
+	return ret;
+}
+
+static int
+gtp_var_agent_set_val(struct gtp_trace_s *gts, int num, int64_t val)
+{
+	int		ret = 0;
+	struct gtp_var	*var;
+
+	var = gtp_var_array[num];
+	switch (var->type) {
+	case gtp_var_special:
+		ret = var->u.hooks->agent_set_val(gts, var, val);
+		break;
+	case gtp_var_per_cpu:
+		gtp_var_get_pc(var)->u.val = val;
+		break;
+	case gtp_var_normal:
+		var->u.val = val;
+		break;
+#ifdef GTP_PERF_EVENTS
+	case gtp_var_perf_event_per_cpu:
+	case gtp_var_perf_event: {
+		struct gtp_var_pe	*pe = gtp_var_get_pe(var);
+		pe->pe->val = perf_event_read_value(pe->pe->event,
+						    &(pe->pe->enabled),
+						    &(pe->pe->running));
+		if (pe->ptid == pe_tv_en)
+			gtp_pe_set_en(pe->pe, (int)val);
+		else {
+			/* For pe_tv_val.  */
+#if (KGTP_API_VERSION_LOCAL < 20120808)
+			gtp_perf_event_set(pe->pe->event, (u64)val);
+#else
+			perf_event_set(pe->pe->event, (u64)val);
+#endif
+		}
+	}
+		break;
+#endif
+	}
+
+	return ret;
+}
+
+/* The number is not the ID of tvar, it is the ID of gtp_var_array. */
+
+static int
+gtp_collect_var(struct gtp_trace_s *gts, int num)
+{
+	struct gtp_frame_var		*fvar;
+	char				*tmp;
+#ifdef GTP_FTRACE_RING_BUFFER
+	struct ring_buffer_event	*rbe;
+#endif
+
+	if (gts->next == NULL) {
+		if (gtp_action_head(gts))
+			return -1;
+	}
+
+#ifdef GTP_FTRACE_RING_BUFFER
+	GTP_FRAME_RINGBUFFER_ALLOC(GTP_FRAME_VAR_SIZE);
+#endif
+#if defined(GTP_FRAME_SIMPLE) || defined(GTP_RB)
+#ifdef GTP_RB
+	tmp = gtp_rb_alloc(gts->next, GTP_FRAME_VAR_SIZE, gts->id);
+#endif
+#ifdef GTP_FRAME_SIMPLE
+	tmp = gtp_frame_alloc(GTP_FRAME_VAR_SIZE);
+#endif
+	if (!tmp) {
+		gts->tpe->reason = gtp_stop_frame_full;
+		return -1;
+	}
+#ifdef GTP_FRAME_SIMPLE
+	*gts->next = tmp;
+#endif
+#endif
+
+	FID(tmp) = FID_VAR;
+	tmp += FID_SIZE;
+
+#ifdef GTP_FRAME_SIMPLE
+	gts->next = (char **)tmp;
+	*gts->next = NULL;
+	tmp += sizeof(char *);
+#endif
+
+	fvar = (struct gtp_frame_var *) tmp;
+	fvar->num = gtp_var_array[num]->num;
+	if (gtp_var_agent_get_val(gts, num, &(fvar->val))) {
+		fvar->val = 0;
+		gts->tpe->reason = gtp_stop_agent_expr_code_error;
+		return -1;
+	}
+
+#ifdef GTP_FTRACE_RING_BUFFER
+	ring_buffer_unlock_commit(gtp_frame, rbe);
+#endif
+
+	return 0;
+}
+
+#define STACK_MAX	32
+static DEFINE_PER_CPU(ULONGEST[STACK_MAX], action_x_stack);
+
+static int
+gtp_action_x(struct gtp_trace_s *gts, struct action *ae)
+{
+	int		ret = 0;
+	unsigned int	pc = 0, sp = 0;
+	ULONGEST	top = 0;
+	int		arg;
+	union {
+		union {
+			uint8_t	bytes[1];
+			uint8_t	val;
+		} u8;
+		union {
+			uint8_t	bytes[2];
+			uint16_t val;
+		} u16;
+		union {
+			uint8_t bytes[4];
+			uint32_t val;
+		} u32;
+		union {
+			uint8_t bytes[8];
+			ULONGEST val;
+		} u64;
+	} cnv;
+	uint8_t		*ebuf = ae->u.exp.buf;
+	int		psize = GTP_PRINTF_MAX;
+	char		*pbuf = __get_cpu_var(gtp_printf);
+	ULONGEST	*stack = __get_cpu_var(action_x_stack);
+
+	if (unlikely(ae->u.exp.need_var_lock))
+		spin_lock(&gtp_var_lock);
+
+	while (1) {
+#ifdef GTP_DEBUG_V
+		printk(GTP_DEBUG_V "gtp_parse_x: cmd %x\n", ebuf[pc]);
+#endif
+
+		switch (ebuf[pc++]) {
+		/* add */
+		case 0x02:
+			top += stack[--sp];
+			break;
+
+		case op_check_add:
+			if (sp)
+				top += stack[--sp];
+			else
+				goto code_error_out;
+			break;
+
+		/* sub */
+		case 0x03:
+			top = stack[--sp] - top;
+			break;
+
+		case op_check_sub:
+			if (sp)
+				top = stack[--sp] - top;
+			else
+				goto code_error_out;
+			break;
+
+		/* mul */
+		case 0x04:
+			top *= stack[--sp];
+			break;
+
+		case op_check_mul:
+			if (sp)
+				top *= stack[--sp];
+			else
+				goto code_error_out;
+			break;
+
+#ifndef CONFIG_MIPS
+		/* div_signed */
+		case 0x05:
+			if (top) {
+				LONGEST l = (LONGEST) stack[--sp];
+				do_div(l, (LONGEST) top);
+				top = l;
+			} else
+				goto code_error_out;
+			break;
+
+		case op_check_div_signed:
+			if (top && sp) {
+				LONGEST l = (LONGEST) stack[--sp];
+				do_div(l, (LONGEST) top);
+				top = l;
+			} else
+				goto code_error_out;
+			break;
+
+		/* div_unsigned */
+		case 0x06:
+			if (top) {
+				ULONGEST ul = stack[--sp];
+				do_div(ul, top);
+				top = ul;
+			} else
+				goto code_error_out;
+			break;
+
+		case op_check_div_unsigned:
+			if (top && sp) {
+				ULONGEST ul = stack[--sp];
+				do_div(ul, top);
+				top = ul;
+			} else
+				goto code_error_out;
+			break;
+
+		/* rem_signed */
+		case 0x07:
+			if (top) {
+				LONGEST l1 = (LONGEST) stack[--sp];
+				LONGEST l2 = (LONGEST) top;
+				top = do_div(l1, l2);
+			} else
+				goto code_error_out;
+			break;
+
+		case op_check_rem_signed:
+			if (top && sp) {
+				LONGEST l1 = (LONGEST) stack[--sp];
+				LONGEST l2 = (LONGEST) top;
+				top = do_div(l1, l2);
+			} else
+				goto code_error_out;
+			break;
+
+		/* rem_unsigned */
+		case 0x08:
+			if (top) {
+				ULONGEST ul1 = stack[--sp];
+				ULONGEST ul2 = top;
+				top = do_div(ul1, ul2);
+			} else
+				goto code_error_out;
+			break;
+
+		case op_check_rem_unsigned:
+			if (top && sp) {
+				ULONGEST ul1 = stack[--sp];
+				ULONGEST ul2 = top;
+				top = do_div(ul1, ul2);
+			} else
+				goto code_error_out;
+			break;
+#endif
+
+		/* lsh */
+		case 0x09:
+			top = stack[--sp] << top;
+			break;
+
+		case op_check_lsh:
+			if (sp)
+				top = stack[--sp] << top;
+			else
+				goto code_error_out;
+			break;
+
+		/* rsh_signed */
+		case 0x0a:
+			top = ((LONGEST) stack[--sp]) >> top;
+			break;
+
+		case op_check_rsh_signed:
+			if (sp)
+				top = ((LONGEST) stack[--sp]) >> top;
+			else
+				goto code_error_out;
+			break;
+
+		/* rsh_unsigned */
+		case 0x0b:
+			top = stack[--sp] >> top;
+			break;
+
+		case op_check_rsh_unsigned:
+			if (sp)
+				top = stack[--sp] >> top;
+			else
+				goto code_error_out;
+			break;
+
+		/* trace */
+		case 0x0c:
+			--sp;
+			if (!(gts->tpe->flags & GTP_ENTRY_FLAGS_HAVE_PRINTK)) {
+				if (gtp_action_memory_read
+					(gts, -1,
+						(CORE_ADDR) stack[sp],
+						(size_t) top))
+					goto out;
+			}
+			top = stack[--sp];
+			break;
+
+		case op_check_trace:
+			if (sp > 1) {
+				if (gtp_action_memory_read
+					(gts, -1, (CORE_ADDR) stack[--sp],
+					(size_t) top)) {
+					/* gtp_action_memory_read will
+						set error status with itself
+						if it got error. */
+					goto out;
+				}
+				top = stack[--sp];
+			} else
+				goto code_error_out;
+			break;
+
+		/* trace_printk */
+		case op_trace_printk:
+			if (gtp_action_printk(gts,
+						(ULONGEST)stack[--sp],
+						(size_t) top))
+				goto out;
+			top = stack[--sp];
+			break;
+
+		/* trace_quick */
+		case 0x0d:
+			if (!(gts->tpe->flags & GTP_ENTRY_FLAGS_HAVE_PRINTK)) {
+				if (gtp_action_memory_read
+					(gts, -1, (CORE_ADDR) top,
+						(size_t) ebuf[pc]))
+					goto out;
+			}
+			pc++;
+			break;
+
+		/* trace_quick_printk */
+		case op_trace_quick_printk:
+			if (gtp_action_printk(gts, (ULONGEST) top,
+						(size_t) ebuf[pc++]))
+				goto out;
+			break;
+
+		/* log_not */
+		case 0x0e:
+			top = !top;
+			break;
+
+		/* bit_and */
+		case 0x0f:
+			top &= stack[--sp];
+			break;
+
+		case op_check_bit_and:
+			if (sp)
+				top &= stack[--sp];
+			else
+				goto code_error_out;
+			break;
+
+		/* bit_or */
+		case 0x10:
+			top |= stack[--sp];
+			break;
+
+		case op_check_bit_or:
+			if (sp)
+				top |= stack[--sp];
+			else
+				goto code_error_out;
+			break;
+
+		/* bit_xor */
+		case 0x11:
+			top ^= stack[--sp];
+			break;
+
+		case op_check_bit_xor:
+			if (sp)
+				top ^= stack[--sp];
+			else
+				goto code_error_out;
+			break;
+
+		/* bit_not */
+		case 0x12:
+			top = ~top;
+			break;
+
+		/* equal */
+		case 0x13:
+			top = (stack[--sp] == top);
+			break;
+
+		case op_check_equal:
+			if (sp)
+				top = (stack[--sp] == top);
+			else
+				goto code_error_out;
+			break;
+
+		/* less_signed */
+		case 0x14:
+			top = (((LONGEST) stack[--sp])
+				< ((LONGEST) top));
+			break;
+
+		case op_check_less_signed:
+			if (sp)
+				top = (((LONGEST) stack[--sp])
+					< ((LONGEST) top));
+			else
+				goto code_error_out;
+			break;
+
+		/* less_unsigned */
+		case 0x15:
+			top = (stack[--sp] < top);
+			break;
+
+		case op_check_less_unsigned:
+			if (sp)
+				top = (stack[--sp] < top);
+			else
+				goto code_error_out;
+			break;
+
+		/* ext */
+		case 0x16:
+			arg = ebuf[pc++];
+			if (arg < (sizeof(LONGEST)*8)) {
+				LONGEST mask = 1 << (arg - 1);
+				top &= ((LONGEST) 1 << arg) - 1;
+				top = (top ^ mask) - mask;
+			}
+			break;
+
+		/* ref8 */
+		case 0x17:
+			if (gts->read_memory
+				(cnv.u8.bytes,
+				(void *)(CORE_ADDR)top, 1))
+				goto code_error_out;
+			top = (ULONGEST) cnv.u8.val;
+			break;
+
+		/* ref16 */
+		case 0x18:
+			if (gts->read_memory
+				(cnv.u16.bytes,
+				(void *)(CORE_ADDR)top, 2))
+				goto code_error_out;
+			top = (ULONGEST) cnv.u16.val;
+			break;
+
+		/* ref32 */
+		case 0x19:
+			if (gts->read_memory
+				(cnv.u32.bytes,
+				(void *)(CORE_ADDR)top, 4))
+				goto code_error_out;
+			top = (ULONGEST) cnv.u32.val;
+			break;
+
+		/* ref64 */
+		case 0x1a:
+			if (gts->read_memory
+				(cnv.u64.bytes,
+				(void *)(CORE_ADDR)top, 8))
+				goto code_error_out;
+			top = (ULONGEST) cnv.u64.val;
+			break;
+
+		/* if_goto */
+		case 0x20:
+			if (top)
+				pc = (ebuf[pc] << 8)
+					+ (ebuf[pc + 1]);
+			else
+				pc += 2;
+			/* pop */
+			top = stack[--sp];
+			break;
+
+		case op_check_if_goto:
+			if (top)
+				pc = (ebuf[pc] << 8)
+					+ (ebuf[pc + 1]);
+			else
+				pc += 2;
+			/* pop */
+			if (sp)
+				top = stack[--sp];
+			else
+				goto code_error_out;
+			break;
+
+		/* goto */
+		case 0x21:
+			pc = (ebuf[pc] << 8) + (ebuf[pc + 1]);
+			break;
+
+		/* const8 */
+		case 0x22:
+			stack[sp++] = top;
+			top = ebuf[pc++];
+			break;
+
+		/* const16 */
+		case 0x23:
+			stack[sp++] = top;
+			top = ebuf[pc++];
+			top = (top << 8) + ebuf[pc++];
+			break;
+
+		/* const32 */
+		case 0x24:
+			stack[sp++] = top;
+			top = ebuf[pc++];
+			top = (top << 8) + ebuf[pc++];
+			top = (top << 8) + ebuf[pc++];
+			top = (top << 8) + ebuf[pc++];
+			break;
+
+		/* const64 */
+		case 0x25:
+			stack[sp++] = top;
+			top = ebuf[pc++];
+			top = (top << 8) + ebuf[pc++];
+			top = (top << 8) + ebuf[pc++];
+			top = (top << 8) + ebuf[pc++];
+			top = (top << 8) + ebuf[pc++];
+			top = (top << 8) + ebuf[pc++];
+			top = (top << 8) + ebuf[pc++];
+			top = (top << 8) + ebuf[pc++];
+			break;
+
+		/* reg */
+		case 0x26:
+			stack[sp++] = top;
+			arg = ebuf[pc++];
+			arg = (arg << 8) + ebuf[pc++];
+			top = gtp_action_reg_read(gts, arg);
+			if (gts->tpe->reason != gtp_stop_normal)
+				goto error_out;
+			break;
+
+		/* end */
+		case 0x27:
+			if (gts->run)
+				*(gts->run) = (int)top;
+			goto out;
+			break;
+
+		/* dup */
+		case 0x28:
+			stack[sp++] = top;
+			break;
+
+		/* pop */
+		case 0x29:
+			top = stack[--sp];
+			break;
+
+		case op_check_pop:
+			if (sp)
+				top = stack[--sp];
+			else
+				goto code_error_out;
+			break;
+
+		/* zero_ext */
+		case 0x2a:
+			arg = ebuf[pc++];
+			if (arg < (sizeof(LONGEST)*8))
+				top &= ((LONGEST) 1 << arg) - 1;
+			break;
+
+		/* swap */
+		case 0x2b:
+			stack[sp] = top;
+			top = stack[sp - 1];
+			stack[sp - 1] = stack[sp];
+			break;
+
+		case op_check_swap:
+			if (sp) {
+				stack[sp] = top;
+				top = stack[sp - 1];
+				stack[sp - 1] = stack[sp];
+			} else
+				goto code_error_out;
+			break;
+
+		/* getv */
+		case 0x2c: {
+				int64_t	val;
+
+				arg = ebuf[pc++];
+				arg = (arg << 8) + ebuf[pc++];
+
+				stack[sp++] = top;
+
+				if (gtp_var_agent_get_val(gts, arg, &val))
+					goto code_error_out;
+
+				top = (ULONGEST)val;
+			}
+			break;
+
+		/* setv */
+		case 0x2d:
+			arg = ebuf[pc++];
+			arg = (arg << 8) + ebuf[pc++];
+			if (gtp_var_agent_set_val(gts, arg, (int64_t)top))
+				goto code_error_out;
+			break;
+
+		/* tracev */
+		case 0x2e:
+			arg = ebuf[pc++];
+			arg = (arg << 8) + ebuf[pc++];
+
+			if (gtp_collect_var(gts, arg)) {
+				/* gtp_collect_var will set error
+				   status with itself if it got error.  */
+				goto error_out;
+			}
+			break;
+
+		/* tracev_printk */
+		case op_tracev_printk: {
+				uint64_t	u64;
+				arg = ebuf[pc++];
+				arg = (arg << 8) + ebuf[pc++];
+
+				if (gtp_var_agent_get_val(gts, arg, &u64))
+					goto code_error_out;
+				if (gtp_action_printk(gts, u64, 0)) {
+					/* gtp_action_printk will set error status
+					   with itself if it got error. */
+					goto error_out;
+				}
+			}
+			break;
+		}
+
+		if (ae->type != 'X' && unlikely(sp > STACK_MAX - 5)) {
+			printk(KERN_WARNING "gtp_action_x: stack overflow.\n");
+			gts->tpe->reason
+				= gtp_stop_agent_expr_stack_overflow;
+			goto error_out;
+		}
+	}
+code_error_out:
+	gts->tpe->reason = gtp_stop_agent_expr_code_error;
+error_out:
+	ret = -1;
+	printk(KERN_WARNING "gtp_action_x: tracepoint %d addr:%p"
+			    "action X get error in pc %u.\n",
+		(int)gts->tpe->num, (void *)(CORE_ADDR)gts->tpe->addr, pc);
+out:
+	if (unlikely(psize != GTP_PRINTF_MAX)) {
+		unsigned long	flags;
+
+		local_irq_save(flags);
+		printk("%s", pbuf - (GTP_PRINTF_MAX - psize));
+		local_irq_restore(flags);
+	}
+	if (unlikely(ae->u.exp.need_var_lock))
+		spin_unlock(&gtp_var_lock);
+	return ret;
+}
+
+#if defined(GTP_FTRACE_RING_BUFFER) || defined(GTP_RB)
+/* Wake up gtpframe pipe.  */
+static void
+gtp_handler_wakeup(void)
+{
+#ifdef GTP_FTRACE_RING_BUFFER
+	FID_TYPE	eid = FID_END;
+	ring_buffer_write(gtp_frame, FID_SIZE, &eid);
+#endif
+
+	if (atomic_read(&gtpframe_pipe_wq_v) > 0) {
+		atomic_dec(&gtpframe_pipe_wq_v);
+		add_preempt_count(HARDIRQ_OFFSET);
+		tasklet_schedule(&gtpframe_pipe_wq_tasklet);
+		sub_preempt_count(HARDIRQ_OFFSET);
+	}
+}
+#endif
+
+#ifdef CONFIG_X86
+/* while-stepping stop.  */
+
+static void
+gtp_step_stop(struct pt_regs *regs)
+{
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,25))
+	regs->flags &= ~(X86_EFLAGS_TF);
+#else
+	regs->eflags &= ~(X86_EFLAGS_TF);
+#endif
+	if (__get_cpu_var(gtp_step).irq_need_open) {
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,25))
+		regs->flags |= X86_EFLAGS_IF;
+#else
+		regs->eflags |= X86_EFLAGS_IF;
+#endif
+	}
+	__get_cpu_var(gtp_step).step = 0;
+	__get_cpu_var(gtp_step).tpe = NULL;
+	__get_cpu_var(gtp_step).irq_need_open = 0;
+}
+#endif
+
+static void
+gtp_handler(struct gtp_trace_s *gts)
+{
+	struct list_head	*head, *cur;
+	struct action		*ae;
+
+#ifdef GTP_DEBUG_V
+	printk(GTP_DEBUG_V "gtp_handler: tracepoint %d %p\n",
+	       (int)gts->tpe->num, (void *)(CORE_ADDR)gts->tpe->addr);
+#endif
+#ifdef CONFIG_X86
+	if (gts->step == 0 && __get_cpu_var(gtp_step).step)
+		gtp_step_stop(gts->regs);
+#endif
+
+	gts->read_memory = (void *)probe_kernel_read;
+	if (gts->tpe->flags & GTP_ENTRY_FLAGS_CURRENT_TASK) {
+		/* Get regs.  */
+		if (gts->tpe->get_regs) {
+			if (gtp_action_x(gts, gts->tpe->get_regs)
+			    || gts->tmp_regs == NULL)
+				goto tpe_stop;
+			gts->regs = gts->tmp_regs;
+		} else
+			gts->regs = task_pt_regs(get_current());
+
+		if (user_mode(gts->regs)) {
+			gts->read_memory = gtp_task_handler_read;
+#ifdef CONFIG_X86_32
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,25))
+			gts->x86_32_sp = gts->regs->sp;
+#else
+			gts->x86_32_sp = gts->regs->esp;
+#endif
+#endif
+		} else {
+#ifdef CONFIG_X86_32
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,25))
+			gts->x86_32_sp = (unsigned long)&gts->regs->sp;
+#else
+			gts->x86_32_sp = (unsigned long)&gts->regs->esp;
+#endif
+#endif
+		}
+	} else {
+#ifdef CONFIG_X86_32
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,25))
+		gts->x86_32_sp = (unsigned long)&gts->regs->sp;
+#else
+		gts->x86_32_sp = (unsigned long)&gts->regs->esp;
+#endif
+#endif
+	}
+
+	if ((gts->tpe->flags & GTP_ENTRY_FLAGS_REG) == 0)
+		return;
+
+#if defined(GTP_FTRACE_RING_BUFFER) || defined(GTP_RB)
+	if (!gtp_pipe_trace && get_current()->pid == gtp_gtpframe_pipe_pid)
+		return;
+#endif
+
+	if ((gts->tpe->flags & GTP_ENTRY_FLAGS_SELF_TRACE) == 0
+	    && (get_current()->pid == gtp_gtp_pid
+		|| get_current()->pid == gtp_gtpframe_pid)) {
+			return;
+	}
+
+	if (gts->tpe->flags & GTP_ENTRY_FLAGS_HAVE_PRINTK) {
+		gts->printk_level = 8;
+		gts->printk_str = gts->tpe->printk_str;
+	}
+
+	/* Condition.  */
+	if (gts->tpe->cond) {
+		int	run;
+
+		gts->run = &run;
+		if (gtp_action_x(gts, gts->tpe->cond))
+			goto tpe_stop;
+		if (!run)
+			return;
+	}
+
+	gts->run = NULL;
+
+	/* Pass.  */
+	if (gts->step == 0 && gts->tpe->flags & GTP_ENTRY_FLAGS_HAVE_PASS) {
+		if (atomic_dec_return(&gts->tpe->current_pass) < 0)
+			goto tpe_stop;
+	}
+
+	/* Handle actions.  */
+	head = gts->step ? &gts->tpe->step_action_list :
+			   &gts->tpe->action_list;
+	list_for_each(cur, head) {
+		ae = list_entry(cur, struct action, node);
+		switch (ae->type) {
+		case 'R':
+			if (gtp_action_r(gts, ae))
+				goto tpe_stop;
+			break;
+		case 'X':
+		case 0xff:
+			if (gtp_action_x(gts, ae))
+				goto tpe_stop;
+			break;
+		case 'M':
+			if (gtp_action_memory_read(gts, ae->u.m.regnum,
+						   ae->u.m.offset,
+						   ae->u.m.size))
+				goto tpe_stop;
+			break;
+		}
+	}
+
+#if defined(GTP_FTRACE_RING_BUFFER) || defined(GTP_RB)
+	if (gts->next) {
+#ifdef GTP_RB
+		GTP_RB_UNLOCK(gts->next);
+#endif
+		gtp_handler_wakeup();
+	}
+#endif
+
+	return;
+
+tpe_stop:
+#if defined(GTP_FTRACE_RING_BUFFER) || defined(GTP_RB)
+	if (gts->next) {
+#ifdef GTP_RB
+		GTP_RB_UNLOCK(gts->next);
+#endif
+		gtp_handler_wakeup();
+	}
+#endif
+
+	gts->tpe->flags &= ~GTP_ENTRY_FLAGS_REG;
+
+	if (gts->tpe->type == gtp_entry_kprobe) {
+		/* Following code can insert this task into tasklet without
+		   wake up softirqd.  */
+		add_preempt_count(HARDIRQ_OFFSET);
+		tasklet_schedule(&gts->tpe->u.kp.stop_tasklet);
+		sub_preempt_count(HARDIRQ_OFFSET);
+	} else {
+		//XXX teawater
+	}
+#ifdef GTP_DEBUG_V
+	printk(GTP_DEBUG_V "gtp_handler: tracepoint %d %p stop.\n",
+		(int)gts->tpe->num, (void *)(CORE_ADDR)gts->tpe->addr);
+#endif
+	return;
+}
+
+static DEFINE_PER_CPU(int, gtp_handler_began);
+
+#ifdef CONFIG_X86
+static int	gtp_access_cooked_rdtsc;
+#endif
+static int	gtp_access_cooked_clock;
+#ifdef GTP_PERF_EVENTS
+static int	gtp_have_pc_pe;
+#endif
+
+static void
+gtp_handler_begin(void)
+{
+	if (!__get_cpu_var(gtp_handler_began)) {
+#ifdef CONFIG_X86
+		if (gtp_access_cooked_rdtsc) {
+			u64	a;
+
+			rdtscll(a);
+			__get_cpu_var(rdtsc_current) = a;
+		}
+#endif
+
+		if (gtp_access_cooked_clock)
+			__get_cpu_var(local_clock_current) = GTP_LOCAL_CLOCK;
+
+#ifdef GTP_PERF_EVENTS
+		if (gtp_have_pc_pe)
+			pc_pe_list_disable();
+#endif
+
+		__get_cpu_var(gtp_handler_began) = 1;
+	}
+}
+
+static void
+gtp_handler_end(void)
+{
+	if (__get_cpu_var(gtp_handler_began)) {
+#ifdef GTP_PERF_EVENTS
+		if (gtp_have_pc_pe)
+			pc_pe_list_enable();
+#endif
+
+		if (gtp_access_cooked_clock) {
+			__get_cpu_var(local_clock_offset) += GTP_LOCAL_CLOCK
+					- __get_cpu_var(local_clock_current);
+			__get_cpu_var(local_clock_current) = 0;
+		}
+
+#ifdef CONFIG_X86
+		if (gtp_access_cooked_rdtsc) {
+			u64	a;
+
+			rdtscll(a);
+			__get_cpu_var(rdtsc_offset) += a
+					- __get_cpu_var(rdtsc_current);
+			__get_cpu_var(rdtsc_current) = 0;
+		}
+#endif
+
+		__get_cpu_var(gtp_handler_began) = 0;
+	}
+}
+
+static inline void
+gtp_kp_pre_handler_1(struct kprobe *p, struct pt_regs *regs)
+{
+	struct kretprobe	*kpret;
+	struct gtp_kp		*gkp;
+	union gtp_entry_u	*u;
+	struct gtp_trace_s	gts;
+
+	memset(&gts, 0, sizeof(struct gtp_trace_s));
+
+	kpret = container_of(p, struct kretprobe, kp);
+	gkp = container_of(kpret, struct gtp_kp, kpret);
+	u = container_of(gkp, union gtp_entry_u, kp);
+	gts.tpe = container_of(u, struct gtp_entry, u);
+	gts.regs = regs;
+
+	gtp_handler(&gts);
+}
+
+static inline void
+gtp_kp_post_handler_1(struct kprobe *p, struct pt_regs *regs,
+		      unsigned long flags)
+{
+	struct kretprobe	*kpret;
+	struct gtp_kp		*gkp;
+	union gtp_entry_u	*u;
+	struct gtp_entry		*tpe;
+	struct gtp_trace_s	gts;
+
+	kpret = container_of(p, struct kretprobe, kp);
+	gkp = container_of(kpret, struct gtp_kp, kpret);
+	u = container_of(gkp, union gtp_entry_u, kp);
+	tpe = container_of(u, struct gtp_entry, u);
+
+	if (tpe->step == 1) {
+		memset(&gts, 0, sizeof(struct gtp_trace_s));
+
+		gts.tpe = tpe;
+		gts.regs = regs;
+		gts.step = tpe->step;
+
+		gtp_handler(&gts);
+	}
+
+#ifdef CONFIG_X86
+	if (tpe->step > 1) {
+		/* Let while-stepping begin.  */
+		/*XXX if there a another one, maybe we need add end frame to let reader know that this while step stop.  */
+		__get_cpu_var(gtp_step).step = tpe->step;
+		__get_cpu_var(gtp_step).tpe = tpe;
+		#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,25))
+		if (regs->flags & X86_EFLAGS_IF)
+		#else
+		if (regs->eflags & X86_EFLAGS_IF)
+		#endif
+			__get_cpu_var(gtp_step).irq_need_open = 1;
+		else
+			__get_cpu_var(gtp_step).irq_need_open = 0;
+		#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,25))
+		regs->flags |= X86_EFLAGS_TF;
+		regs->flags &= ~(X86_EFLAGS_IF);
+		#else
+		regs->eflags |= X86_EFLAGS_TF;
+		regs->eflags &= ~(X86_EFLAGS_IF);
+		#endif
+	}
+#endif
+}
+
+static inline void
+gtp_kp_ret_handler_1(struct kretprobe_instance *ri, struct pt_regs *regs)
+{
+	struct gtp_trace_s	gts;
+	struct gtp_kp		*gkp;
+	union gtp_entry_u	*u;
+
+	memset(&gts, 0, sizeof(struct gtp_trace_s));
+
+	gkp = container_of(ri->rp, struct gtp_kp, kpret);
+	u = container_of(gkp, union gtp_entry_u, kp);
+	gts.tpe = container_of(u, struct gtp_entry, u);
+	gts.regs = regs;
+	gts.ri = ri;
+
+	gtp_handler(&gts);
+}
+
+static int
+gtp_kp_pre_handler_plus_step(struct kprobe *p, struct pt_regs *regs)
+{
+	gtp_handler_begin();
+
+	gtp_kp_pre_handler_1(p, regs);
+
+	return 0;
+}
+
+static int
+gtp_kp_pre_handler_plus(struct kprobe *p, struct pt_regs *regs)
+{
+	gtp_handler_begin();
+
+	gtp_kp_pre_handler_1(p, regs);
+
+	gtp_handler_end();
+
+	return 0;
+}
+
+static int
+gtp_kp_pre_handler(struct kprobe *p, struct pt_regs *regs)
+{
+	gtp_kp_pre_handler_1(p, regs);
+
+	return 0;
+}
+
+/* Only available when tpe->step is true.  */
+
+static void
+gtp_kp_post_handler_plus(struct kprobe *p, struct pt_regs *regs,
+			 unsigned long flags)
+{
+	gtp_kp_post_handler_1(p, regs, flags);
+
+	gtp_handler_end();
+}
+
+/* Only available when tpe->step is true.  */
+
+static void
+gtp_kp_post_handler(struct kprobe *p, struct pt_regs *regs,
+			 unsigned long flags)
+{
+	gtp_kp_post_handler_1(p, regs, flags);
+}
+
+static int
+gtp_kp_ret_handler_plus(struct kretprobe_instance *ri, struct pt_regs *regs)
+{
+	gtp_handler_begin();
+
+	gtp_kp_ret_handler_1(ri, regs);
+
+	gtp_handler_end();
+
+	return 0;
+}
+
+static int
+gtp_kp_ret_handler(struct kretprobe_instance *ri, struct pt_regs *regs)
+{
+	gtp_kp_ret_handler_1(ri, regs);
+
+	return 0;
+}
+
+static struct action *
+gtp_action_alloc(char type)
+{
+	struct action	*ret;
+
+	ret = (struct action *)kzalloc(sizeof (struct action), GFP_KERNEL);
+	if (ret)
+		ret->type = type;
+
+	return ret;
+}
+
+static void
+gtp_action_release(struct action *ae)
+{
+	if (ae == NULL)
+		return;
+	if ((ae->type == 'X' || ae->type == 0xff) && ae->u.exp.buf)
+		kfree(ae->u.exp.buf);
+	kfree(ae);
+}
+
+static void
+gtp_action_list_release(struct list_head *list)
+{
+	struct list_head	*cur, *tmp;
+	struct action		*ae;
+
+	list_for_each_safe(cur, tmp, list) {
+		ae = list_entry(cur, struct action, node);
+		list_del(&ae->node);
+		gtp_action_release(ae);
+	}
+}
+
+static void
+gtp_src_release(struct gtpsrc *src)
+{
+	struct gtpsrc	*src2;
+
+	while (src) {
+		src2 = src;
+		src = src->next;
+		kfree(src2->src);
+		kfree(src2);
+	}
+}
+
+static void
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2,6,19))
+gtp_tracepoint_stop(struct work_struct *work)
+{
+	struct gtp_kp		*gkp = container_of(work,
+						    struct gtp_kp,
+						    stop_work);
+	union gtp_entry_u	*u = container_of(gkp,
+						  union gtp_entry_u,
+						  kp);
+	struct gtp_entry	*tpe = container_of(u,
+						    struct gtp_entry,
+						    u);
+#else
+gtp_tracepoint_stop(void *p)
+{
+	struct gtp_entry	*tpe = p;
+#endif
+
+#ifdef GTP_DEBUG
+	printk(GTP_DEBUG "gtp_tracepoint_stop: tracepoint %d %p\n",
+	       (int)tpe->num, (void *)(CORE_ADDR)tpe->addr);
+#endif
+
+	
+	if (tpe->type == gtp_entry_kprobe) {
+		if (tpe->flags & GTP_ENTRY_FLAGS_IS_KRETPROBE)
+			unregister_kretprobe(&tpe->u.kp.kpret);
+		else
+			unregister_kprobe(&tpe->u.kp.kpret.kp);
+	}
+}
+
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,30))
+static void
+gtp_tracepoint_enable(struct work_struct *work)
+{
+	struct gtp_entry	*tpe = container_of(work,
+						    struct gtp_entry,
+						    enable_work);
+
+#ifdef GTP_DEBUG
+	printk(GTP_DEBUG "gtp_tracepoint_enable: tracepoint %d %p\n",
+	       (int)tpe->num, (void *)(CORE_ADDR)tpe->addr);
+#endif
+
+	if (tpe->type == gtp_entry_kprobe) {
+		if (tpe->flags & GTP_ENTRY_FLAGS_IS_KRETPROBE)
+			enable_kretprobe(&tpe->u.kp.kpret);
+		else
+			enable_kprobe(&tpe->u.kp.kpret.kp);
+	}
+}
+
+static void
+gtp_tracepoint_disable(struct work_struct *work)
+{
+	struct gtp_entry	*tpe = container_of(work,
+						    struct gtp_entry,
+						    disable_work);
+
+#ifdef GTP_DEBUG
+	printk(GTP_DEBUG "gtp_tracepoint_disable: tracepoint %d %p\n",
+	       (int)tpe->num, (void *)(CORE_ADDR)tpe->addr);
+#endif
+
+	if (tpe->type == gtp_entry_kprobe) {
+		if (tpe->flags & GTP_ENTRY_FLAGS_IS_KRETPROBE)
+			disable_kretprobe(&tpe->u.kp.kpret);
+		else
+			disable_kprobe(&tpe->u.kp.kpret.kp);
+	}
+}
+#endif
+
+static struct gtp_entry *
+gtp_list_add(ULONGEST num, ULONGEST addr)
+{
+	struct gtp_entry	*ret = kzalloc(sizeof(struct gtp_entry),
+					       GFP_KERNEL);
+
+	if (!ret)
+		goto out;
+	ret->num = num;
+	ret->addr = addr;
+
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2,6,19))
+	INIT_WORK(&ret->u.kp.stop_work, gtp_tracepoint_stop);
+#else
+	INIT_WORK(&ret->u.kp.stop_work, gtp_tracepoint_stop, ret);
+#endif
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,30))
+	INIT_WORK(&ret->enable_work, gtp_tracepoint_enable);
+	INIT_WORK(&ret->disable_work, gtp_tracepoint_disable);
+#endif
+	INIT_LIST_HEAD(&ret->action_list);
+	INIT_LIST_HEAD(&ret->step_action_list);
+
+	/* Add to gtp_list.  */
+	ret->next = gtp_list;
+	gtp_list = ret;
+
+out:
+	return ret;
+}
+
+static struct gtp_entry *
+gtp_list_find(ULONGEST num, ULONGEST addr)
+{
+	struct gtp_entry	*tpe;
+
+	for (tpe = gtp_list; tpe; tpe = tpe->next) {
+		if (tpe->num == num && tpe->addr == addr)
+			return tpe;
+	}
+
+	return NULL;
+}
+
+/* If more than one gtp entry have same num, return NULL.  */
+
+static struct gtp_entry *
+gtp_list_find_without_addr_do_check(ULONGEST num)
+{
+	struct gtp_entry	*tpe, *ret = NULL;
+
+	for (tpe = gtp_list; tpe; tpe = tpe->next) {
+		if (tpe->num == num) {
+			if (ret)
+				return NULL;
+			else
+				ret = tpe;
+		}
+	}
+
+	return ret;
+}
+
+static void
+gtp_list_release(void)
+{
+	struct gtp_entry	*tpe;
+
+	while (gtp_list) {
+		tpe = gtp_list;
+		gtp_list = gtp_list->next;
+		gtp_action_release(tpe->cond);
+		gtp_action_list_release(&tpe->action_list);
+		gtp_action_list_release(&tpe->step_action_list);
+		gtp_src_release(tpe->src);
+		gtp_src_release(tpe->action_cmd);
+		gtp_src_release(tpe->printk_str);
+		kfree(tpe);
+	}
+
+	current_gtp = NULL;
+	current_gtp_action_cmd = NULL;
+	current_gtp_src = NULL;
+}
+
+#ifdef GTP_FTRACE_RING_BUFFER
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2,6,34)) || defined(GTP_SELF_RING_BUFFER)
+static void
+gtp_frame_iter_open(void)
+{
+	int	cpu;
+
+
+	for_each_online_cpu(cpu)
+		gtp_frame_iter[cpu] = ring_buffer_read_prepare(gtp_frame, cpu);
+	ring_buffer_read_prepare_sync();
+	for_each_online_cpu(cpu) {
+		ring_buffer_read_start(gtp_frame_iter[cpu]);
+	}
+}
+#else
+static void
+gtp_frame_iter_open(void)
+{
+	int	cpu;
+
+	for_each_online_cpu(cpu) {
+		gtp_frame_iter[cpu] = ring_buffer_read_start(gtp_frame, cpu);
+		ring_buffer_iter_reset(gtp_frame_iter[cpu]);
+	}
+}
+#endif
+
+static void
+gtp_frame_iter_reset(void)
+{
+	int	cpu;
+
+	for_each_online_cpu(cpu)
+		ring_buffer_iter_reset(gtp_frame_iter[cpu]);
+	gtp_frame_current_num = -1;
+}
+
+static int
+gtp_frame_iter_peek_head(void)
+{
+	int	cpu;
+	int	ret = -1;
+	u64	min = 0;
+
+	for_each_online_cpu(cpu) {
+		struct ring_buffer_event	*rbe;
+		char				*tmp;
+		u64				ts;
+
+		while (1) {
+			rbe = ring_buffer_iter_peek(gtp_frame_iter[cpu], &ts);
+			if (rbe == NULL)
+				break;
+			tmp = ring_buffer_event_data(rbe);
+			if (FID(tmp) == FID_HEAD)
+				break;
+			ring_buffer_read(gtp_frame_iter[cpu], NULL);
+		}
+
+		if (rbe) {
+			if ((min && ts < min) || !min) {
+				min = ts;
+				ret = cpu;
+			}
+		}
+	}
+
+	if (ret < 0)
+		gtp_frame_current_num = -1;
+	else
+		gtp_frame_current_num++;
+	return ret;
+}
+
+static void
+gtp_frame_iter_close(void)
+{
+	int	cpu;
+
+	for_each_online_cpu(cpu) {
+		if (gtp_frame_iter[cpu]) {
+			ring_buffer_read_finish(gtp_frame_iter[cpu]);
+			gtp_frame_iter[cpu] = NULL;
+		}
+	}
+}
+#endif
+
+static void
+gtp_frame_reset(void)
+{
+	gtp_frame_current_num = -1;
+#ifdef GTP_FRAME_SIMPLE
+	gtp_frame_r_start = gtp_frame;
+	gtp_frame_w_start = gtp_frame;
+	gtp_frame_end = gtp_frame + GTP_FRAME_SIZE;
+	gtp_frame_is_circular = 0;
+	gtp_frame_current = NULL;
+#endif
+#ifdef GTP_FTRACE_RING_BUFFER
+	gtp_frame_iter_close();
+	if (gtp_frame)
+		ring_buffer_reset(gtp_frame);
+#endif
+#ifdef GTP_RB
+	gtp_rb_reset();
+#endif
+	atomic_set(&gtp_frame_create, 0);
+	if (gtp_frame_file) {
+		vfree(gtp_frame_file);
+		gtp_frame_file = NULL;
+		gtp_frame_file_size = 0;
+	}
+}
+
+static int
+hex2int(char hex, int *i)
+{
+	if ((hex >= '0') && (hex <= '9')) {
+		*i = hex - '0';
+		return 1;
+	}
+	if ((hex >= 'a') && (hex <= 'f')) {
+		*i = hex - 'a' + 10;
+		return 1;
+	}
+	if ((hex >= 'A') && (hex <= 'F')) {
+		*i = hex - 'A' + 10;
+		return 1;
+	}
+
+	return 0;
+}
+
+static char *
+hex2ulongest(char *pkg, ULONGEST *u64)
+{
+	int	i;
+
+	if (u64)
+		*u64 = 0;
+	while (hex2int(pkg[0], &i)) {
+		pkg++;
+		if (u64) {
+			*u64 = (*u64) << 4;
+			*u64 |= i & 0xf;
+		}
+	}
+
+	return pkg;
+}
+
+static char *
+hex2string(char *pkg, char *out)
+{
+	char	*ret = out;
+	int	i, j;
+
+	while (hex2int(pkg[0], &i) && hex2int(pkg[1], &j)) {
+		out[0] = i * 16 + j;
+		pkg += 2;
+		out += 1;
+	}
+	out[0] = '\0';
+
+	return ret;
+}
+
+static void
+gtpro_list_clear(void)
+{
+	struct gtpro_entry	*e;
+
+	while (gtpro_list) {
+		e = gtpro_list;
+		gtpro_list = gtpro_list->next;
+		kfree(e);
+	}
+}
+
+static struct gtpro_entry *
+gtpro_list_add(CORE_ADDR start, CORE_ADDR end)
+{
+	struct gtpro_entry	*e;
+
+	e = kmalloc(sizeof(struct gtpro_entry), GFP_KERNEL);
+	if (e == NULL)
+		goto out;
+
+#ifdef GTP_DEBUG
+	printk(GTP_DEBUG "gtpro_list_add: %p %p\n", (void *)start, (void *)end);
+#endif
+
+	e->start = start;
+	e->end = end;
+
+	e->next = gtpro_list;
+	gtpro_list = e;
+
+out:
+	return e;
+}
+
+static int
+gtp_src_add(char *begin, char *end, struct gtpsrc **src_list)
+{
+	struct gtpsrc	*src, *srctail;
+
+	src = kmalloc(sizeof(struct gtpsrc), GFP_KERNEL);
+	if (src == NULL)
+		return -ENOMEM;
+	src->next = NULL;
+	src->src = gtp_strdup(begin, end);
+	if (src->src == NULL) {
+		kfree(src);
+		return -ENOMEM;
+	}
+
+	if (*src_list) {
+		for (srctail = *src_list; srctail->next;
+		      srctail = srctail->next)
+			;
+		srctail->next = src;
+	} else
+		*src_list = src;
+
+	return 0;
+}
+
+#ifdef CONFIG_X86
+static void
+gtp_hw_breakpoint_handler_1 (struct gtp_hwb_s *hwb, struct pt_regs *regs)
+{
+	struct gtp_trace_s	gts;
+
+	preempt_disable();
+
+	memset(&gts, 0, sizeof(struct gtp_trace_s));
+	gts.tpe = hwb->watch;
+	gts.regs = regs;
+	gts.hwb = hwb;
+	gtp_handler(&gts);
+
+	preempt_enable_no_resched();
+
+	/* Update hwb->prev_val.  */
+	if (gts.hwb_current_val_gotten)
+		hwb->prev_val = gts.hwb_current_val;
+	else
+		gtp_get_addr_val(hwb->addr, hwb->size, &(hwb->prev_val));
+}
+
+#define ADDR_PREFIX_OPCODE 0x67
+#define DATA_PREFIX_OPCODE 0x66
+#define LOCK_PREFIX_OPCODE 0xf0
+#define CS_PREFIX_OPCODE 0x2e
+#define DS_PREFIX_OPCODE 0x3e
+#define ES_PREFIX_OPCODE 0x26
+#define FS_PREFIX_OPCODE 0x64
+#define GS_PREFIX_OPCODE 0x65
+#define SS_PREFIX_OPCODE 0x36
+#define REPNE_PREFIX_OPCODE 0xf2
+#define REPE_PREFIX_OPCODE  0xf3
+
+static int
+gtp_step_check_insn(struct pt_regs *regs)
+{
+	uint32_t	opcode;
+	uint8_t		opcode8;
+	unsigned long	pc = GTP_REGS_PC(regs);
+
+	/* prefixes */
+	while (1) {
+		if (probe_kernel_read(&opcode8, (void *)pc, 1))
+			return -1;
+		pc++;
+		switch (opcode8) {
+		case REPE_PREFIX_OPCODE:
+		case REPNE_PREFIX_OPCODE:
+		case LOCK_PREFIX_OPCODE:
+		case CS_PREFIX_OPCODE:
+		case SS_PREFIX_OPCODE:
+		case DS_PREFIX_OPCODE:
+		case ES_PREFIX_OPCODE:
+		case FS_PREFIX_OPCODE:
+		case GS_PREFIX_OPCODE:
+		case DATA_PREFIX_OPCODE:
+		case ADDR_PREFIX_OPCODE:
+#ifndef CONFIG_X86_32
+		case 0x40 ... 0x4f:
+#endif
+			break;
+		default:
+			goto out_prefixes;
+		}
+	}
+out_prefixes:
+
+	opcode = (uint32_t)opcode8;
+reswitch:
+	switch (opcode) {
+	case 0x0f:
+		if (probe_kernel_read(&opcode8, (void *)pc, 1))
+			return -1;
+		opcode = (uint32_t) opcode8 | 0x0f00;
+		goto reswitch;
+		break;
+	case 0xfb:
+		/* sti */
+		__get_cpu_var(gtp_step).irq_need_open = 1;
+		GTP_REGS_PC(regs) = pc;
+		break;
+	case 0xfa:
+		/* cli */
+		__get_cpu_var(gtp_step).irq_need_open = 0;
+		GTP_REGS_PC(regs) = pc;
+		break;
+	case 0x0f07:
+		/* sysret */
+		return 1;
+		break;
+	};
+
+	return 0;
+}
+
+static int
+gtp_notifier_call(struct notifier_block *self, unsigned long cmd,
+		   void *ptr)
+{
+	int		ret = NOTIFY_DONE;
+	unsigned long	flags;
+	struct die_args *args;
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(3,0,0))
+	int		i;
+#endif
+	unsigned long	dr6;
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,33))
+	unsigned long	*dr6_p;
+#endif
+
+	if (cmd != DIE_DEBUG)
+		return ret;
+
+	local_irq_save(flags);
+	args = ptr;
+
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,33))
+	/* Get from X86 hw_breakpoint_handler.  */
+	dr6_p = (unsigned long *)ERR_PTR(args->err);
+	dr6 = *dr6_p;
+#else
+	dr6 = args->err;
+#endif
+	gtp_set_debugreg(GTP_HWB_DR7_DEF, 7);
+
+	/* Handle while-stepping.  */
+	spin_lock(&__get_cpu_var(gtp_step).lock);
+	if ((dr6 & 0x4000) != 0) {
+		/* Clear the bit that handle by KGTP.  */
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,33))
+		(*dr6_p) &= ~(0x4000);
+#else
+ 		dr6 &= ~(0x4000);
+#endif
+		if (!__get_cpu_var(gtp_step).tpe || user_mode(args->regs))
+			gtp_step_stop(args->regs);
+		else {
+			int need_stop = gtp_step_check_insn(args->regs);
+			if (need_stop < 0)
+				printk(KERN_WARNING "KGTP: check insn in %p got error.",
+				       (void *)GTP_REGS_PC(args->regs));
+
+			preempt_disable();
+			{
+				struct gtp_trace_s	gts;
+
+				memset(&gts, 0, sizeof(struct gtp_trace_s));
+				gts.tpe = __get_cpu_var(gtp_step).tpe;
+				gts.regs = args->regs;
+				gts.step = __get_cpu_var(gtp_step).step;
+				gtp_handler(&gts);
+			}
+			preempt_enable_no_resched();
+
+			if (__get_cpu_var(gtp_step).step > 1 && !need_stop) {
+				/* XXX: not sure need set eflags each step.  */
+#if 0
+				#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,25))
+				args->regs->flags |= X86_EFLAGS_TF;
+				args->regs->flags &= ~(X86_EFLAGS_IF);
+				#else
+				args->regs->eflags |= X86_EFLAGS_TF;
+				args->regs->eflags &= ~(X86_EFLAGS_IF);
+				#endif
+#endif
+				__get_cpu_var(gtp_step).step--;
+			} else {
+				/*XXX: maybe need add a end frame.  */
+				gtp_step_stop(args->regs);
+			}
+		}
+	}
+	spin_unlock(&__get_cpu_var(gtp_step).lock);
+
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(3,0,0))
+	/* Handle watch traceppoint.  */
+	if ((dr6 & 0xf) == 0)
+		goto out;
+	read_lock(&gtp_hwb_lock);
+
+	for (i = 0; i < HWB_NUM; i++) {
+		if ((dr6 & (0x1 << i)) == 0)
+			continue;
+		/* Clear the bit that handle by KGTP.  */
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,33))
+		(*dr6_p) &= ~(0x1 << i);
+#else
+		dr6 &= ~(0x1 << i);
+#endif
+		if (gtp_hwb[i].watch == NULL)
+			continue;
+		/* Check if gtp_hwb is updated in other CPU.  */
+		if (__get_cpu_var(gtp_hwb_sync_count_local) != gtp_hwb_sync_count) {
+			unsigned long	addr;
+
+			gtp_get_debugreg(addr, i);
+			if (addr != gtp_hwb[i].addr)
+				continue;
+		}
+		gtp_hw_breakpoint_handler_1(&gtp_hwb[i], args->regs);
+	}
+
+	/* If the HWB need update in this CPU, just update it.  */
+	if (__get_cpu_var(gtp_hwb_sync_count_local) != gtp_hwb_sync_count) {
+		gtp_set_debugreg(gtp_hwb_drx[0], 0);
+		gtp_set_debugreg(gtp_hwb_drx[1], 1);
+		gtp_set_debugreg(gtp_hwb_drx[2], 2);
+		gtp_set_debugreg(gtp_hwb_drx[3], 3);
+		__get_cpu_var(gtp_hwb_sync_count_local) = gtp_hwb_sync_count;
+	}
+
+	gtp_set_debugreg(gtp_hwb_dr7, 7);
+	read_unlock(&gtp_hwb_lock);
+#endif
+
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(3,0,0))
+out:
+#endif
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,33))
+	gtp_set_debugreg(dr6, 6);
+#endif
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,33))
+	/* If have some other traps, let other handler handle it.  */
+	if (((*dr6_p) & GTP_HWB_DR6_MASK) == 0)
+		ret = NOTIFY_STOP;
+	current->thread.debugreg6 = *dr6_p;
+#else
+	if ((dr6 & GTP_HWB_DR6_MASK) == 0)
+		ret = NOTIFY_STOP;
+	current->thread.debugreg6 = dr6;
+#endif
+
+	local_irq_restore(flags);
+	return ret;
+}
+
+static struct notifier_block gtp_notifier = {
+	.notifier_call = gtp_notifier_call,
+	.priority = 0x7ffffffe /* we need to be notified after kprobe.  */
+};
+#endif
+
+#ifdef CONFIG_X86
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3,0,0))
+static void
+gtp_hw_breakpoint_handler(int num, struct pt_regs *regs)
+{
+	read_lock(&gtp_hwb_lock);
+
+	/* Handle the warning of new gcc.  */
+	if (num < 0 || num >= HWB_NUM)
+		goto out;
+
+	if (gtp_hwb[num].watch == NULL)
+		goto out;
+	if (__get_cpu_var(gtp_hwb_sync_count_local) != gtp_hwb_sync_count) {
+		unsigned long	addr;
+
+		gtp_get_debugreg(addr, num);
+		if (addr != gtp_hwb[num].addr) {
+			gtp_set_debugreg(gtp_hwb[num].addr, num);
+			goto out;
+		}
+	}
+
+	gtp_hw_breakpoint_handler_1(&gtp_hwb[num], regs);
+out:
+	read_unlock(&gtp_hwb_lock);
+}
+
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3,1,0))
+static void
+gtp_hw_breakpoint_0_handler(struct perf_event *bp, struct perf_sample_data *data,
+			    struct pt_regs *regs)
+{
+	gtp_hw_breakpoint_handler(breakinfo[0].num, regs);
+}
+
+static void
+gtp_hw_breakpoint_1_handler(struct perf_event *bp, struct perf_sample_data *data,
+			    struct pt_regs *regs)
+{
+	gtp_hw_breakpoint_handler(breakinfo[1].num, regs);
+}
+
+static void
+gtp_hw_breakpoint_2_handler(struct perf_event *bp, struct perf_sample_data *data,
+			    struct pt_regs *regs)
+{
+	gtp_hw_breakpoint_handler(breakinfo[2].num, regs);
+}
+
+static void
+gtp_hw_breakpoint_3_handler(struct perf_event *bp, struct perf_sample_data *data,
+			    struct pt_regs *regs)
+{
+	gtp_hw_breakpoint_handler(breakinfo[3].num, regs);
+}
+#else
+static void
+gtp_hw_breakpoint_0_handler(struct perf_event *bp, int nmi,
+			    struct perf_sample_data *data,
+			    struct pt_regs *regs)
+{
+	gtp_hw_breakpoint_handler(breakinfo[0].num, regs);
+}
+
+static void
+gtp_hw_breakpoint_1_handler(struct perf_event *bp, int nmi,
+			    struct perf_sample_data *data,
+			    struct pt_regs *regs)
+{
+	gtp_hw_breakpoint_handler(breakinfo[1].num, regs);
+}
+
+static void
+gtp_hw_breakpoint_2_handler(struct perf_event *bp, int nmi,
+			    struct perf_sample_data *data,
+			    struct pt_regs *regs)
+{
+	gtp_hw_breakpoint_handler(breakinfo[2].num, regs);
+}
+
+static void
+gtp_hw_breakpoint_3_handler(struct perf_event *bp, int nmi,
+			    struct perf_sample_data *data,
+			    struct pt_regs *regs)
+{
+	gtp_hw_breakpoint_handler(breakinfo[3].num, regs);
+}
+#endif
+#endif
+
+static unsigned int
+gtp_hwb_size_to_arch(int size)
+{
+	unsigned int	ret;
+
+	switch (size) {
+	default:
+	case 1:
+		ret = 0;
+		break;
+	case 2:
+		ret = 1;
+		break;
+	case 4:
+		ret = 3;
+		break;
+	case 8:
+		ret = 2;
+		break;
+	}
+
+	return ret;
+}
+
+static unsigned int
+gtp_hwb_type_to_arch(int type)
+{
+	unsigned int	ret;
+
+	switch (type) {
+	default:
+	case gtp_watch_write:
+		ret = 1;
+		break;
+	case gtp_watch_exec:
+		ret = 0;
+		break;
+	case gtp_watch_read_write:
+		ret = 3;
+		break;
+	}
+
+	return ret;
+}
+
+static int
+gtp_register_hwb(const struct gtp_hwb_s *arg, int nowait)
+{
+	unsigned long		flags;
+	struct gtp_hwb_s	*hwb = NULL;
+	int			ret = -EBUSY;
+
+	write_lock_irqsave(&gtp_hwb_lock, flags);
+	if (!list_empty(&gtp_hwb_unused_list)) {
+		int	num;
+		int64_t	prev_val;
+
+		/* Get the value from address that will watch as prev value.  */
+		ret = gtp_get_addr_val(arg->addr, arg->size, &prev_val);
+		if (ret)
+			goto out;
+
+		hwb = list_first_entry(&gtp_hwb_unused_list, struct gtp_hwb_s, node);
+		list_del_init(&hwb->node);
+		list_add(&hwb->node, &gtp_hwb_used_list);
+		num = hwb->num;
+		memcpy((void *)&arg->node, (void *)&hwb->node, sizeof (hwb->node));
+		memcpy(hwb, arg, sizeof(struct gtp_hwb_s));
+		hwb->num = num;
+		hwb->prev_val = prev_val;
+
+		/* Update gtp_hwb_dr7 and gtp_hwb_drx[num].  */
+		/* Set Gx.  */
+		gtp_hwb_dr7 |= 2 << (num << 1);
+		/* Clear RWx and LENx.  */
+		gtp_hwb_dr7 &= ~(0xf0000 << (num << 2));
+		/* Set RWx and LENx.  */
+		gtp_hwb_dr7 |= ((gtp_hwb_size_to_arch(hwb->size) << 2)
+				| gtp_hwb_type_to_arch(hwb->type))
+			       << ((num << 2) + 16);
+		/* Update DRx.  */
+		gtp_hwb_drx[num] = hwb->addr;
+
+		/* Set gtp_hwb_dr7 and gtp_hwb_drx[num] to hwb.  */
+		gtp_set_debugreg(gtp_hwb_drx[num], num);
+		gtp_set_debugreg(gtp_hwb_dr7, 7);
+
+		gtp_hwb_sync_count++;
+		hwb->count = gtp_hwb_sync_count;
+
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,27))
+		if (nowait) {
+			/* Send ipi to let other cpu update.  */
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,30))
+			arch_send_call_function_ipi_mask(&__get_cpu_var(gtp_hwb_sync_cpu_mask));
+#else
+			arch_send_call_function_ipi(&__get_cpu_var(gtp_hwb_sync_cpu_mask));
+#endif
+		}
+#endif
+
+		ret = 0;
+	}
+out:
+	write_unlock_irqrestore(&gtp_hwb_lock, flags);
+
+	if (ret == 0 && !nowait)
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,27))
+		smp_call_function(gtp_hwb_sync, NULL, 1);
+#else
+		smp_call_function(gtp_hwb_sync, NULL, 0, 1);
+#endif
+
+	return ret;
+}
+
+static int
+gtp_unregister_hwb(CORE_ADDR addr, int sync)
+{
+	unsigned long		flags;
+	struct list_head	*pos;
+	struct gtp_hwb_s	*hwb = NULL;
+	int			ret = -ENXIO;
+
+	write_lock_irqsave(&gtp_hwb_lock, flags);
+	list_for_each(pos, &gtp_hwb_used_list) {
+		hwb = list_entry(pos, struct gtp_hwb_s, node);
+		if (hwb->addr == addr)
+			break;
+	}
+	if (hwb) {
+		list_del_init(&hwb->node);
+		list_add_tail(&hwb->node, &gtp_hwb_unused_list);
+		hwb->watch = NULL;
+
+		/* Update gtp_hwb_dr7.  */
+		/* Clear Gx.  */
+		gtp_hwb_dr7 &= ~(2 << (hwb->num << 1));
+
+		if (sync) {
+			gtp_hwb_sync_count++;
+
+			/* Sync gtp_hwb_dr7 update to hwb.  */
+			gtp_set_debugreg(gtp_hwb_dr7, 7);
+
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,27))
+			/* Send ipi to let other cpu update.  */
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,30))
+			arch_send_call_function_ipi_mask(&__get_cpu_var(gtp_hwb_sync_cpu_mask));
+#else
+			arch_send_call_function_ipi(&__get_cpu_var(gtp_hwb_sync_cpu_mask));
+#endif
+#endif
+		}
+
+		ret = 0;
+	}
+	write_unlock_irqrestore(&gtp_hwb_lock, flags);
+
+	return ret;
+}
+#endif
+
+static int
+gtp_gdbrsp_qtstop(void)
+{
+	struct gtp_entry	*tpe;
+#ifdef GTP_PERF_EVENTS
+	struct list_head	*cur;
+#endif
+
+#ifdef GTP_DEBUG
+	printk(GTP_DEBUG "gtp_gdbrsp_qtstop\n");
+#endif
+
+#ifdef FRAME_ALLOC_RECORD
+	printk(KERN_WARNING "frame_alloc_size = %llu, "
+			    "frame_alloc_size_hole = %llu\n",
+	       frame_alloc_size, frame_alloc_size_hole);
+	frame_alloc_size = 0;
+	frame_alloc_size_hole = 0;
+#endif
+
+	if (!gtp_start)
+		return -EBUSY;
+
+	flush_workqueue(gtp_wq);
+
+	for (tpe = gtp_list; tpe; tpe = tpe->next) {
+		if (tpe->type != gtp_entry_kprobe
+		    || (tpe->flags & GTP_ENTRY_FLAGS_REG) == 0)
+			continue;
+
+		if (tpe->flags & GTP_ENTRY_FLAGS_IS_KRETPROBE)
+			unregister_kretprobe(&tpe->u.kp.kpret);
+		else
+			unregister_kprobe(&tpe->u.kp.kpret.kp);
+
+		tpe->flags &= ~GTP_ENTRY_FLAGS_REG;
+
+		tasklet_kill(&tpe->u.kp.stop_tasklet);
+
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,30))
+		tasklet_kill(&tpe->disable_tasklet);
+		tasklet_kill(&tpe->enable_tasklet);
+#endif
+	}
+
+#ifdef CONFIG_X86
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(3,0,0))
+	if (gtp_have_step || gtp_have_watch_tracepoint)
+#else
+	if (gtp_have_step)
+#endif
+		unregister_die_notifier(&gtp_notifier);
+
+	{
+		/* Init data of while-stepping.  */
+		int	cpu;
+		for_each_online_cpu(cpu) {
+			struct gtp_step_s	*step = &per_cpu(gtp_step, cpu);
+
+			spin_lock(&step->lock);
+			step->step = 0;
+			step->tpe = NULL;
+			spin_unlock(&step->lock);
+		}
+	}
+#endif
+
+#ifdef CONFIG_X86
+	/* Stop hwb.  */
+	if (gtp_have_watch_tracepoint) {
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3,0,0))
+		{
+			int	i;
+
+			/* Register hw breakpoints.  */
+			for (i = 0; i < HWB_NUM; i++) {
+				unregister_wide_hw_breakpoint(breakinfo[i].pev);
+				breakinfo[i].pev = NULL;
+			}
+		}
+#endif
+
+		gtp_hwb_stop(NULL);
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,27))
+		smp_call_function(gtp_hwb_stop, NULL, 1);
+#else
+		smp_call_function(gtp_hwb_stop, NULL, 0, 1);
+#endif
+
+		for (tpe = gtp_list; tpe; tpe = tpe->next) {
+			if (tpe->type == gtp_entry_kprobe
+			    || (tpe->flags & GTP_ENTRY_FLAGS_REG) == 0
+			    || tpe->disable)
+				continue;
+
+			if (tpe->type == gtp_entry_watch_static)
+				gtp_unregister_hwb(tpe->addr, 0);
+
+			tpe->flags &= ~GTP_ENTRY_FLAGS_REG;
+
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,30))
+			tasklet_kill(&tpe->disable_tasklet);
+			tasklet_kill(&tpe->enable_tasklet);
+#endif
+		}
+
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,27))
+		unregister_kprobe(&gtp_ipi_kp);
+#endif
+	}
+#endif
+
+#ifdef GTP_PERF_EVENTS
+	list_for_each(cur, &gtp_var_list) {
+		struct gtp_var		*var;
+		struct gtp_var_pe	*pe;
+
+		var = list_entry(cur, struct gtp_var, node);
+		if (var->type != gtp_var_perf_event
+		    && var->type != gtp_var_perf_event_per_cpu)
+			continue;
+		if (var->type == gtp_var_perf_event_per_cpu
+		    && var->u.pc.cpu < 0)
+			continue;
+
+		pe = gtp_var_get_pe(var);
+		if (pe->pe->event == NULL)
+			continue;
+
+		pe->pe->val = perf_event_read_value(pe->pe->event,
+						      &(pe->pe->enabled),
+						      &(pe->pe->running));
+		perf_event_release_kernel(pe->pe->event);
+		pe->pe->event = NULL;
+	}
+#endif
+
+	if (gtp_var_array) {
+		kfree(gtp_var_array);
+		gtp_var_array = NULL;
+	}
+
+#ifdef GTP_FTRACE_RING_BUFFER
+	if (gtp_frame) {
+		gtp_frame_iter_open();
+		gtp_frame_iter_reset();
+	}
+#endif
+
+	gtp_start = 0;
+#if defined(GTP_FTRACE_RING_BUFFER) || defined(GTP_RB)
+	if (atomic_read(&gtpframe_pipe_wq_v) > 0) {
+		atomic_dec(&gtpframe_pipe_wq_v);
+		tasklet_schedule(&gtpframe_pipe_wq_tasklet);
+	}
+	tasklet_kill(&gtpframe_pipe_wq_tasklet);
+#endif
+	wake_up_interruptible_nr(&gtpframe_wq, 1);
+
+	return 0;
+}
+
+static int
+gtp_gdbrsp_qtinit(void)
+{
+#ifdef GTP_DEBUG
+	printk(GTP_DEBUG "gtp_gdbrsp_qtinit\n");
+#endif
+
+	if (gtp_start)
+		gtp_gdbrsp_qtstop();
+
+	gtp_list_release();
+
+#ifdef GTP_RB
+	if (!GTP_RB_PAGE_IS_EMPTY)
+#elif defined(GTP_FRAME_SIMPLE) || defined(GTP_FTRACE_RING_BUFFER)
+	if (gtp_frame)
+#endif
+		gtp_frame_reset();
+
+	gtpro_list_clear();
+#ifdef CONFIG_X86
+	gtp_have_watch_tracepoint = 0;
+	gtp_have_step = 0;
+#endif
+
+	gtp_var_release(0);
+
+#ifdef CONFIG_X86
+	gtp_access_cooked_rdtsc = 0;
+#endif
+	gtp_access_cooked_clock = 0;
+#ifdef GTP_PERF_EVENTS
+	gtp_have_pc_pe = 0;
+#endif
+
+	return 0;
+}
+
+struct gtp_x_loop {
+	struct gtp_x_loop	*next;
+	unsigned int		addr;
+	int			non_goto_done;
+};
+
+static struct gtp_x_loop *
+gtp_x_loop_find(struct gtp_x_loop *list, unsigned int pc)
+{
+	struct gtp_x_loop	*ret = NULL;
+
+	for (ret = list; ret; ret = ret->next) {
+		if (ret->addr == pc)
+			break;
+	}
+
+	return ret;
+}
+
+static struct gtp_x_loop *
+gtp_x_loop_add(struct gtp_x_loop **list, unsigned int pc, int non_goto_done)
+{
+	struct gtp_x_loop	*ret;
+
+	ret = kmalloc(sizeof(struct gtp_x_loop), GFP_KERNEL);
+	if (!ret)
+		goto out;
+
+	ret->addr = pc;
+	ret->non_goto_done = non_goto_done;
+
+	ret->next = *list;
+	*list = ret;
+
+out:
+	return ret;
+}
+
+struct gtp_x_if_goto {
+	struct gtp_x_if_goto	*next;
+	unsigned int		ip;
+	unsigned int		sp;
+};
+
+static struct gtp_x_if_goto *
+gtp_x_if_goto_add(struct gtp_x_if_goto **list, unsigned int pc, unsigned int sp)
+{
+	struct gtp_x_if_goto	*ret;
+
+	ret = kmalloc(sizeof(struct gtp_x_loop), GFP_KERNEL);
+	if (!ret)
+		goto out;
+
+	ret->ip = pc;
+	ret->sp = sp;
+
+	ret->next = *list;
+	*list = ret;
+
+out:
+	return ret;
+}
+
+struct gtp_x_var {
+	struct gtp_x_var	*next;
+	unsigned int		num;
+	unsigned int		flags;
+};
+
+static int
+gtp_x_var_add(struct gtp_x_var **list, unsigned int num, unsigned int flag)
+{
+	struct gtp_x_var	*curv;
+
+	for (curv = *list; curv; curv = curv->next) {
+		if (curv->num == num)
+			break;
+	}
+
+	if (!curv) {
+		curv = kmalloc(sizeof(struct gtp_x_var), GFP_KERNEL);
+		if (!curv)
+			return -ENOMEM;
+		curv->num = num;
+		curv->flags = 0;
+		if (*list) {
+			curv->next = *list;
+			*list = curv;
+		} else {
+			curv->next = NULL;
+			*list = curv;
+		}
+	}
+
+	curv->flags |= flag;
+
+	return 0;
+}
+
+static int
+gtp_add_backtrace_actions(struct gtp_entry *tpe, int step)
+{
+	struct list_head	*head, *cur;
+	struct action		*ae;
+	int			got_r = 0, got_m = 0;
+
+	head = step ? &tpe->step_action_list : &tpe->action_list;
+
+	list_for_each(cur, head) {
+		ae = list_entry(cur, struct action, node);
+		if (ae->type == 'R')
+			got_r = 1;
+		else if (ae->type == 'M' && ae->u.m.regnum == GTP_SP_NUM
+			  && ae->u.m.offset == 0 && ae->u.m.size >= gtp_bt_size)
+			got_m = 1;
+
+		if (got_r && got_m)
+			return 1;
+	}
+
+	if (!got_r) {
+		ae = gtp_action_alloc('R');
+		if (!ae)
+			return -ENOMEM;
+		list_add_tail(&ae->node, head);
+	}
+
+	if (!got_m) {
+		ae = gtp_action_alloc('M');
+		if (!ae)
+			return -ENOMEM;
+		ae->u.m.regnum = GTP_SP_NUM;
+		ae->u.m.size = gtp_bt_size;
+		list_add_tail(&ae->node, head);
+	}
+
+	return 1;
+}
+
+static int
+gtp_check_getv(struct gtp_entry *tpe, struct action *ae, int step, 
+	       uint8_t *ebuf, unsigned int pc,
+	       struct gtp_x_var **list)
+{
+	int		ret = -EINVAL;
+	int		arg;
+	struct gtp_var	*var;
+
+	if (pc + 1 >= ae->u.exp.size)
+		goto out;
+	arg = ebuf[pc++];
+	arg = (arg << 8) + ebuf[pc++];
+
+	var = gtp_var_find_num(arg);
+	if (var == NULL) {
+		printk(KERN_WARNING "Action try to get TSV %d that doesn't exist.\n",
+			arg);
+		goto out;
+	}
+
+	switch (var->type) {
+	case gtp_var_special:
+		if (arg == GTP_VAR_SELF_TRACE_ID) {
+			tpe->flags |= GTP_ENTRY_FLAGS_SELF_TRACE;
+			ret = 1;
+			goto out;
+		} else if (arg == GTP_VAR_BT_ID) {
+			ret = gtp_add_backtrace_actions (tpe, step);
+			goto out;
+		} else if (arg == GTP_VAR_CURRENT_ID) {
+			tpe->flags |= GTP_ENTRY_FLAGS_CURRENT_TASK;
+			ret = 1;
+			goto out;
+		}
+
+		if (arg == GTP_VAR_COOKED_CLOCK_ID)
+			gtp_access_cooked_clock = 1;
+#ifdef CONFIG_X86
+		else if (arg == GTP_VAR_COOKED_RDTSC_ID)
+			gtp_access_cooked_rdtsc = 1;
+#endif
+		if (!var->u.hooks || (var->u.hooks
+				      && !var->u.hooks->agent_get_val)) {
+			printk(KERN_WARNING "Action try to get special TSV %d that cannot be get.\n",
+				arg);
+			ret = -EINVAL;
+			goto out;
+		}
+		break;
+
+#ifdef GTP_PERF_EVENTS
+	case gtp_var_perf_event_per_cpu:
+	case gtp_var_perf_event: {
+			struct gtp_var_pe	*pe = gtp_var_get_pe(var);
+
+			if (pe->ptid != pe_tv_val
+			    && pe->ptid != pe_tv_enabled
+			    && pe->ptid != pe_tv_running) {
+				printk(KERN_WARNING "Action try to get perf event TSV %d that cannot be get.\n",
+				arg);
+				goto out;
+			}
+			if (var->type == gtp_var_perf_event
+			    && gtp_x_var_add(list, arg, 1)) {
+				ret = -ENOMEM;
+				goto out;
+			}
+		}
+		break;
+#endif
+
+	case gtp_var_normal:
+		if (gtp_x_var_add(list, arg, 1)) {
+			ret = -ENOMEM;
+			goto out;
+		}
+		break;
+	}
+
+	/* Change the num of var to the num of gtp_var_array.
+	   It will make this insn speed up. */
+	arg = gtp_var_array_find_num(var);
+	if (arg < 0) {
+		printk(KERN_WARNING "Action try to set TSV %d that does't inside the gtp var array.\n",
+			var->num);
+		goto out;
+	}
+	ebuf[pc - 2] = (uint8_t)(arg >> 8);
+	ebuf[pc - 1] = (uint8_t)(arg & 0xff);
+	ret = 0;
+
+out:
+	return ret;
+}
+
+static int
+gtp_check_setv(struct gtp_entry *tpe, struct action *ae, int step,
+	       uint8_t *ebuf, unsigned int pc,
+	       struct gtp_x_var **list, int loop,
+	       ULONGEST *stack, ULONGEST top)
+{
+	int		arg;
+	struct gtp_var	*var;
+	int		ret = -EINVAL;
+
+	if (pc + 1 >= ae->u.exp.size)
+		goto out;
+	arg = ebuf[pc++];
+	arg = (arg << 8) + ebuf[pc++];
+
+	var = gtp_var_find_num(arg);
+	if (var == NULL) {
+		printk(KERN_WARNING "Action try to set TSV %d that doesn't exist.\n",
+			arg);
+		goto out;
+	}
+
+	switch (var->type) {
+	case gtp_var_special:
+		switch (arg) {
+		case GTP_VAR_SELF_TRACE_ID:
+			tpe->flags |= GTP_ENTRY_FLAGS_SELF_TRACE;
+			ret = 1;
+			goto out;
+			break;
+		case GTP_VAR_KRET_ID:
+			/* XXX: still not set it value to maxactive.  */
+			tpe->flags |= GTP_ENTRY_FLAGS_IS_KRETPROBE;
+			ret = 1;
+			goto out;
+			break;
+		case GTP_VAR_BT_ID:
+			ret = gtp_add_backtrace_actions (tpe, step);
+			goto out;
+			break;
+		case GTP_VAR_CURRENT_ID:
+			tpe->flags |= GTP_ENTRY_FLAGS_CURRENT_TASK;
+			ret = 2;
+			break;
+		case GTP_VAR_PRINTK_LEVEL_ID:
+			if (loop || step) {
+				printk(KERN_WARNING "Loop or step action doesn't support printk.\n");
+				goto out;
+			} else
+				tpe->flags |= GTP_ENTRY_FLAGS_HAVE_PRINTK;
+			break;
+#ifdef CONFIG_X86
+		case GTP_WATCH_STATIC_ID:
+			if (stack == NULL || top > 1) {
+				printk(KERN_WARNING "$watch_static just support set to 0 or 1.\n");
+				goto out;
+			}
+			/* Init watch struct inside gtp_entry.  */
+			if (tpe->type != gtp_entry_watch_static
+			    && tpe->type != gtp_entry_watch_dynamic) {
+				tpe->type = gtp_entry_watch_dynamic;
+				tpe->u.watch.type = gtp_watch_write;
+				tpe->u.watch.size = 1;
+			}
+			gtp_have_watch_tracepoint = 1;
+			if (top == 1)
+				tpe->type = gtp_entry_watch_static;
+			else
+				tpe->type = gtp_entry_watch_dynamic;
+			ret = 1;
+			goto out;
+			break;
+		case GTP_WATCH_TYPE_ID:
+			if (stack && (tpe->type == gtp_entry_watch_static
+				      || tpe->type == gtp_entry_watch_dynamic)) {
+				if (top != gtp_watch_exec
+				    && top != gtp_watch_write
+				    && top != gtp_watch_read_write) {
+					printk(KERN_WARNING "$watch_type just support set to 0, 1 or 2.\n");
+					goto out;
+				}
+				tpe->u.watch.type = top;
+				ret = 1;
+				goto out;
+			}
+			break;
+		case GTP_WATCH_SIZE_ID:
+			if (stack && (tpe->type == gtp_entry_watch_static
+				      || tpe->type == gtp_entry_watch_dynamic)) {
+				if (top != 1 && top != 2 && top != 4
+				    && top != 8) {
+					printk(KERN_WARNING "$watch_size just support set to 1, 2, 4 or 8.\n");
+					goto out;
+				}
+				tpe->u.watch.size = top;
+				ret = 1;
+				goto out;
+			}
+			break;
+#endif
+		}
+
+		if (!var->u.hooks || (var->u.hooks
+				      && !var->u.hooks->agent_set_val)) {
+			printk(KERN_WARNING "Action try to set special TSV %d that cannot be get.\n",
+			       arg);
+			goto out;
+		}
+		break;
+
+#ifdef GTP_PERF_EVENTS
+	case gtp_var_perf_event_per_cpu:
+	case gtp_var_perf_event: {
+			struct gtp_var_pe	*pe = gtp_var_get_pe(var);
+
+			if (pe->ptid != pe_tv_en
+			    && pe->ptid != pe_tv_val) {
+				printk(KERN_WARNING "Action try to set perf event TSV %d that cannot be set.\n",
+				arg);
+				goto out;
+			}
+			if (var->type == gtp_var_perf_event
+			    && gtp_x_var_add(list, arg, 2)) {
+				ret = -ENOMEM;
+				goto out;
+			}
+		}
+		break;
+#endif
+
+	case gtp_var_normal:
+		if (gtp_x_var_add(list, arg, 2)) {
+			ret = -ENOMEM;
+			goto out;
+		}
+		break;
+	}
+
+	/* Change the num of var to the num of gtp_var_array.
+	   It will make this insn speed up. */
+	arg = gtp_var_array_find_num(var);
+	if (arg < 0) {
+		printk(KERN_WARNING "Action try to set TSV %d that does't inside the gtp var array.\n",
+		       var->num);
+		goto out;
+	}
+	ebuf[pc - 2] = (uint8_t)(arg >> 8);
+	ebuf[pc - 1] = (uint8_t)(arg & 0xff);
+	/* Handle GTP_VAR_CURRENT_ID, it need return 2.  */
+	if (ret != 2)
+		ret = 0;
+
+out:
+	return ret;
+}
+
+/* This is the first check.
+   1. Get the max size of stack need (sp_max).
+      Check if it bigger than SP_MAX.
+   2. Check TSV.
+      Check if normal TSV id is right.
+      Check special TSV, if need change insn code to op_special_getv,
+      op_special_setv or op_special_tracev.
+   3. If this is loop, change ae->type to 0xff and return.  */
+
+static int
+gtp_check_x_simple(struct gtp_entry *tpe, struct action *ae, int step)
+{
+	int			ret = -EINVAL;
+	unsigned int		pc = 0, sp = 0;
+	struct gtp_x_if_goto	*glist = NULL, *gtmp;
+	struct gtp_x_var	*vlist = NULL, *vtmp;
+	uint8_t			*ebuf = ae->u.exp.buf;
+	int			last_trace_pc = -1;
+	unsigned int		sp_max = 0;
+	ULONGEST		top = 0;
+	ULONGEST		stack_space[STACK_MAX + 10];
+	ULONGEST		*stack = stack_space;
+	/* If true, the actions set $current.  */
+	int			is_set_current = 0;
+
+reswitch:
+	while (pc < ae->u.exp.size) {
+#ifdef GTP_DEBUG
+		printk(GTP_DEBUG "gtp_check_x_simple: cmd %u %x\n", pc,
+		       ebuf[pc]);
+#endif
+		if (stack) {
+			int	arg;
+
+			switch (ebuf[pc]) {
+			/* add */
+			case 0x02:
+				if (sp)
+					top += stack[sp - 1];
+				break;
+
+			/* sub */
+			case 0x03:
+				if (sp)
+					top = stack[sp - 1] - top;
+				break;
+
+			/* mul */
+			case 0x04:
+				if (sp)
+					top *= stack[sp - 1];
+				break;
+
+#ifndef CONFIG_MIPS
+			/* div_signed */
+			case 0x05:
+				if (top && sp) {
+					LONGEST l = (LONGEST) stack[sp - 1];
+					do_div(l, (LONGEST) top);
+					top = l;
+				} else if (top == 0) {
+					printk(KERN_WARNING "gtp_check_x_simple: div_signed "
+							    "0 in %d.\n", pc);
+					goto release_out;
+				}
+				break;
+
+			/* div_unsigned */
+			case 0x06:
+				if (top && sp) {
+					ULONGEST ul = stack[sp - 1];
+					do_div(ul, top);
+					top = ul;
+				} else if (top == 0) {
+					printk(KERN_WARNING "gtp_check_x_simple: div_unsigned "
+							    "0 in %d.\n", pc);
+					goto release_out;
+				}
+				break;
+
+			/* rem_signed */
+			case 0x07:
+				if (top && sp) {
+					LONGEST l1 = (LONGEST) stack[sp - 1];
+					LONGEST l2 = (LONGEST) top;
+					top = do_div(l1, l2);
+				} else if (top == 0) {
+					printk(KERN_WARNING "gtp_check_x_simple: rem_signed "
+							    "0 in %d.\n", pc);
+					goto release_out;
+				}
+				break;
+
+			/* rem_unsigned */
+			case 0x08:
+				if (top && sp) {
+					ULONGEST ul1 = stack[sp - 1];
+					ULONGEST ul2 = top;
+					top = do_div(ul1, ul2);
+				} else if (top == 0) {
+					printk(KERN_WARNING "gtp_check_x_simple: rem_unsigned "
+							    "0 in %d.\n", pc);
+					goto release_out;
+				}
+				break;
+#endif
+			/* lsh */
+			case 0x09:
+				if (sp)
+					top = stack[sp - 1] << top;
+				break;
+
+			/* rsh_signed */
+			case 0x0a:
+				if (sp)
+					top = ((LONGEST) stack[sp - 1]) >> top;
+				break;
+
+			/* rsh_unsigned */
+			case 0x0b:
+				if (sp)
+					top = stack[sp - 1] >> top;
+				break;
+
+			/* log_not */
+			case 0x0e:
+				top = !top;
+				break;
+
+			/* bit_and */
+			case 0x0f:
+				if (sp)
+					top &= stack[sp - 1];
+				break;
+
+			/* bit_or */
+			case 0x10:
+				if (sp)
+					top |= stack[sp - 1];
+				break;
+
+			/* bit_xor */
+			case 0x11:
+				if (sp)
+					top ^= stack[sp - 1];
+				break;
+
+			/* bit_not */
+			case 0x12:
+				top = ~top;
+				break;
+
+			/* equal */
+			case 0x13:
+				if (sp)
+					top = (stack[sp - 1] == top);
+				break;
+
+			/* less_signed */
+			case 0x14:
+				if (sp)
+					top = (((LONGEST) stack[sp - 1])
+						< ((LONGEST) top));
+				break;
+
+			/* less_unsigned */
+			case 0x15:
+				if (sp)
+					top = (stack[sp - 1] < top);
+				break;
+
+			/* ext */
+			case 0x16:
+ 				arg = ebuf[pc + 1];
+				if (arg < (sizeof(LONGEST)*8)) {
+					LONGEST mask = 1 << (arg - 1);
+					top &= ((LONGEST) 1 << arg) - 1;
+					top = (top ^ mask) - mask;
+				}
+				break;
+
+			/* const8 */
+			case 0x22:
+				stack[sp + 1] = top;
+				top = ebuf[pc + 1];
+				break;
+
+			/* const16 */
+			case 0x23:
+				stack[sp + 1] = top;
+				top = ebuf[pc + 1];
+				top = (top << 8) + ebuf[pc + 2];
+				break;
+
+			/* const32 */
+			case 0x24:
+				stack[sp + 1] = top;
+				top = ebuf[pc + 1];
+				top = (top << 8) + ebuf[pc + 2];
+				top = (top << 8) + ebuf[pc + 3];
+				top = (top << 8) + ebuf[pc + 4];
+				break;
+
+			/* const64 */
+			case 0x25:
+				stack[sp + 1] = top;
+				top = ebuf[pc + 1];
+				top = (top << 8) + ebuf[pc + 2];
+				top = (top << 8) + ebuf[pc + 3];
+				top = (top << 8) + ebuf[pc + 4];
+				top = (top << 8) + ebuf[pc + 5];
+				top = (top << 8) + ebuf[pc + 6];
+				top = (top << 8) + ebuf[pc + 7];
+				top = (top << 8) + ebuf[pc + 8];
+				break;
+
+			/* dup */
+			case 0x28:
+				stack[sp + 1] = top;
+				break;
+
+			/* pop */
+			case 0x29:
+				if (sp)
+					top = stack[sp - 1];
+				break;
+
+			/* zero_ext */
+			case 0x2a:
+				arg = ebuf[pc + 1];
+				if (arg < (sizeof(LONGEST)*8))
+					top &= ((LONGEST) 1 << arg) - 1;
+				break;
+
+			/* swap */
+			case 0x2b:
+				if (sp) {
+					stack[sp] = top;
+					top = stack[sp - 1];
+					stack[sp - 1] = stack[sp];
+				}
+				break;
+
+			/* trace */
+			case 0x0c:
+			/* trace_quick */
+			case 0x0d:
+			/* ref8 */
+			case 0x17:
+			/* ref16 */
+			case 0x18:
+			/* ref32 */
+			case 0x19:
+			/* ref64 */
+			case 0x1a:
+			/* if_goto */
+			case 0x20:
+			/* reg */
+			case 0x26:
+			/* getv */
+			case 0x2c:
+				stack = NULL;
+				break;
+			}
+		}
+		switch (ebuf[pc++]) {
+		/* add */
+		case 0x02:
+		/* sub */
+		case 0x03:
+		/* mul */
+		case 0x04:
+		/* lsh */
+		case 0x09:
+		/* rsh_signed */
+		case 0x0a:
+		/* rsh_unsigned */
+		case 0x0b:
+		/* bit_and */
+		case 0x0f:
+		/* bit_or */
+		case 0x10:
+		/* bit_xor */
+		case 0x11:
+		/* equal */
+		case 0x13:
+		/* less_signed */
+		case 0x14:
+		/* less_unsigned */
+		case 0x15:
+		/* pop */
+		case 0x29:
+		/* swap */
+		case 0x2b:
+			if (sp < 1) {
+				printk(KERN_WARNING "gtp_check_x_simple: stack "
+						    "overflow in %d.\n",
+				       pc - 1);
+				goto release_out;
+			} else {
+				if (ebuf[pc - 1] != 0x2b)
+					sp--;
+			}
+			break;
+
+		/* trace */
+		case 0x0c:
+			if (tpe->flags & GTP_ENTRY_FLAGS_HAVE_PRINTK)
+				last_trace_pc = pc - 1;
+
+			if (sp < 2) {
+				printk(KERN_WARNING "gtp_check_x_simple: stack "
+						    "overflow in %d.\n",
+				       pc - 1);
+				goto release_out;
+			} else
+				sp -= 2;
+			break;
+
+		/* log_not */
+		case 0x0e:
+		/* bit_not */
+		case 0x12:
+		/* ref8 */
+		case 0x17:
+		/* ref16 */
+		case 0x18:
+		/* ref32 */
+		case 0x19:
+		/* ref64 */
+		case 0x1a:
+			break;
+
+		/* dup */
+		case 0x28:
+			sp++;
+			if (sp_max < sp)
+				sp_max = sp;
+			break;
+
+		/* const8 */
+		case 0x22:
+			sp++;
+			if (sp_max < sp)
+				sp_max = sp;
+		/* ext */
+		case 0x16:
+		/* zero_ext */
+		case 0x2a:
+			if (pc >= ae->u.exp.size)
+				goto release_out;
+			pc++;
+			break;
+
+		/* trace_quick */
+		case 0x0d:
+			if (tpe->flags & GTP_ENTRY_FLAGS_HAVE_PRINTK)
+				last_trace_pc = pc - 1;
+
+			if (pc >= ae->u.exp.size)
+				goto release_out;
+			pc++;
+			break;
+
+		/* const16 */
+		case 0x23:
+		/* reg */
+		case 0x26:
+			if (pc + 1 >= ae->u.exp.size)
+				goto release_out;
+			pc += 2;
+
+			sp++;
+			if (sp_max < sp)
+				sp_max = sp;
+			break;
+
+		/* const32 */
+		case 0x24:
+			if (pc + 3 >= ae->u.exp.size)
+				goto release_out;
+			pc += 4;
+
+			sp++;
+			if (sp_max < sp)
+				sp_max = sp;
+			break;
+
+		/* const64 */
+		case 0x25:
+			if (pc + 7 >= ae->u.exp.size)
+				goto release_out;
+			pc += 8;
+
+			sp++;
+			if (sp_max < sp)
+				sp_max = sp;
+			break;
+
+		/* if_goto */
+		case 0x20:
+			if (tpe->flags & GTP_ENTRY_FLAGS_HAVE_PRINTK) {
+				printk(KERN_WARNING "If_goto action doesn't"
+				       "support printk.\n");
+				goto release_out;
+			}
+			if (pc + 1 >= ae->u.exp.size)
+				goto release_out;
+
+			{
+				unsigned int	dpc = (ebuf[pc] << 8)
+						      + ebuf[pc + 1];
+
+				if (dpc < pc) {
+					/* This action X include loop. */
+					if (is_set_current)
+						printk(KERN_WARNING "KGTP: cannot set $current inside loop.\n");
+					else {
+						ae->type = 0xff;
+						ret = 0;
+					}
+					goto release_out;
+				}
+
+				if (!gtp_x_if_goto_add(&glist, dpc, sp)) {
+					ret = -ENOMEM;
+					goto release_out;
+				}
+			}
+
+			pc += 2;
+			break;
+
+		/* goto */
+		case 0x21:
+			if (pc + 1 >= ae->u.exp.size)
+				goto release_out;
+
+			{
+				unsigned int	dpc = (ebuf[pc] << 8)
+						      + ebuf[pc + 1];
+
+				if (dpc < pc) {
+					/* This action X include loop. */
+					if (is_set_current)
+						printk(KERN_WARNING "KGTP: cannot set $current inside loop.\n");
+					else {
+						ae->type = 0xff;
+						ret = 0;
+					}
+					goto release_out;
+				}
+
+				pc = dpc;
+			}
+			break;
+
+		/* end */
+		case 0x27:
+			goto out;
+			break;
+
+		/* getv */
+		case 0x2c: {
+				int lret = gtp_check_getv(tpe, ae, step,
+							  ebuf, pc, &vlist);
+				if (lret != 0) {
+					ret = lret;
+					goto release_out;
+				}
+				pc += 2;
+
+				sp++;
+				if (sp_max < sp)
+					sp_max = sp;
+			}
+			break;
+
+		/* setv */
+		case 0x2d: {
+				int lret = gtp_check_setv(tpe, ae, step,
+							  ebuf, pc, &vlist,
+							  0, stack, top);
+				if (lret == 1 || lret < 0) {
+					ret = lret;
+					goto release_out;
+				}
+				if (lret == 2)
+					is_set_current = 1;
+				pc += 2;
+			}
+			break;
+
+		/* tracev */
+		case 0x2e: {
+				int	lret;
+
+				if (tpe->flags & GTP_ENTRY_FLAGS_HAVE_PRINTK)
+					last_trace_pc = pc - 1;
+
+				lret = gtp_check_getv(tpe, ae, step, ebuf,
+						      pc, &vlist);
+				if (lret != 0) {
+					ret = lret;
+					goto release_out;
+				}
+				pc += 2;
+			}
+			break;
+
+		/* div_signed */
+		case 0x05:
+		/* div_unsigned */
+		case 0x06:
+		/* rem_signed */
+		case 0x07:
+		/* rem_unsigned */
+		case 0x08:
+#ifdef CONFIG_MIPS
+			/* XXX, mips don't have 64 bit div.  */
+			goto release_out;
+#endif
+			if (sp < 1) {
+				printk(KERN_WARNING "gtp_check_x_simple: stack "
+						    "overflow in %d.\n",
+				       pc - 1);
+				goto release_out;
+			} else
+				sp--;
+			break;
+
+		/* float */
+		case 0x01:
+		/* ref_float */
+		case 0x1b:
+		/* ref_double */
+		case 0x1c:
+		/* ref_long_double */
+		case 0x1d:
+		/* l_to_d */
+		case 0x1e:
+		/* d_to_l */
+		case 0x1f:
+		/* trace16 */
+		case 0x30:
+		default:
+			goto release_out;
+			break;
+		}
+	}
+	goto release_out;
+
+out:
+#ifdef GTP_DEBUG
+	printk(GTP_DEBUG "sp_max = %d\n", sp_max);
+#endif
+	if (sp_max >= STACK_MAX) {
+		printk(KERN_WARNING "gtp_check_x_simple: stack overflow, "
+				    "current %d, max %d.\n",
+		       sp_max, STACK_MAX);
+		goto release_out;
+	}
+	if (glist) {
+		pc = glist->ip;
+		sp = glist->sp;
+		gtmp = glist;
+		glist = glist->next;
+		kfree(gtmp);
+		goto reswitch;
+	}
+	if (is_set_current)
+		ret = 2;
+	else
+		ret = 0;
+#ifdef GTP_DEBUG
+	printk(GTP_DEBUG "gtp_check_x_simple: Code is OK. sp_max is %d.\n",
+	       sp_max);
+#endif
+
+release_out:
+	while (glist) {
+		gtmp = glist;
+		glist = glist->next;
+		kfree(gtmp);
+	}
+	while (vlist) {
+		vtmp = vlist;
+		vlist = vlist->next;
+
+		if ((vtmp->flags & 1) && (vtmp->flags & 2))
+			ae->u.exp.need_var_lock = 1;
+		kfree(vtmp);
+	}
+
+	if (!is_set_current && (tpe->flags & GTP_ENTRY_FLAGS_HAVE_PRINTK)
+	    && last_trace_pc > -1) {
+		/* Set the last trace code to printk code.  */
+		switch (ebuf[last_trace_pc]) {
+		/* trace */
+		case 0x0c:
+			ebuf[last_trace_pc] = op_trace_printk;
+			break;
+		/* trace_quick */
+		case 0x0d:
+			ebuf[last_trace_pc] = op_trace_quick_printk;
+			break;
+		/* tracev */
+		case 0x2e:
+			ebuf[last_trace_pc] = op_tracev_printk;
+			break;
+		}
+	}
+
+	return ret;
+}
+
+/* The second check.
+   Special check for loop.
+   Different with gtp_check_x_simple is it will not check sp_max.  */
+
+static int
+gtp_check_x_loop(struct gtp_entry *tpe, struct action *ae, int step)
+{
+	int			ret = -EINVAL;
+	unsigned int		pc = 0;
+	struct gtp_x_loop	*glist = NULL, *gtmp;
+	struct gtp_x_var	*vlist = NULL, *vtmp;
+	uint8_t			*ebuf = ae->u.exp.buf;
+
+	printk(KERN_WARNING "Action of tracepoint %d have loop.\n",
+	       (int)tpe->num);
+
+	tpe->flags &= ~GTP_ENTRY_FLAGS_HAVE_PRINTK;
+
+reswitch:
+	while (pc < ae->u.exp.size) {
+#ifdef GTP_DEBUG
+		printk(GTP_DEBUG "gtp_check_x_loop: cmd %x\n", ebuf[pc]);
+#endif
+		switch (ebuf[pc++]) {
+		/* add */
+		case 0x02:
+			ebuf[pc - 1] = op_check_add;
+			break;
+		/* sub */
+		case 0x03:
+			ebuf[pc - 1] = op_check_sub;
+			break;
+		/* mul */
+		case 0x04:
+			ebuf[pc - 1] = op_check_mul;
+			break;
+		/* lsh */
+		case 0x09:
+			ebuf[pc - 1] = op_check_lsh;
+			break;
+		/* rsh_signed */
+		case 0x0a:
+			ebuf[pc - 1] = op_check_rsh_signed;
+			break;
+		/* rsh_unsigned */
+		case 0x0b:
+			ebuf[pc - 1] = op_check_rsh_unsigned;
+			break;
+		/* bit_and */
+		case 0x0f:
+			ebuf[pc - 1] = op_check_bit_and;
+			break;
+		/* bit_or */
+		case 0x10:
+			ebuf[pc - 1] = op_check_bit_or;
+			break;
+		/* bit_xor */
+		case 0x11:
+			ebuf[pc - 1] = op_check_bit_xor;
+			break;
+		/* equal */
+		case 0x13:
+			ebuf[pc - 1] = op_check_equal;
+			break;
+		/* less_signed */
+		case 0x14:
+			ebuf[pc - 1] = op_check_less_signed;
+			break;
+		/* less_unsigned */
+		case 0x15:
+			ebuf[pc - 1] = op_check_less_unsigned;
+			break;
+		/* pop */
+		case 0x29:
+			ebuf[pc - 1] = op_check_pop;
+			break;
+		/* swap */
+		case 0x2b:
+			ebuf[pc - 1] = op_check_swap;
+			break;
+
+		/* trace */
+		case 0x0c:
+			ebuf[pc - 1] = op_check_trace;
+			break;
+
+		/* log_not */
+		case 0x0e:
+		/* bit_not */
+		case 0x12:
+		/* ref8 */
+		case 0x17:
+		/* ref16 */
+		case 0x18:
+		/* ref32 */
+		case 0x19:
+		/* ref64 */
+		case 0x1a:
+		/* dup */
+		case 0x28:
+			break;
+
+		/* const8 */
+		case 0x22:
+		/* ext */
+		case 0x16:
+		/* zero_ext */
+		case 0x2a:
+		/* trace_quick */
+		case 0x0d:
+			if (pc >= ae->u.exp.size)
+				goto release_out;
+			pc++;
+			break;
+
+		/* const16 */
+		case 0x23:
+		/* reg */
+		case 0x26:
+			if (pc + 1 >= ae->u.exp.size)
+				goto release_out;
+			pc += 2;
+			break;
+
+		/* const32 */
+		case 0x24:
+			if (pc + 3 >= ae->u.exp.size)
+				goto release_out;
+			pc += 4;
+			break;
+
+		/* const64 */
+		case 0x25:
+			if (pc + 7 >= ae->u.exp.size)
+				goto release_out;
+			pc += 8;
+			break;
+
+		/* if_goto */
+		case 0x20:
+		case op_check_if_goto:
+			ebuf[pc - 1] = op_check_if_goto;
+
+			if (pc + 1 >= ae->u.exp.size)
+				goto release_out;
+
+			gtmp = gtp_x_loop_find(glist, pc);
+			if (gtmp) {
+				if (gtmp->non_goto_done)
+					goto out;
+				else {
+					gtmp->non_goto_done = 1;
+					pc += 2;
+				}
+			} else {
+				if (!gtp_x_loop_add(&glist, pc, 0)) {
+					ret = -ENOMEM;
+					goto release_out;
+				}
+				pc = (ebuf[pc] << 8) + ebuf[pc + 1];
+			}
+			break;
+
+		/* goto */
+		case 0x21:
+			if (pc + 1 >= ae->u.exp.size)
+				goto release_out;
+
+			gtmp = gtp_x_loop_find(glist, pc);
+			if (gtmp)
+				goto out;
+			else {
+				if (!gtp_x_loop_add(&glist, pc, 1)) {
+					ret = -ENOMEM;
+					goto release_out;
+				}
+			}
+
+			pc = (ebuf[pc] << 8) + (ebuf[pc + 1]);
+			break;
+
+		/* end */
+		case 0x27:
+			goto out;
+			break;
+
+		/* getv */
+		case 0x2c:
+		/* tracev */
+		case 0x2e: {
+				int lret = gtp_check_getv(tpe, ae, step,
+							  ebuf, pc, &vlist);
+				if (lret != 0) {
+					ret = lret;
+					goto release_out;
+				}
+				pc += 2;
+			}
+			break;
+
+		/* setv */
+		case 0x2d: {
+				int lret = gtp_check_setv(tpe, ae, step,
+							  ebuf, pc, &vlist,
+							  1, NULL, 0);
+				if (lret == 1 || lret < 0) {
+					ret = lret;
+					goto release_out;
+				}
+				if (lret == 2) {
+					printk(KERN_WARNING "KGTP: cannot set $current inside loop.\n");
+					goto release_out;
+				}
+			}
+			break;
+
+		/* div_signed */
+		case 0x05:
+#ifdef CONFIG_MIPS
+			/* XXX, mips don't have 64 bit div.  */
+			printk(KERN_WARNING "MIPS don't have 64 bit div.\n");
+			goto release_out;
+#endif
+			ebuf[pc - 1] = op_check_div_signed;
+			break;
+		/* div_unsigned */
+		case 0x06:
+#ifdef CONFIG_MIPS
+			/* XXX, mips don't have 64 bit div.  */
+			printk(KERN_WARNING "MIPS don't have 64 bit div.\n");
+			goto release_out;
+#endif
+			ebuf[pc - 1] = op_check_div_unsigned;
+			break;
+		/* rem_signed */
+		case 0x07:
+#ifdef CONFIG_MIPS
+			/* XXX, mips don't have 64 bit div.  */
+			printk(KERN_WARNING "MIPS don't have 64 bit div.\n");
+			goto release_out;
+#endif
+			ebuf[pc - 1] = op_check_rem_signed;
+			break;
+		/* rem_unsigned */
+		case 0x08:
+#ifdef CONFIG_MIPS
+			/* XXX, mips don't have 64 bit div.  */
+			printk(KERN_WARNING "MIPS don't have 64 bit div.\n");
+			goto release_out;
+#endif
+			ebuf[pc - 1] = op_check_rem_unsigned;
+			break;
+
+		/* float */
+		case 0x01:
+		/* ref_float */
+		case 0x1b:
+		/* ref_double */
+		case 0x1c:
+		/* ref_long_double */
+		case 0x1d:
+		/* l_to_d */
+		case 0x1e:
+		/* d_to_l */
+		case 0x1f:
+		/* trace16 */
+		case 0x30:
+		default:
+			goto release_out;
+			break;
+		}
+	}
+	goto release_out;
+
+out:
+	for (gtmp = glist; gtmp; gtmp = gtmp->next) {
+		if (!gtmp->non_goto_done)
+			break;
+	}
+	if (gtmp) {
+		pc = gtmp->addr + 2;
+		gtmp->non_goto_done = 1;
+		goto reswitch;
+	}
+	ret = 0;
+
+release_out:
+	while (glist) {
+		gtmp = glist;
+		glist = glist->next;
+		kfree(gtmp);
+	}
+	while (vlist) {
+		vtmp = vlist;
+		vlist = vlist->next;
+
+		if ((vtmp->flags & 2)
+		    && ((vtmp->flags & 1) || (vtmp->flags & 4)))
+			ae->u.exp.need_var_lock = 1;
+		kfree(vtmp);
+	}
+
+	return ret;
+}
+
+static int
+gtp_check_x(struct gtp_entry *tpe, struct action *ae, int step)
+{
+	int	ret = gtp_check_x_simple(tpe, ae, step);
+
+	if (ret != 0 || ae->type == 'X')
+		return ret;
+
+	return gtp_check_x_loop(tpe, ae, step);
+}
+
+#if defined(GTP_FTRACE_RING_BUFFER) || defined(GTP_RB)
+static void
+gtpframe_pipe_wq_wake_up(unsigned long data)
+{
+	/* About why KGTP use a tasklet to wake up:
+	   When a tracepoint that is inserted to "schedule" function
+	   call wake up inside its handler, the kernel maybe will deadlock.
+	   "tasklet_schedule" is a small function and it can be
+	   very easy controlled to wake up softirqd or not
+	   (add_preempt_count(HARDIRQ_OFFSET) can control it). 
+	   So KGTP just use it to wake up a task.  */
+	wake_up_interruptible_nr(&gtpframe_pipe_wq, 1);
+}
+#endif
+
+static void
+gtp_wq_add_work(unsigned long data)
+{
+	/* Same with prev function, queue_work will wake up sometimes.  */
+	queue_work(gtp_wq, (struct work_struct *)data);
+}
+
+static int
+gtp_gdbrsp_qtstart(void)
+{
+	int			ret = -EINVAL;
+	int			cpu;
+	struct gtp_entry	*tpe;
+	int			i;
+	struct gtp_var		*var;
+	struct list_head	*cur;
+#ifdef CONFIG_X86
+	unsigned long		flags;
+#endif
+
+#ifdef GTP_DEBUG
+	printk(GTP_DEBUG "gtp_gdbrsp_qtstart\n");
+#endif
+
+	if (gtp_start)
+		return -EBUSY;
+
+#ifdef GTP_FTRACE_RING_BUFFER
+	if (!tracing_is_on()) {
+		printk(KERN_WARNING "qtstart: Ring buffer is off.  Please use "
+		       "command "
+		       "\"echo 1 > /sys/kernel/debug/tracing/tracing_on\" "
+		       "open it.\n");
+		return -EIO;
+	}
+#endif
+
+	/* Setup the gtp_var_array.
+	   It must be setup before action because action need it.  */
+	gtp_var_array = kcalloc(gtp_var_num, sizeof(struct gtp_var *),
+				GFP_KERNEL);
+	if (!gtp_var_array)
+		return -ENOMEM;
+	i = 0;
+	list_for_each(cur, &gtp_var_list) {
+		var = list_entry(cur, struct gtp_var, node);
+		gtp_var_array[i] = var;
+		i++;
+	}
+#ifdef GTP_RB
+	var = gtp_var_find_num(GTP_STEP_ID_ID);
+	if (var == NULL) {
+		printk(KERN_WARNING "KGTP: cannot get $step_id.\n");
+		return -EINVAL;
+	}
+	gtp_var_array_step_id_id = gtp_var_array_find_num(var);
+	if (gtp_var_array_step_id_id < 0) {
+		printk(KERN_WARNING "KGTP: cannot get $step_id.\n");
+		return -EINVAL;
+	}
+#endif
+
+	/* Check and setup actions.  */
+	for (tpe = gtp_list; tpe; tpe = tpe->next) {
+		struct list_head	*head, *cur, *tmp;
+		struct action		*ae;
+
+		/* Check tpe->step for old version GDB without patch
+		   http://sourceware.org/ml/gdb-cvs/2013-04/msg00044.html  */
+		if (tpe->step != 0 && list_empty(&tpe->step_action_list))
+			tpe->step = 0;
+
+		/* Check cond.  */
+		if (tpe->cond) {
+			int	lret = gtp_check_x(tpe, tpe->cond, 0);
+			if (lret == 1) {
+				printk(KERN_WARNING "KGTP: cannot set special TSV inside condition.\n");
+				goto out;
+			} else if (lret == 2) {
+				printk(KERN_WARNING "KGTP: cannot set $current inside condition.\n");
+				goto out;
+			} else if (lret != 0) {
+				ret = lret;
+				printk(KERN_WARNING "KGTP: gtp_check_x get error %d\n",
+				       lret);
+				goto out;
+			}
+		}
+
+		/* Check X.  */
+		head = &tpe->action_list;
+next_list:
+		list_for_each_safe(cur, tmp, head) {
+			ae = list_entry(cur, struct action, node);
+			if (ae->type == 'X' || ae->type == 0xff) {
+				int lret = gtp_check_x(tpe, ae,
+						       (head == &tpe->step_action_list));
+				if (lret == 1) {
+					/* Remove ae from action_list.  */
+					list_del(&ae->node);
+					gtp_action_release(ae);
+				} else if (lret == 2) {
+					/* Set this actions to get_regs.  */
+					gtp_action_release(tpe->get_regs);
+					list_del(&ae->node);
+					tpe->get_regs = ae;
+				} else if (lret != 0) {
+					printk(KERN_WARNING "KGTP: gtp_check_x get error %d\n",
+					       lret);
+					goto out;
+				}
+			}
+		}
+		if (head == &tpe->action_list) {
+			/* Begin to check step_action_list.  */
+			head = &tpe->step_action_list;
+			goto next_list;
+		}
+
+		/* Check the tracepoint that have printk.  */
+		if (tpe->flags & GTP_ENTRY_FLAGS_HAVE_PRINTK) {
+			struct gtpsrc	*src, *srctail = NULL;
+
+			list_for_each_safe(cur, tmp, &tpe->action_list) {
+				ae = list_entry(cur, struct action, node);
+				switch (ae->type) {
+				case 'R':
+					/* Remove it. */
+					list_del(&ae->node);
+					gtp_action_release(ae);
+					break;
+				case 'M':
+					printk(KERN_WARNING "qtstart: action "
+					       "of tp %d %p is not right.  "
+					       "Please put global variable to "
+					       "trace state variable "
+					       "$printk_tmp before print it.\n",
+					       (int)tpe->num,
+					       (void *)(CORE_ADDR)tpe->addr);
+					ret = -EINVAL;
+					goto out;
+					break;
+				}
+			}
+
+			for (src = tpe->src; src; src = src->next) {
+				int		i;
+				char		str[strlen(src->src) >> 1];
+				char		*var = NULL;
+				ULONGEST	num;
+				char		tmp[30];
+				struct gtpsrc	*ksrc;
+
+#ifdef GTP_DEBUG
+				printk(GTP_DEBUG "gtp_gdbrsp_qtstart: action "
+						 "%s\n", src->src);
+#endif
+				/* Get the action in str.  */
+				if (strncmp("cmd:0:", src->src,
+					    strlen("cmd:0:")))
+					continue;
+				var = hex2ulongest(src->src + 6, &num);
+				if (var[0] == '\0')
+					goto out;
+				var++;
+				hex2string(var, str);
+				if (strlen(str) != num)
+					goto out;
+#ifdef GTP_DEBUG
+				printk(GTP_DEBUG "gtp_gdbrsp_qtstart: action "
+						 "command %s\n", str);
+#endif
+
+				if (strncmp("collect ", str,
+					    strlen("collect ")))
+					continue;
+				for (i = strlen("collect "); ; i++) {
+					if (str[i] != ' ') {
+						var = str + i;
+						break;
+					}
+					if (str[i] == '\0')
+						break;
+				}
+				if (!var) {
+					printk(KERN_WARNING "qtstart: cannot "
+							    "get the var name "
+							    "from tp %d %p"
+							    "command %s.\n",
+					       (int)tpe->num,
+					       (void *)(CORE_ADDR)tpe->addr,
+					       str);
+					goto out;
+				}
+				if (strcmp(var, "$args") == 0
+				    || strcmp(var, "$local") == 0) {
+					printk(KERN_WARNING "qtstart: cannot "
+							    "print $args and "
+							    "$local.\n");
+					goto out;
+				}
+				if (strcmp(var, "$reg") == 0)
+					continue;
+
+				if (var[0] == '$') {
+					/* Check if var is TSV that cannot get in action.  */
+					char		src[3 + strlen(var) * 2];
+					struct gtp_var	*tsv;
+
+					strcpy(src, "1:");
+					string2hex (var + 1, src + 2);
+					tsv = gtp_var_find_src(src);
+					if (tsv
+					    && tsv->type == gtp_var_special
+					    && !tsv->u.hooks->agent_get_val)
+						continue;
+				}
+
+				ksrc = kmalloc(sizeof(struct gtpsrc),
+					       GFP_KERNEL);
+				if (ksrc == NULL) {
+					ret = -ENOMEM;
+					goto out;
+				}
+				ksrc->next = NULL;
+
+				snprintf(tmp, 30, "gtp %d %p:", (int)tpe->num,
+					 (void *)(CORE_ADDR)tpe->addr);
+				ksrc->src = kmalloc(strlen(tmp)
+						   + strlen(var) + 2,
+						   GFP_KERNEL);
+				if (ksrc->src == NULL) {
+					kfree(ksrc);
+					ret = -ENOMEM;
+					goto out;
+				}
+				sprintf(ksrc->src, "%s%s=", tmp, var);
+
+#ifdef GTP_DEBUG
+				printk(GTP_DEBUG "gtp_gdbrsp_qtstart: new "
+						 "printk var %s\n", ksrc->src);
+#endif
+
+				if (tpe->printk_str)
+					srctail->next = ksrc;
+				else
+					tpe->printk_str = ksrc;
+				srctail = ksrc;
+			}
+		}
+	}
+
+#if defined(GTP_FTRACE_RING_BUFFER)			\
+    && (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,39))	\
+    && !defined(GTP_SELF_RING_BUFFER)
+	if (gtp_frame && gtp_circular_is_changed) {
+		ring_buffer_free(gtp_frame);
+		gtp_frame = NULL;
+	}
+	gtp_circular_is_changed = 0;
+#endif
+
+#ifdef GTP_RB
+	if (GTP_RB_PAGE_IS_EMPTY) {
+		if (gtp_rb_page_alloc(GTP_FRAME_SIZE) != 0) {
+			ret = -ENOMEM;
+			goto out;
+		}
+#endif
+#if defined(GTP_FRAME_SIMPLE) || defined(GTP_FTRACE_RING_BUFFER)
+	if (!gtp_frame) {
+#ifdef GTP_FRAME_SIMPLE
+		gtp_frame = vmalloc(GTP_FRAME_SIZE);
+#endif
+#ifdef GTP_FTRACE_RING_BUFFER
+		gtp_frame = ring_buffer_alloc(GTP_FRAME_SIZE,
+					      gtp_circular ? RB_FL_OVERWRITE
+							     : 0);
+#endif
+		if (!gtp_frame) {
+			ret = -ENOMEM;
+			goto out;
+		}
+#endif
+
+		gtp_frame_reset();
+	}
+
+	for_each_online_cpu(cpu) {
+#ifdef CONFIG_X86
+		per_cpu(rdtsc_current, cpu) = 0;
+		per_cpu(rdtsc_offset, cpu) = 0;
+#endif
+		per_cpu(local_clock_current, cpu) = 0;
+		per_cpu(local_clock_offset, cpu) = 0;
+		per_cpu(gtp_handler_began, cpu) = 0;
+	}
+
+	gtp_start = 1;
+
+#ifdef GTP_PERF_EVENTS
+	/* Clear pc_pe_list.  */
+	for_each_online_cpu(cpu) {
+		per_cpu(pc_pe_list, cpu) = NULL;
+		per_cpu(pc_pe_list_all_disabled, cpu) = 1;
+	}
+	list_for_each(cur, &gtp_var_list) {
+		struct gtp_var_perf_event	*pe;
+		var = list_entry(cur, struct gtp_var, node);
+
+		if (var->type != gtp_var_perf_event
+		    && var->type != gtp_var_perf_event_per_cpu)
+			continue;
+		if (var->type == gtp_var_perf_event_per_cpu
+		    && var->u.pc.cpu < 0)
+			continue;
+		pe = gtp_var_get_pe(var)->pe;
+		if (pe->event)
+			continue;
+
+#ifdef GTP_DEBUG
+		printk(GTP_DEBUG "gtp_gdbrsp_qtstart:"
+			         "create perf_event CPU%d %d %d.\n",
+		       (int)pe->cpu, (int)pe->attr.type, (int)pe->attr.config);
+#endif
+		
+		/* Get event.  */
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3,1,0)) \
+       || (RHEL_RELEASE_CODE >= RHEL_RELEASE_VERSION(6,3))
+		pe->event = perf_event_create_kernel_counter(&(pe->attr),
+							     pe->cpu,
+							     NULL, NULL,
+							     NULL);
+#elif (LINUX_VERSION_CODE > KERNEL_VERSION(2,6,36)) \
+       || (RHEL_RELEASE_CODE >= RHEL_RELEASE_VERSION(6,1))
+		pe->event =
+			perf_event_create_kernel_counter(&(pe->attr),
+							 pe->cpu,
+							 NULL, NULL);
+#else
+		pe->event =
+			perf_event_create_kernel_counter(&(pe->attr),
+							 pe->cpu,
+							 -1, NULL);
+#endif
+		if (IS_ERR(pe->event)) {
+			int	ret = PTR_ERR(pe->event);
+
+			printk(KERN_WARNING "gtp_gdbrsp_qtstart:"
+			       "create perf_event CPU%d %d %d got error.\n",
+			       (int)pe->cpu, (int)pe->attr.type,
+			       (int)pe->attr.config);
+			pe->event = NULL;
+			gtp_gdbrsp_qtstop();
+			return ret;
+		}
+
+		/* Add event to pc_pe_list.  */
+		if (pe->cpu >= 0) {
+			struct gtp_var_perf_event *ppl = per_cpu(pc_pe_list,
+								 pe->cpu);
+			if (ppl == NULL) {
+				per_cpu(pc_pe_list, pe->cpu) = pe;
+				pe->pc_next = NULL;
+			} else {
+				pe->pc_next = ppl;
+				per_cpu(pc_pe_list,
+					pe->cpu) = pe;
+			}
+			if (pe->en)
+				per_cpu(pc_pe_list_all_disabled, pe->cpu)
+					= 0;
+		}
+	}
+#endif
+
+#if defined(GTP_FTRACE_RING_BUFFER) || defined(GTP_RB)
+	tasklet_init(&gtpframe_pipe_wq_tasklet, gtpframe_pipe_wq_wake_up, 0);
+#endif
+
+	/* Init tracepoint and do last tracepoint check. */
+#ifdef CONFIG_X86
+	if (gtp_have_step && gtp_have_watch_tracepoint) {
+		printk(KERN_WARNING "KGTP: watch tracepoint cannot work together with while-stepping.\n");
+		gtp_gdbrsp_qtstop();
+		return -EINVAL;
+	}
+#endif
+
+	gtp_start_last_errno = 0;
+	for (tpe = gtp_list; tpe; tpe = tpe->next) {
+		if ((tpe->flags & GTP_ENTRY_FLAGS_IS_KRETPROBE)
+		    && (tpe->step || tpe->type != gtp_entry_kprobe
+#ifdef CONFIG_X86
+		    || gtp_have_step)) {
+#else
+		    )) {
+#endif
+			printk(KERN_WARNING "KGTP: $kret cannot use with while-stepping or watch.\n");
+			gtp_gdbrsp_qtstop();
+			return -EINVAL;
+		}
+		tpe->reason = gtp_stop_normal;
+		if (tpe->flags & GTP_ENTRY_FLAGS_HAVE_PASS)
+			atomic_set(&tpe->current_pass, tpe->pass);
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,30))
+		tasklet_init(&tpe->enable_tasklet, gtp_wq_add_work,
+			     (unsigned long)&tpe->enable_work);
+		tasklet_init(&tpe->disable_tasklet, gtp_wq_add_work,
+			     (unsigned long)&tpe->disable_work);
+#endif
+	}
+
+#ifdef CONFIG_X86
+	/* Start hwb.  */
+	if (gtp_have_watch_tracepoint) {
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3,0,0))
+		{
+			struct perf_event_attr attr;
+
+			hw_breakpoint_init(&attr);
+			attr.bp_len = HW_BREAKPOINT_LEN_1;
+			attr.bp_type = HW_BREAKPOINT_W;
+
+			/* Register hw breakpoints.  */
+			for (i = 0; i < HWB_NUM; i++) {
+				perf_overflow_handler_t	triggered;
+				/* Step 1: Set the id to addr and let following code check it.
+				   Make sure the num of a hw. */
+				attr.bp_addr = i;
+				switch (i) {
+				case 0:
+					triggered = gtp_hw_breakpoint_0_handler;
+					break;
+				case 1:
+					triggered = gtp_hw_breakpoint_1_handler;
+					break;
+				case 2:
+					triggered = gtp_hw_breakpoint_2_handler;
+					break;
+				case 3:
+					triggered = gtp_hw_breakpoint_3_handler;
+					break;
+				}
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3,1,0))
+				breakinfo[i].pev = register_wide_hw_breakpoint(&attr, triggered, NULL);
+#else
+				breakinfo[i].pev = register_wide_hw_breakpoint(&attr, triggered);
+#endif
+				if (IS_ERR((void * __force)breakinfo[i].pev)) {
+					printk(KERN_WARNING "KGTP: Could not allocate hw breakpoints.\n");
+					breakinfo[i].pev = NULL;
+					gtp_gdbrsp_qtstop();
+					return PTR_ERR((void * __force)breakinfo[i].pev);
+				}
+			}
+
+			/* Step 2: Make sure breakinfo[i] is which hw breakpoint and set
+			   it to breakinfo[i].num.  */
+			for (i = 0; i < HWB_NUM; i++) {
+				unsigned long	num;
+
+				gtp_get_debugreg(num, i);
+				breakinfo[num].num = i;
+			}
+		}
+#endif
+
+		gtp_hwb_stop(NULL);
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,27))
+		smp_call_function(gtp_hwb_stop, NULL, 1);
+#else
+		smp_call_function(gtp_hwb_stop, NULL, 0, 1);
+#endif
+
+		write_lock_irqsave(&gtp_hwb_lock, flags);
+		INIT_LIST_HEAD(&gtp_hwb_used_list);
+		INIT_LIST_HEAD(&gtp_hwb_unused_list);
+		for (i = 0; i < HWB_NUM; i++) {
+			gtp_hwb[i].num = i;
+			gtp_hwb[i].watch = NULL;
+			gtp_hwb_drx[i] = 0;
+			list_add(&(gtp_hwb[i].node), &gtp_hwb_unused_list);
+		}
+		gtp_hwb_dr7 = GTP_HWB_DR7_DEF;
+
+		gtp_hwb_sync_count = 0;
+		for_each_online_cpu(cpu) {
+			per_cpu(gtp_hwb_sync_count_local, cpu) = gtp_hwb_sync_count;
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,27))
+			cpumask_copy(&(per_cpu(gtp_hwb_sync_cpu_mask, cpu)),
+				     cpu_online_mask);
+			cpumask_clear_cpu(cpu, &(per_cpu(gtp_hwb_sync_cpu_mask, cpu)));
+#endif
+		}
+		write_unlock_irqrestore(&gtp_hwb_lock, flags);
+
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,27))
+		/* Register kprobe handler for IPI.  */
+		memset (&gtp_ipi_kp, '\0', sizeof(gtp_ipi_kp));
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3,9,0))
+		gtp_ipi_kp.symbol_name = "generic_smp_call_function_single_interrupt";
+#else
+		gtp_ipi_kp.symbol_name = "generic_smp_call_function_interrupt";
+#endif
+		gtp_ipi_kp.pre_handler = gtp_ipi_handler;
+		ret = register_kprobe(&gtp_ipi_kp);
+		if (ret) {
+			printk(KERN_WARNING "KGTP: try to register handler on IPI got error.\n");
+			gtp_gdbrsp_qtstop();
+			return ret;
+		}
+#endif
+
+		/* Register static watch.  */
+		for (tpe = gtp_list; tpe; tpe = tpe->next) {
+			struct gtp_hwb_s	arg;
+
+			if (tpe->type == gtp_entry_kprobe || tpe->disable)
+				continue;
+
+			if (tpe->type == gtp_entry_watch_static) {
+				arg.addr = tpe->addr;
+				arg.size = tpe->u.watch.size;
+				arg.type = tpe->u.watch.type;
+				arg.trace_num = tpe->num;
+				arg.trace_addr = tpe->addr;
+				arg.watch = tpe;
+				ret = gtp_register_hwb(&arg, 0);
+				if (ret < 0) {
+					printk(KERN_WARNING "gtp_gdbrsp_qtstart: register watchpoint %d %p got error.\n",
+					(int)tpe->num, (void *)(CORE_ADDR)tpe->addr);
+					if (gtp_start_ignore_error) {
+						gtp_start_last_errno = (uint64_t)ret;
+						continue;
+					} else {
+						gtp_gdbrsp_qtstop();
+						return ret;
+					}
+				}
+			}
+
+			tpe->flags |= GTP_ENTRY_FLAGS_REG;
+		}
+	}
+#endif
+
+#ifdef CONFIG_X86
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(3,0,0))
+	if (gtp_have_step || gtp_have_watch_tracepoint) {
+#else
+	if (gtp_have_step) {
+#endif
+		/* Register notifier.  */
+		ret = register_die_notifier(&gtp_notifier);
+		if (ret) {
+			gtp_gdbrsp_qtstop();
+			return ret;
+		}
+	}
+#endif
+
+	/* Register kprobe.  */
+	for (tpe = gtp_list; tpe; tpe = tpe->next) {
+		if (tpe->type != gtp_entry_kprobe)
+			continue;
+
+		tasklet_init(&tpe->u.kp.stop_tasklet, gtp_wq_add_work,
+			     (unsigned long)&tpe->u.kp.stop_work);
+
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,30))
+		if (tpe->disable)
+			tpe->u.kp.kpret.kp.flags |= KPROBE_FLAG_DISABLED;
+#endif
+
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,30))
+		if (tpe->addr != 0) {
+#else
+		if (tpe->disable == 0 && tpe->addr != 0) {
+#endif
+			tpe->u.kp.kpret.kp.addr = (kprobe_opcode_t *) (CORE_ADDR)tpe->addr;
+			if (tpe->flags & GTP_ENTRY_FLAGS_IS_KRETPROBE) {
+				if (gtp_access_cooked_clock
+#ifdef CONFIG_X86
+				    || gtp_access_cooked_rdtsc
+#endif
+#ifdef GTP_PERF_EVENTS
+				    || gtp_have_pc_pe
+#endif
+				)
+					tpe->u.kp.kpret.handler = gtp_kp_ret_handler_plus;
+				else
+					tpe->u.kp.kpret.handler = gtp_kp_ret_handler;
+
+				ret = register_kretprobe(&tpe->u.kp.kpret);
+			} else {
+				if (gtp_access_cooked_clock
+#ifdef CONFIG_X86
+				    || gtp_access_cooked_rdtsc
+#endif
+#ifdef GTP_PERF_EVENTS
+				    || gtp_have_pc_pe
+#endif
+				) {
+#ifdef CONFIG_X86
+					if (tpe->step || gtp_have_step) {
+#else
+					if (tpe->step) {
+#endif
+						tpe->u.kp.kpret.kp.pre_handler = gtp_kp_pre_handler_plus_step;
+						tpe->u.kp.kpret.kp.post_handler = gtp_kp_post_handler_plus;
+					} else
+						tpe->u.kp.kpret.kp.pre_handler = gtp_kp_pre_handler_plus;
+				} else {
+					tpe->u.kp.kpret.kp.pre_handler = gtp_kp_pre_handler;
+#ifdef CONFIG_X86
+					if (tpe->step || gtp_have_step)
+#else
+					if (tpe->step)
+#endif
+						tpe->u.kp.kpret.kp.post_handler = gtp_kp_post_handler;
+				}
+				ret = register_kprobe(&tpe->u.kp.kpret.kp);
+			}
+			if (ret < 0) {
+				printk(KERN_WARNING "gtp_gdbrsp_qtstart: register tracepoint %d %p got error.\n",
+				(int)tpe->num, (void *)(CORE_ADDR)tpe->addr);
+				if (gtp_start_ignore_error) {
+					gtp_start_last_errno = (uint64_t)ret;
+					continue;
+				} else {
+					gtp_gdbrsp_qtstop();
+					return ret;
+				}
+			}
+			tpe->flags |= GTP_ENTRY_FLAGS_REG;
+		}
+	}
+	ret = 0;
+out:
+	if (ret != 0) {
+		kfree(gtp_var_array);
+		gtp_var_array = NULL;
+	}
+	return ret;
+}
+
+static int
+gtp_parse_x(struct gtp_entry *tpe, struct action *ae, char **pkgp)
+{
+	ULONGEST	size;
+	int		ret = -EINVAL, i, h, l;
+	char		*pkg = *pkgp;
+
+	if (pkg[0] == '\0')
+		goto out;
+	pkg = hex2ulongest(pkg, &size);
+	if (pkg[0] != ',')
+		goto out;
+	ae->u.exp.size = (unsigned int)size;
+	pkg++;
+
+	ae->u.exp.buf = kmalloc(ae->u.exp.size, GFP_KERNEL);
+	if (!ae->u.exp.buf) {
+		ret = -ENOMEM;
+		goto out;
+	}
+
+	for (i = 0; i < ae->u.exp.size
+		    && hex2int(pkg[0], &h) && hex2int(pkg[1], &l);
+	     i++) {
+#ifdef GTP_DEBUG
+		printk(GTP_DEBUG "gtp_parse_x: %s %d %d\n", pkg, h, l);
+#endif
+		ae->u.exp.buf[i] = (h << 4) | l;
+		pkg += 2;
+#ifdef GTP_DEBUG
+		printk(GTP_DEBUG "gtp_parse_x: %x\n", ae->u.exp.buf[i]);
+#endif
+	}
+	if (i != ae->u.exp.size) {
+		kfree(ae->u.exp.buf);
+		goto out;
+	}
+
+	ae->u.exp.need_var_lock = 0;
+	ret = 0;
+
+out:
+	*pkgp = pkg;
+	return ret;
+}
+
+static int
+gtp_gdbrsp_qtdp(char *pkg)
+{
+	int			addnew = 1;
+	ULONGEST		num, addr;
+	struct gtp_entry	*tpe;
+
+#ifdef GTP_DEBUG
+	printk(GTP_DEBUG "gtp_gdbrsp_qtdp: %s\n", pkg);
+#endif
+
+	if (gtp_start)
+		return -EBUSY;
+
+	if (pkg[0] == '-') {
+		pkg++;
+		addnew = 0;
+	}
+
+	/* Get num and addr.  */
+	if (pkg[0] == '\0')
+		return -EINVAL;
+	pkg = hex2ulongest(pkg, &num);
+	if (pkg[0] == '\0')
+		return -EINVAL;
+	pkg++;
+	pkg = hex2ulongest(pkg, &addr);
+	if (pkg[0] == '\0')
+		return -EINVAL;
+	pkg++;
+
+	tpe = gtp_list_find(num, addr);
+	if (addnew) {
+		ULONGEST	ulongtmp;
+
+		if (tpe)
+			return -EINVAL;
+
+		tpe = gtp_list_add(num, addr);
+		if (tpe == NULL)
+			return -ENOMEM;
+
+		if (pkg[0] == '\0')
+			return -EINVAL;
+		if (pkg[0] == 'D')
+			tpe->disable = 1;
+		pkg++;
+
+		/* Get step.  */
+		if (pkg[0] == '\0')
+			return -EINVAL;
+		pkg++;
+		pkg = hex2ulongest(pkg, &ulongtmp);
+		if (pkg[0] == '\0')
+			return -EINVAL;
+#ifndef CONFIG_X86
+		if (ulongtmp > 1) {
+			printk(KERN_WARNING "KGTP in this ARCH support one step, X86 support more than one step.\n");
+			return -EINVAL;
+		}
+#endif
+		tpe->step = (int)ulongtmp;
+#ifdef CONFIG_X86
+		if (tpe->step > 1)
+			gtp_have_step = 1;
+#else
+		if (tpe->step > 1)
+			tpe->step = 1;
+#endif
+
+		/* Get pass.  */
+		if (pkg[0] == '\0')
+			return -EINVAL;
+		pkg++;
+		pkg = hex2ulongest(pkg, &tpe->pass);
+		if (tpe->pass != 0)
+			tpe->flags |= GTP_ENTRY_FLAGS_HAVE_PASS;
+	}
+
+	if (tpe) {
+		/* Add action to tpe.  */
+		int	step_action = 0;
+
+		if (pkg[0] == 'S') {
+			if (tpe->step == 0)
+				return -EINVAL;
+			pkg++;
+			step_action = 1;
+		} else if (!list_empty(&tpe->step_action_list))
+			step_action = 1;
+		while (pkg[0]) {
+			struct action	*ae = NULL;
+			char *pkg_cmd = pkg;
+
+#ifdef GTP_DEBUG
+			printk(GTP_DEBUG "gtp_gdbrsp_qtdp: %s\n", pkg);
+#endif
+			switch (pkg[0]) {
+			case ':':
+				pkg++;
+				break;
+			case 'M': {
+					int		is_neg = 0;
+					ULONGEST	ulongtmp;
+
+					ae = gtp_action_alloc(pkg[0]);
+					if (!ae)
+						return -ENOMEM;
+					pkg++;
+					if (pkg[0] == '-') {
+						is_neg = 1;
+						pkg++;
+					}
+					pkg = hex2ulongest(pkg, &ulongtmp);
+					ae->u.m.regnum = (int)ulongtmp;
+					if (is_neg)
+						ae->u.m.regnum
+						  = -ae->u.m.regnum;
+					if (pkg[0] == '\0') {
+						kfree(ae);
+						return -EINVAL;
+					}
+					pkg++;
+					pkg = hex2ulongest(pkg, &ulongtmp);
+					ae->u.m.offset = (CORE_ADDR)ulongtmp;
+					if (pkg[0] == '\0') {
+						kfree(ae);
+						return -EINVAL;
+					}
+					pkg++;
+					pkg = hex2ulongest(pkg, &ulongtmp);
+					ae->u.m.size = (size_t)ulongtmp;
+				}
+				break;
+			case 'R':
+				/* XXX: reg_mask is ignore.  */
+				ae = gtp_action_alloc(pkg[0]);
+				if (!ae)
+					return -ENOMEM;
+				pkg++;
+				pkg = hex2ulongest(pkg,
+						   &ae->u.reg_mask);
+				break;
+			case 'X': {
+					int	ret;
+
+					ae = gtp_action_alloc(pkg[0]);
+					if (!ae)
+						return -ENOMEM;
+					pkg++;
+					ret = gtp_parse_x(tpe, ae, &pkg);
+					if (ret) {
+						gtp_action_release(ae);
+						ae = NULL;
+
+						if (ret < 0)
+							return ret;
+					}
+				}
+				break;
+			case '-':
+				pkg++;
+				break;
+			default:
+				/* XXX: Not support.  */
+				return 1;
+			}
+
+			if (ae) {
+				/* Save the cmd.  */
+				if (gtp_src_add (pkg_cmd, pkg, &(tpe->action_cmd))) {
+					gtp_action_release(ae);
+					return -ENOMEM;
+				}
+				/* Add ae to tpe.  */
+				if ((ae->type == 'X' || ae->type == 0xff)
+				    && addnew && !tpe->cond) {
+					tpe->cond = ae;
+				} else if (!step_action)
+					list_add_tail(&ae->node, &tpe->action_list);
+				else
+					list_add_tail(&ae->node, &tpe->step_action_list);
+			}
+		}
+	} else
+		return -EINVAL;
+
+	return 0;
+}
+
+static int
+gtp_gdbrsp_qtdpsrc(char *pkg)
+{
+	ULONGEST		num, addr;
+	struct gtp_entry	*tpe;
+
+#ifdef GTP_DEBUG
+	printk(GTP_DEBUG "gtp_gdbrsp_qtdpsrc: %s\n", pkg);
+#endif
+
+	if (gtp_start)
+		return -EBUSY;
+
+	/* Get num and addr.  */
+	if (pkg[0] == '\0')
+		return -EINVAL;
+	pkg = hex2ulongest(pkg, &num);
+	if (pkg[0] == '\0')
+		return -EINVAL;
+	pkg++;
+	pkg = hex2ulongest(pkg, &addr);
+	if (pkg[0] == '\0')
+		return -EINVAL;
+	pkg++;
+	tpe = gtp_list_find(num, addr);
+	if (tpe == NULL)
+		return -EINVAL;
+
+	return gtp_src_add(pkg, NULL, &(tpe->src));
+}
+
+static void gtp_plugin_mod_get(void);
+static void gtp_plugin_mod_put(void);
+
+static int
+gtp_gdbrsp_qtdisconnected(char *pkg)
+{
+	ULONGEST setting;
+
+	if (pkg[0] == '\0')
+		return -EINVAL;
+
+	hex2ulongest(pkg, &setting);
+
+	if (gtp_disconnected_tracing != (int)setting) {
+		if (setting)
+			gtp_plugin_mod_get();
+		else
+			gtp_plugin_mod_put();
+
+		gtp_disconnected_tracing = (int)setting;
+	}
+
+	return 0;
+}
+
+static int
+gtp_gdbrsp_qtbuffer(char *pkg)
+{
+	if (strncmp("circular:", pkg, 9) == 0) {
+		ULONGEST setting;
+
+		pkg += 9;
+		if (pkg[0] == '\0')
+			return -EINVAL;
+		hex2ulongest(pkg, &setting);
+
+#ifdef GTP_FTRACE_RING_BUFFER
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2,6,38)) \
+    || defined(GTP_SELF_RING_BUFFER)
+		gtp_circular = (int)setting;
+		if (gtp_frame)
+			ring_buffer_change_overwrite(gtp_frame, (int)setting);
+#else
+		if (gtp_circular != (int)setting)
+			gtp_circular_is_changed = 1;
+#endif
+#endif
+		gtp_circular = (int)setting;
+
+		return 0;
+	}
+
+	return 1;
+}
+
+static int
+gtp_frame_head_find_num(int num)
+{
+#ifdef GTP_FRAME_SIMPLE
+	int	tfnum = 0;
+	char	*tmp = gtp_frame_r_start;
+
+	do {
+		if (tmp == gtp_frame_end)
+			tmp = gtp_frame;
+
+		if (FID(tmp) == FID_HEAD) {
+			if (tfnum == num) {
+				gtp_frame_current_num = num;
+				gtp_frame_current = tmp;
+				return 0;
+			}
+			tfnum++;
+		}
+
+		tmp = gtp_frame_next(tmp);
+		if (!tmp)
+			break;
+	} while (tmp != gtp_frame_w_start);
+#endif
+#ifdef GTP_FTRACE_RING_BUFFER
+	if (gtp_frame_current_num >= num)
+		gtp_frame_iter_reset();
+
+	while (1) {
+		int	cpu;
+
+		cpu = gtp_frame_iter_peek_head();
+		if (cpu < 0)
+			break;
+
+		if (num == gtp_frame_current_num)
+			return cpu;
+
+		ring_buffer_read(gtp_frame_iter[cpu], NULL);
+	}
+#endif
+#ifdef GTP_RB
+	if (num < gtp_frame_current_num)
+		gtp_rb_read_reset();
+
+	while (1) {
+		if (gtp_frame_current_num == num)
+			return 0;
+
+		if (gtp_rb_read() != 0)
+			break;
+	}
+#endif
+
+	return -1;
+}
+
+static int
+gtp_frame_head_find_addr(int inside, unsigned long lo,
+			 unsigned long hi)
+{
+#ifdef GTP_FRAME_SIMPLE
+	int	tfnum = gtp_frame_current_num;
+	char	*tmp;
+
+	if (gtp_frame_current)
+		tmp = gtp_frame_current;
+	else
+		tmp = gtp_frame_r_start;
+
+	do {
+		if (tmp == gtp_frame_end)
+			tmp = gtp_frame;
+
+		if (FID(tmp) == FID_HEAD) {
+			if (tfnum != gtp_frame_current_num) {
+				char		*next;
+				struct pt_regs	*regs = NULL;
+
+				for (next = *(char **)(tmp + FID_SIZE); next;
+				     next = *(char **)(next + FID_SIZE)) {
+					if (FID(next) == FID_REG) {
+						regs = (struct pt_regs *)
+						       (next + FID_SIZE
+							+ sizeof(char *));
+						break;
+					}
+				}
+				if (regs
+				    && ((inside
+					 && GTP_REGS_PC(regs) >= lo
+					 && GTP_REGS_PC(regs) <= hi)
+					|| (!inside
+					    && (GTP_REGS_PC(regs) < lo
+						|| GTP_REGS_PC(regs) > hi)))) {
+					gtp_frame_current_num = tfnum;
+					gtp_frame_current = tmp;
+					return 0;
+				}
+			}
+			tfnum++;
+		}
+
+		tmp = gtp_frame_next(tmp);
+		if (!tmp)
+			break;
+	} while (tmp != gtp_frame_w_start);
+#endif
+#ifdef GTP_FTRACE_RING_BUFFER
+	while (1) {
+		int				cpu;
+		struct ring_buffer_event	*rbe;
+		char				*tmp;
+		struct pt_regs			*regs = NULL;
+
+		cpu = gtp_frame_iter_peek_head();
+		if (cpu < 0)
+			break;
+
+		while (1) {
+			ring_buffer_read(gtp_frame_iter[cpu], NULL);
+			rbe = ring_buffer_iter_peek(gtp_frame_iter[cpu], NULL);
+			if (rbe == NULL)
+				break;
+
+			tmp = ring_buffer_event_data(rbe);
+			if (FID(tmp) == FID_HEAD)
+				break;
+			if (FID(tmp) == FID_REG) {
+				regs = (struct pt_regs *)(tmp + FID_SIZE);
+				break;
+			}
+		}
+
+		if (regs
+		    && ((inside
+			  && GTP_REGS_PC(regs) >= lo
+			  && GTP_REGS_PC(regs) <= hi)
+			|| (!inside
+			    && (GTP_REGS_PC(regs) < lo
+				|| GTP_REGS_PC(regs) > hi))))
+			return gtp_frame_head_find_num(gtp_frame_current_num);
+	}
+#endif
+#ifdef GTP_RB
+	struct gtp_rb_walk_s	rbws;
+
+	if (gtp_frame_current_num < 0) {
+		if (gtp_rb_read() != 0)
+			return -1;
+	}
+
+	rbws.flags = GTP_RB_WALK_PASS_PAGE | GTP_RB_WALK_CHECK_END
+		     | GTP_RB_WALK_CHECK_ID | GTP_RB_WALK_CHECK_TYPE;
+	rbws.type = FID_REG;
+
+	while (1) {
+		char	*tmp;
+
+		rbws.end = gtp_frame_current_rb->w;
+		rbws.id = gtp_frame_current_id;
+		tmp = gtp_rb_walk(&rbws, gtp_frame_current_rb->rp);
+		if (rbws.reason == gtp_rb_walk_type) {
+			struct pt_regs	*regs
+				= (struct pt_regs *)(tmp + FID_SIZE);
+
+			if ((inside && GTP_REGS_PC(regs) >= lo
+			     && GTP_REGS_PC(regs) <= hi)
+			    || (!inside && (GTP_REGS_PC(regs) < lo
+					    || GTP_REGS_PC(regs) > hi))) {
+				return 0;
+			}
+		}
+
+		if (gtp_rb_read() != 0)
+			break;
+	}
+#endif
+
+	return -1;
+}
+
+static int
+gtp_frame_head_find_trace(ULONGEST trace)
+{
+#ifdef GTP_FRAME_SIMPLE
+	int	tfnum = gtp_frame_current_num;
+	char	*tmp;
+
+	if (gtp_frame_current)
+		tmp = gtp_frame_current;
+	else
+		tmp = gtp_frame_r_start;
+
+	do {
+		if (tmp == gtp_frame_end)
+			tmp = gtp_frame;
+
+		if (FID(tmp) == FID_HEAD) {
+			if (tfnum != gtp_frame_current_num) {
+				if (trace == *(ULONGEST *) (tmp + FID_SIZE
+							    + sizeof(char *))) {
+					gtp_frame_current_num = tfnum;
+					gtp_frame_current = tmp;
+					return 0;
+				}
+			}
+			tfnum++;
+		}
+
+		tmp = gtp_frame_next(tmp);
+		if (!tmp)
+			break;
+	} while (tmp != gtp_frame_w_start);
+#endif
+#ifdef GTP_FTRACE_RING_BUFFER
+	while (1) {
+		int				cpu;
+		struct ring_buffer_event	*rbe;
+		char				*tmp;
+
+		cpu = gtp_frame_iter_peek_head();
+		if (cpu < 0)
+			break;
+
+		rbe = ring_buffer_iter_peek(gtp_frame_iter[cpu], NULL);
+		if (rbe == NULL) {
+			/* It will not happen, just for safe.  */
+			return -1;
+		}
+		tmp = ring_buffer_event_data(rbe);
+		if (trace == *(ULONGEST *) (tmp + FID_SIZE))
+			return cpu;
+
+		ring_buffer_read(gtp_frame_iter[cpu], NULL);
+	}
+#endif
+#ifdef GTP_RB
+	if (gtp_frame_current_num < 0) {
+		if (gtp_rb_read() != 0)
+			return -1;
+	}
+
+	while (1) {
+		if (gtp_frame_current_tpe == trace)
+			return 0;
+
+		if (gtp_rb_read() != 0)
+			break;
+	}
+#endif
+
+	return -1;
+}
+
+static int
+gtp_gdbrsp_qtframe(char *pkg)
+{
+	int	ret = -1;
+#if defined(GTP_FTRACE_RING_BUFFER) || defined(GTP_RB)
+	int	old_num = gtp_frame_current_num;
+#endif
+
+	if (gtp_start)
+		return -EBUSY;
+
+	if (gtp_gtpframe_pipe_pid >= 0)
+		return -EBUSY;
+
+#ifdef GTP_DEBUG
+	printk(GTP_DEBUG "gtp_gdbrsp_qtframe: %s\n", pkg);
+#endif
+
+	if (atomic_read(&gtp_frame_create) == 0)
+		goto out;
+
+	if (strncmp(pkg, "pc:", 3) == 0) {
+		ULONGEST	addr;
+
+		pkg += 3;
+
+		if (pkg[0] == '\0')
+			return -EINVAL;
+		hex2ulongest(pkg, &addr);
+
+		ret = gtp_frame_head_find_addr(1, (unsigned long)addr,
+					       (unsigned long)addr);
+	} else if (strncmp(pkg, "tdp:", 4) == 0) {
+		ULONGEST	trace;
+
+		pkg += 4;
+
+		if (pkg[0] == '\0')
+			return -EINVAL;
+		hex2ulongest(pkg, &trace);
+
+		ret = gtp_frame_head_find_trace(trace);
+	} else if (strncmp(pkg, "range:", 6) == 0) {
+		ULONGEST	start, end;
+
+		pkg += 6;
+
+		if (pkg[0] == '\0')
+			return -EINVAL;
+		pkg = hex2ulongest(pkg, &start);
+		if (pkg[0] == '\0')
+			return -EINVAL;
+		pkg++;
+		hex2ulongest(pkg, &end);
+
+		ret = gtp_frame_head_find_addr(1, (unsigned long)start,
+					       (unsigned long)end);
+	} else if (strncmp(pkg, "outside:", 8) == 0) {
+		ULONGEST	start, end;
+
+		pkg += 8;
+
+		if (pkg[0] == '\0')
+			return -EINVAL;
+		pkg = hex2ulongest(pkg, &start);
+		if (pkg[0] == '\0')
+			return -EINVAL;
+		pkg++;
+		hex2ulongest(pkg, &end);
+
+		ret = gtp_frame_head_find_addr(0, (unsigned long)start,
+					       (unsigned long)end);
+	} else {
+		ULONGEST	num;
+
+		if (pkg[0] == '\0')
+			return -EINVAL;
+		hex2ulongest(pkg, &num);
+
+		if (((int) num) < 0) {
+			/* Return to current.  */
+#ifdef GTP_FRAME_SIMPLE
+			gtp_frame_current = NULL;
+			gtp_frame_current_num = -1;
+#endif
+#ifdef GTP_FTRACE_RING_BUFFER
+			gtp_frame_iter_reset();
+#endif
+#ifdef GTP_RB
+			gtp_rb_read_reset();
+#endif
+
+			return 0;
+		}
+		ret = gtp_frame_head_find_num((int) num);
+	}
+
+out:
+	if (ret < 0) {
+#if defined(GTP_FTRACE_RING_BUFFER) || defined(GTP_RB)
+		/* Set frame back to old_num.  */
+		if (old_num < 0)
+#ifdef GTP_FTRACE_RING_BUFFER
+			gtp_frame_iter_reset();
+#endif
+#ifdef GTP_RB
+			gtp_rb_read_reset();
+#endif
+		else
+			gtp_frame_head_find_num(old_num);
+#endif
+		snprintf(gtp_rw_bufp, GTP_RW_BUFP_MAX, "F-1");
+		gtp_rw_bufp += 3;
+		gtp_rw_size += 3;
+	} else {
+#ifdef GTP_FRAME_SIMPLE
+		gtp_frame_current_tpe = *(ULONGEST *)(gtp_frame_current
+						      + FID_SIZE
+						      + sizeof(char *));
+#endif
+#ifdef GTP_FTRACE_RING_BUFFER
+		struct ring_buffer_event	*rbe;
+		char				*tmp;
+
+		rbe = ring_buffer_read(gtp_frame_iter[ret],
+				       &gtp_frame_current_clock);
+		if (rbe == NULL) {
+			/* It will not happen, just for safe.  */
+			ret = -1;
+			goto out;
+		}
+		gtp_frame_current_cpu = ret;
+		tmp = ring_buffer_event_data(rbe);
+		gtp_frame_current_tpe = *(ULONGEST *)(tmp + FID_SIZE);
+#endif
+		snprintf(gtp_rw_bufp, GTP_RW_BUFP_MAX, "F%xT%x",
+			 gtp_frame_current_num,
+			 (unsigned int) gtp_frame_current_tpe);
+		gtp_rw_size += strlen(gtp_rw_bufp);
+		gtp_rw_bufp += strlen(gtp_rw_bufp);
+	}
+	return 1;
+}
+
+static int
+gtp_gdbrsp_qtro(char *pkg)
+{
+	ULONGEST	start, end;
+
+	gtpro_list_clear();
+
+	while (pkg[0]) {
+		pkg = hex2ulongest(pkg, &start);
+		if (pkg[0] != ',')
+			return -EINVAL;
+		pkg++;
+		pkg = hex2ulongest(pkg, &end);
+		if (pkg[0])
+			pkg++;
+
+		if (gtpro_list_add((CORE_ADDR)start, (CORE_ADDR)end) == NULL)
+			return -ENOMEM;
+	}
+
+	return 0;
+}
+
+static int
+gtp_gdbrsp_qtdv(char *pkg)
+{
+	int				ret = -EINVAL;
+	ULONGEST			num, val;
+	struct gtp_var			*var = NULL;
+	char				*src;
+	int				src_size;
+	int				per_cpu_alloced = 0;
+#ifdef GTP_PERF_EVENTS
+	int				pe_alloced = 0;
+#endif
+
+	pkg = hex2ulongest(pkg, &num);
+	if (pkg[0] != ':')
+		goto error_out;
+	pkg++;
+	pkg = hex2ulongest(pkg, &val);
+	if (pkg[0] != ':')
+		goto error_out;
+
+	var = gtp_var_find_num(num);
+	if (var) {
+		if (var->type == gtp_var_special) {
+			if (var->u.hooks && var->u.hooks->gdb_set_val) {
+				ret = var->u.hooks->gdb_set_val(NULL,
+								var, val);
+				if (ret != 0)
+					goto error_out;
+			}
+			return 0;
+		} else
+			goto error_out;
+	}
+
+	pkg ++;
+	src = pkg;
+	src_size = strlen(src);
+
+	/* Remove "0:" for following code.  */
+	if (strlen(pkg) <= 2)
+		goto error_out;
+	pkg += 2;
+
+	/* Check if this is a "p_" or "per_cpu_" trace state variable.  */
+	if (strncasecmp(pkg, "705f", 4) == 0
+	    || strncasecmp(pkg, "7065725f6370755f", 16) == 0) {
+		int				name_size;
+		char				*id_s;
+		int				mul = 1;
+		struct list_head		*cur;
+		struct gtp_var			*cvar;
+		int				per_cpu_id = -1;
+
+		if (strncasecmp(pkg, "705f", 4) == 0)
+			pkg += 4;
+		else
+			pkg += 16;
+		name_size = strlen(pkg);
+
+		/* Get the cpu id of this variable.  */
+		if (name_size % 2 != 0)
+			goto error_out;
+		for (id_s = pkg + name_size - 2; id_s > pkg; id_s -= 2) {
+			int	i, j;
+
+			if (!hex2int(id_s[0], &i))
+				goto error_out;
+			if (!hex2int(id_s[1], &j))
+				goto error_out;
+			j |= (i << 4);
+			if (j < 0x30 || j > 0x39)
+				break;
+			j -= 0x30;
+			if (per_cpu_id < 0)
+				per_cpu_id = 0;
+			per_cpu_id += mul * j;
+			mul *= 10;
+			/* src_size will not include the cpu id.  */
+			src_size -= 2;
+		}
+		if (per_cpu_id >= gtp_cpu_number) {
+			printk(KERN_WARNING "gtp_gdbrsp_qtdv: id %d is bigger "
+					    "than cpu number %d.\n",
+			       per_cpu_id, gtp_cpu_number);
+			goto error_out;
+		}
+
+		var = gtp_var_alloc(per_cpu_id, (unsigned int)num, 0,
+				    (int64_t)val, src);
+		if (IS_ERR(var)) {
+			ret = PTR_ERR(var);
+			var = NULL;
+			goto error_out;
+		}
+
+		/* Setup var.  */
+		var->type = gtp_var_per_cpu;
+		var->u.pc.cpu = per_cpu_id;
+		/* Find the per cpu struct.  */
+		list_for_each(cur, &gtp_var_list) {
+			cvar = list_entry(cur, struct gtp_var, node);
+#ifdef GTP_PERF_EVENTS
+			if (cvar->type != gtp_var_per_cpu
+			    && cvar->type != gtp_var_perf_event_per_cpu)
+#else
+			if (cvar->type != gtp_var_per_cpu)
+#endif
+				continue;
+
+			if (strncmp (cvar->src, src, src_size) == 0) {
+				int	csize;
+
+				/* Following part code to make sure
+				   cvar->src without ID is same with
+				   var->src without id.  */
+				csize = strlen(cvar->src);
+				if (csize % 2 != 0) {
+					printk(KERN_WARNING "Src %s of TSR %u is not right.\n",
+					       cvar->src, cvar->num);
+					continue;
+				}
+				for (csize -= 2; csize >= src_size; csize -= 2) {
+					int	i, j;
+
+					if (!hex2int(cvar->src[csize], &i))
+						break;
+					if (!hex2int(cvar->src[csize + 1], &j))
+						break;
+					j |= (i << 4);
+					if (j < 0x30 || j > 0x39)
+						break;
+				}
+				if (csize >= src_size)
+					continue;
+
+				var->u.pc.pc = cvar->u.pc.pc;
+				break;
+			}
+		}
+		if (var->u.pc.pc == NULL) {
+			int	cpu;
+
+			var->u.pc.pc = alloc_percpu(struct gtp_var_per_cpu);
+			if (var->u.pc.pc == NULL) {
+				ret = -ENOMEM;
+				goto error_out;
+			}
+			for_each_online_cpu(cpu)
+				memset(per_cpu_ptr(var->u.pc.pc, cpu), '\0',
+				       sizeof(struct gtp_var_per_cpu));
+
+			per_cpu_alloced = 1;
+#ifdef GTP_DEBUG
+			printk(GTP_DEBUG "gtp_gdbrsp_qtdv: Create a "
+					 "new per_cpu list for %s and set var "
+					 "to cpu %d.\n",
+			       src, var->u.pc.cpu);
+#endif
+		} else {
+#ifdef GTP_DEBUG
+			printk(GTP_DEBUG "gtp_gdbrsp_qtdv: Find a "
+					 "per_cpu list for %s and set var "
+					 "to cpu %d.\n",
+			       src, var->u.pc.cpu);
+#endif
+		}
+		if (var->u.pc.cpu >= 0)
+			gtp_var_get_pc(var)->u.val = val;
+	} else {
+		var = gtp_var_alloc(-1, (unsigned int)num, 0, (int64_t)val,
+				    src);
+		if (IS_ERR(var)) {
+			ret = PTR_ERR(var);
+			var = NULL;
+			goto error_out;
+		}
+		/* Setup var.  */
+		var->type = gtp_var_normal;
+		var->u.val = val;
+	}
+
+	/* Check if this is a "pe_" OR "perf_event_" trace state variable.  */
+	if (strncasecmp(pkg, "70655f", 6) == 0
+	    || strncasecmp(pkg, "706572665f6576656e745f", 22) == 0) {
+#ifdef GTP_PERF_EVENTS
+		enum pe_tv_id		ptid;
+		struct list_head	*cur;
+		struct gtp_var_pe	*cpe = NULL, *pe;
+
+		if (strncasecmp(pkg, "70655f", 6) == 0)
+			pkg += 6;
+		else
+			pkg += 22;
+
+		if (strncasecmp(pkg, "6370755f", 8) == 0) {
+			/* "cpu_" */
+			pkg += 8;
+			ptid = pe_tv_cpu;
+		} else if (strncasecmp(pkg, "747970655f", 10) == 0) {
+			/* "type_" */
+			pkg += 10;
+			ptid = pe_tv_type;
+		} else if (strncasecmp(pkg, "636f6e6669675f", 14) == 0) {
+			/* "config_" */
+			pkg += 14;
+			ptid = pe_tv_config;
+		} else if (strncasecmp(pkg, "656e5f", 6) == 0) {
+			/* "en_" */
+			pkg += 6;
+			ptid = pe_tv_en;
+		} else if (strncasecmp(pkg, "76616c5f", 8) == 0) {
+			/* "val_" */
+			pkg += 8;
+			ptid = pe_tv_val;
+		} else if (strncasecmp(pkg, "656e61626c65645f", 16) == 0) {
+			/* "enabled_" */
+			pkg += 16;
+			ptid = pe_tv_enabled;
+		} else if (strncasecmp(pkg, "72756e6e696e675f", 16) == 0) {
+			/* "running_" */
+			pkg += 16;
+			ptid = pe_tv_running;
+		} else
+			goto error_out;
+
+		if (strlen(pkg) <= 0)
+			goto error_out;
+
+		if (var->type == gtp_var_per_cpu) {
+			var->type = gtp_var_perf_event_per_cpu;
+			if (var->u.pc.cpu < 0)
+				goto out;
+		}
+		else
+			var->type = gtp_var_perf_event;
+
+		/* Find the pe_tv that name is pkg.  */
+		list_for_each(cur, &gtp_var_list) {
+			struct gtp_var	*cvar = list_entry(cur,
+							   struct gtp_var,
+							   node);
+			if (var->type == cvar->type
+			    && !(cvar->type == gtp_var_perf_event_per_cpu
+				 && cvar->u.pc.cpu < 0)) {
+				cpe = gtp_var_get_pe(cvar);
+				if (strcmp(cpe->pe->name, pkg) == 0)
+					break;
+			}
+		}
+
+		pe = gtp_var_get_pe(var);
+		pe->ptid = ptid;
+
+		if (cur == &gtp_var_list) {
+			if (var->type == gtp_var_perf_event_per_cpu)
+				pe->pe = kzalloc(sizeof(struct gtp_var_perf_event),
+						 GFP_KERNEL);
+			else
+				pe->pe = kmalloc_node(sizeof(struct gtp_var_perf_event),
+						      GFP_KERNEL | __GFP_ZERO,
+						      cpu_to_node(var->u.pc.cpu));
+			if (pe->pe == NULL) {
+				ret = -ENOMEM;
+				goto error_out;
+			}
+
+			/* Init the value in pe to default value.  */
+			pe_alloced = 1;
+			pe->pe->name = gtp_strdup(pkg, NULL);
+			if (pe->pe->name == NULL) {
+				ret = -ENOMEM;
+				goto error_out;
+			}
+			pe->pe->en = 0;
+			pe->pe->attr.type = PERF_TYPE_HARDWARE;
+			pe->pe->attr.config = PERF_COUNT_HW_CPU_CYCLES;
+			pe->pe->attr.disabled = 1;
+			pe->pe->attr.pinned = 1;
+			pe->pe->attr.size = sizeof(struct perf_event_attr);
+			if (var->type == gtp_var_perf_event_per_cpu)
+				pe->pe->cpu = var->u.pc.cpu;
+		} else
+			pe->pe = cpe->pe;
+
+		/* Set current val to pe.  */
+		switch (ptid) {
+		case pe_tv_cpu:
+			pe->pe->cpu = (int)(LONGEST)val;
+			break;
+		case pe_tv_type:
+			pe->pe->attr.type = val;
+			break;
+		case pe_tv_config:
+			pe->pe->attr.config = val;
+			break;
+		case pe_tv_en:
+			if (val) {
+				pe->pe->attr.disabled = 0;
+				pe->pe->en = 1;
+			} else {
+				pe->pe->attr.disabled = 1;
+				pe->pe->en = 0;
+			}
+			break;
+		case pe_tv_val:
+		case pe_tv_enabled:
+		case pe_tv_running:
+			break;
+		default:
+			goto error_out;
+			break;
+		}
+
+		gtp_have_pc_pe = 1;
+#else
+		printk(KERN_WARNING "Current Kernel doesn't open "
+				    "GTP_PERF_EVENTS\n");
+		ret = -ENXIO;
+		goto error_out;
+#endif
+	}
+#ifdef GTP_PERF_EVENTS
+out:
+#endif
+	list_add(&var->node, &gtp_var_list);
+	gtp_var_num++;
+
+	return 0;
+
+error_out:
+#ifdef GTP_PERF_EVENTS
+	if (pe_alloced)
+		kfree(gtp_var_get_pe(var)->pe);
+#endif
+	if (per_cpu_alloced)
+		free_percpu(var->u.pc.pc);
+
+	if (var) {
+		kfree(var->src);
+		kfree(var);
+	}
+
+	return ret;
+}
+
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,30))
+static int
+gtp_gdbrsp_qtenable_qtdisable(char *pkg, int enable)
+{
+	ULONGEST		num, addr;
+	struct gtp_entry	*tpe;
+	int			ret;
+
+	pkg = hex2ulongest(pkg, &num);
+	if (pkg[0] != ':')
+		return -EINVAL;
+	pkg++;
+	hex2ulongest(pkg, &addr);
+
+	tpe = gtp_list_find(num, addr);
+	if (tpe == NULL)
+		return -EINVAL;
+	if (tpe->type != gtp_entry_kprobe) {
+		printk(KERN_WARNING "gtp_write: this tracepoint doesn't support enable and disable.\n");
+		return -EINVAL;
+	}
+
+	spin_lock(&gtp_handler_enable_disable_loc);
+
+	if (tpe->flags & GTP_ENTRY_FLAGS_IS_KRETPROBE) {
+		if (enable)
+			ret = enable_kretprobe(&(tpe->u.kp.kpret));
+		else
+			ret = disable_kretprobe(&(tpe->u.kp.kpret));
+	} else {
+		if (enable)
+			ret = enable_kprobe(&(tpe->u.kp.kpret.kp));
+		else
+			ret = disable_kprobe(&(tpe->u.kp.kpret.kp));
+	}
+
+	if (ret != 0)
+		tpe->disable = enable ? 0 : 1;
+
+	spin_unlock(&gtp_handler_enable_disable_loc);
+	return ret;
+}
+#endif
+
+static int
+gtp_gdbrsp_QT(char *pkg)
+{
+	int	ret = 1;
+
+#ifdef GTP_DEBUG
+	printk(GTP_DEBUG "gtp_gdbrsp_QT: %s\n", pkg);
+#endif
+
+	if (strcmp("init", pkg) == 0)
+		ret = gtp_gdbrsp_qtinit();
+	else if (strcmp("Stop", pkg) == 0)
+		ret = gtp_gdbrsp_qtstop();
+	else if (strcmp("Start", pkg) == 0)
+		ret = gtp_gdbrsp_qtstart();
+	else if (strncmp("DP:", pkg, 3) == 0)
+		ret = gtp_gdbrsp_qtdp(pkg + 3);
+	else if (strncmp("DPsrc:", pkg, 6) == 0)
+		ret = gtp_gdbrsp_qtdpsrc(pkg + 6);
+	else if (strncmp("Disconnected:", pkg, 13) == 0)
+		ret = gtp_gdbrsp_qtdisconnected(pkg + 13);
+	else if (strncmp("Buffer:", pkg, 7) == 0)
+		ret = gtp_gdbrsp_qtbuffer(pkg + 7);
+	else if (strncmp("Frame:", pkg, 6) == 0)
+		ret = gtp_gdbrsp_qtframe(pkg + 6);
+	else if (strncmp("ro:", pkg, 3) == 0)
+		ret = gtp_gdbrsp_qtro(pkg + 3);
+	else if (strncmp("DV:", pkg, 3) == 0)
+		ret = gtp_gdbrsp_qtdv(pkg + 3);
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,30))
+	else if (strncmp("Enable:", pkg, 7) == 0)
+		ret = gtp_gdbrsp_qtenable_qtdisable(pkg + 7, 1);
+	else if (strncmp("Disable:", pkg, 8) == 0)
+		ret = gtp_gdbrsp_qtenable_qtdisable(pkg + 8, 0);
+#endif
+
+#ifdef GTP_DEBUG
+	printk(GTP_DEBUG "gtp_gdbrsp_QT: return %d\n", ret);
+#endif
+
+	return ret;
+}
+
+static int
+gtp_get_status(struct gtp_entry *tpe, char *buf, int bufmax)
+{
+	int			size = 0;
+	int			tfnum = 0;
+	CORE_ADDR		tmpaddr;
+
+#ifdef GTP_RB
+	if (GTP_RB_PAGE_IS_EMPTY) {
+#endif
+#if defined(GTP_FRAME_SIMPLE) || defined(GTP_FTRACE_RING_BUFFER)
+	if (!gtp_frame) {
+#endif
+		snprintf(buf, bufmax, "tnotrun:0;");
+		buf += 10;
+		size += 10;
+		bufmax -= 10;
+	} else if (!tpe || (tpe && tpe->reason == gtp_stop_normal)) {
+		snprintf(buf, bufmax, "tstop:0;");
+		buf += 8;
+		size += 8;
+		bufmax -= 8;
+	} else {
+		char	outtmp[100];
+
+		switch (tpe->reason) {
+		case gtp_stop_frame_full:
+			snprintf(buf, bufmax, "tfull:%lx;",
+				 (unsigned long)tpe->num);
+			break;
+		case gtp_stop_efault:
+			snprintf(buf, bufmax, "terror:%s:%lx;",
+				 string2hex("read memory false", outtmp),
+				 (unsigned long)tpe->num);
+			break;
+		case gtp_stop_access_wrong_reg:
+			snprintf(buf, bufmax, "terror:%s:%lx;",
+				 string2hex("access wrong register", outtmp),
+				 (unsigned long)tpe->num);
+			break;
+		case gtp_stop_agent_expr_code_error:
+			snprintf(buf, bufmax, "terror:%s:%lx;",
+				 string2hex("agent expression code error",
+					    outtmp),
+				 (unsigned long)tpe->num);
+			break;
+		case gtp_stop_agent_expr_stack_overflow:
+			snprintf(buf, bufmax, "terror:%s:%lx;",
+				string2hex("agent expression stack overflow",
+					   outtmp),
+				(unsigned long)tpe->num);
+			break;
+		default:
+			buf[0] = '\0';
+			break;
+		}
+
+		size += strlen(buf);
+		bufmax -= strlen(buf);
+		buf += strlen(buf);
+	}
+
+	if (atomic_read(&gtp_frame_create)) {
+#ifdef GTP_FRAME_SIMPLE
+		char	*tmp = gtp_frame_r_start;
+
+		do {
+			if (tmp == gtp_frame_end)
+				tmp = gtp_frame;
+
+			if (FID(tmp) == FID_HEAD)
+				tfnum++;
+
+			tmp = gtp_frame_next(tmp);
+			if (!tmp)
+				break;
+		} while (tmp != gtp_frame_w_start);
+#endif
+#ifdef GTP_FTRACE_RING_BUFFER
+		if (gtp_start) {
+			/* XXX: It is just the number of entries.  */
+			tfnum = (int)ring_buffer_entries(gtp_frame);
+		} else {
+			int	old_num = gtp_frame_current_num;
+			int	cpu;
+
+			gtp_frame_iter_reset();
+
+			for_each_online_cpu(cpu) {
+				char				*tmp;
+				struct ring_buffer_event	*rbe;
+
+				while (1) {
+					rbe = ring_buffer_read
+						(gtp_frame_iter[cpu], NULL);
+					if (rbe == NULL)
+						break;
+					tmp = ring_buffer_event_data(rbe);
+					if (FID(tmp) == FID_HEAD)
+						tfnum++;
+				}
+			}
+
+			if (old_num == -1)
+				gtp_frame_iter_reset();
+			else if (old_num >= 0) {
+				gtp_frame_head_find_num(old_num);
+				ring_buffer_read
+					(gtp_frame_iter[gtp_frame_current_cpu],
+					 NULL);
+			}
+		}
+#endif
+#ifdef GTP_RB
+		int			cpu;
+		struct gtp_rb_walk_s	rbws;
+
+		rbws.flags = GTP_RB_WALK_PASS_PAGE | GTP_RB_WALK_CHECK_END;
+
+		for_each_online_cpu(cpu) {
+			struct gtp_rb_s	*rb
+				= (struct gtp_rb_s *)per_cpu_ptr(gtp_rb, cpu);
+			void		*tmp;
+			unsigned long	flags;
+
+			GTP_RB_LOCK_IRQ(rb, flags);
+			rbws.end = rb->w;
+			tmp = rb->r;
+			while (1) {
+				tmp = gtp_rb_walk(&rbws, tmp);
+				if (rbws.reason != gtp_rb_walk_new_entry)
+					break;
+				tfnum++;
+				tmp += FRAME_ALIGN(GTP_FRAME_HEAD_SIZE);
+			}
+			GTP_RB_UNLOCK_IRQ(rb, flags);
+		}
+#endif
+	}
+
+	snprintf(buf, bufmax, "tframes:%x;", tfnum);
+	size += strlen(buf);
+	bufmax -= strlen(buf);
+	buf += strlen(buf);
+
+	snprintf(buf, bufmax, "tcreated:%x;", atomic_read(&gtp_frame_create));
+	size += strlen(buf);
+	bufmax -= strlen(buf);
+	buf += strlen(buf);
+
+#ifdef GTP_FRAME_SIMPLE
+	snprintf(buf, bufmax, "tsize:%x;", GTP_FRAME_SIZE);
+#endif
+#ifdef GTP_FTRACE_RING_BUFFER
+	if (gtp_frame)
+		snprintf(buf, bufmax, "tsize:%lx;",
+			 ring_buffer_size(gtp_frame));
+	else
+		snprintf(buf, bufmax, "tsize:%x;",
+			 GTP_FRAME_SIZE * num_online_cpus());
+#endif
+#ifdef GTP_RB
+	snprintf(buf, bufmax, "tsize:%lx;",
+		 gtp_rb_page_count * GTP_RB_DATA_MAX * num_online_cpus());
+#endif
+	size += strlen(buf);
+	bufmax -= strlen(buf);
+	buf += strlen(buf);
+
+#ifdef GTP_FRAME_SIMPLE
+	spin_lock(&gtp_frame_lock);
+	if (gtp_frame_is_circular)
+		tmpaddr = 0;
+	else
+		tmpaddr = GTP_FRAME_SIZE - (gtp_frame_w_start - gtp_frame);
+	spin_unlock(&gtp_frame_lock);
+#endif
+#ifdef GTP_FTRACE_RING_BUFFER
+	/* XXX: Ftrace ring buffer don't have interface to get the size of free
+	   buffer. */
+	tmpaddr = 0;
+#endif
+#ifdef GTP_RB
+	if (atomic_read(&gtp_frame_create)) {
+		int			cpu;
+
+		tmpaddr = 0;
+		for_each_online_cpu(cpu) {
+			struct gtp_rb_s	*rb
+				= (struct gtp_rb_s *)per_cpu_ptr(gtp_rb, cpu);
+			void		*tmp;
+			unsigned long	flags;
+
+			GTP_RB_LOCK_IRQ(rb, flags);
+			tmpaddr += GTP_RB_END(rb->w) - rb->w;
+			for (tmp = GTP_RB_NEXT(rb->w);
+			     GTP_RB_HEAD(tmp) != GTP_RB_HEAD(rb->r);
+			     tmp = GTP_RB_NEXT(tmp))
+				tmpaddr += GTP_RB_DATA_MAX;
+			tmpaddr += rb->r - GTP_RB_DATA(rb->r);
+			GTP_RB_UNLOCK_IRQ(rb, flags);
+		}
+	} else {
+		tmpaddr = gtp_rb_page_count * GTP_RB_DATA_MAX
+			  * num_online_cpus();
+	}
+#endif
+	snprintf(buf, bufmax, "tfree:%lx;", (unsigned long)tmpaddr);
+	size += strlen(buf);
+	bufmax -= strlen(buf);
+	buf += strlen(buf);
+
+	snprintf(buf, bufmax, "circular:%x;", gtp_circular);
+	size += strlen(buf);
+	bufmax -= strlen(buf);
+	buf += strlen(buf);
+
+	snprintf(buf, bufmax, "disconn:%x", gtp_disconnected_tracing);
+	size += strlen(buf);
+	bufmax -= strlen(buf);
+	buf += strlen(buf);
+
+	return size;
+}
+
+static int
+gtp_gdbrsp_qtstatus(void)
+{
+	struct gtp_entry	*tpe;
+	int			tmp;
+
+	for (tpe = gtp_list; tpe; tpe = tpe->next) {
+		if (tpe->reason != gtp_stop_normal)
+			break;
+	}
+
+	if (gtp_start && tpe)	/* Tpe is stop, stop all tpes.  */
+		gtp_gdbrsp_qtstop();
+
+	snprintf(gtp_rw_bufp, GTP_RW_BUFP_MAX, "T%x;", gtp_start ? 1 : 0);
+	gtp_rw_bufp += 3;
+	gtp_rw_size += 3;
+
+	tmp = gtp_get_status(tpe, gtp_rw_bufp, GTP_RW_BUFP_MAX);
+	gtp_rw_bufp += tmp;
+	gtp_rw_size += tmp;
+
+	return 1;
+}
+
+#define GTP_REPORT_TRACEPOINT_MAX	(1 + 16 + 1 + 16 + 1 + 1 + 1 + \
+					 20 + 1 + 16 + 1)
+
+static void
+gtp_report_tracepoint(struct gtp_entry *gtp, char *buf, int bufmax)
+{
+	snprintf(buf, bufmax, "T%lx:%lx:%c:%d:%lx", (unsigned long)gtp->num,
+		 (unsigned long)gtp->addr, (gtp->disable ? 'D' : 'E'),
+		 gtp->step, (unsigned long)gtp->pass);
+}
+
+static int
+gtp_report_action_max(struct gtp_entry *gtp, struct gtpsrc *action)
+{
+	return 1 + 16 + 1 + 16 + 1 + strlen(action->src) + 1;
+}
+
+static void
+gtp_report_action(struct gtp_entry *gtp, struct gtpsrc *action, char *buf,
+		  int bufmax)
+{
+	snprintf(buf, bufmax, "A%lx:%lx:%s", (unsigned long)gtp->num,
+		 (unsigned long)gtp->addr, action->src);
+}
+
+static int
+gtp_report_src_max(struct gtp_entry *gtp, struct gtpsrc *src)
+{
+	return 1 + 16 + 1 + 16 + 1 + strlen(src->src) + 1;
+}
+
+static void
+gtp_report_src(struct gtp_entry *gtp, struct gtpsrc *src, char *buf, int bufmax)
+{
+	snprintf(buf, bufmax, "Z%lx:%lx:%s", (unsigned long)gtp->num,
+		 (unsigned long)gtp->addr, src->src);
+}
+
+static void
+gtp_current_set_check(void)
+{
+	if (current_gtp_src == NULL)
+		current_gtp = current_gtp->next;
+}
+
+static void
+gtp_current_action_check(void)
+{
+	if (current_gtp_action_cmd == NULL) {
+		current_gtp_src = current_gtp->src;
+		gtp_current_set_check();
+	}
+}
+
+static int
+gtp_gdbrsp_qtfp(void)
+{
+	if (gtp_list) {
+		current_gtp = gtp_list;
+		gtp_report_tracepoint(current_gtp, gtp_rw_bufp,
+				      GTP_RW_BUFP_MAX);
+		gtp_rw_size += strlen(gtp_rw_bufp);
+		gtp_rw_bufp += strlen(gtp_rw_bufp);
+		current_gtp_action_cmd = current_gtp->action_cmd;
+		gtp_current_action_check();
+	} else {
+		if (GTP_RW_BUFP_MAX > 1) {
+			gtp_rw_bufp[0] = 'l';
+			gtp_rw_size += 1;
+			gtp_rw_bufp += 1;
+		}
+	}
+
+	return 1;
+}
+
+static int
+gtp_gdbrsp_qtsp(void)
+{
+	if (current_gtp_action_cmd) {
+		gtp_report_action(current_gtp, current_gtp_action_cmd,
+				  gtp_rw_bufp, GTP_RW_BUFP_MAX);
+		gtp_rw_size += strlen(gtp_rw_bufp);
+		gtp_rw_bufp += strlen(gtp_rw_bufp);
+		current_gtp_action_cmd = current_gtp_action_cmd->next;
+		gtp_current_action_check();
+		goto out;
+	}
+
+	if (current_gtp_src) {
+		gtp_report_src(current_gtp, current_gtp_src, gtp_rw_bufp,
+			       GTP_RW_BUFP_MAX);
+		gtp_rw_size += strlen(gtp_rw_bufp);
+		gtp_rw_bufp += strlen(gtp_rw_bufp);
+		current_gtp_src = current_gtp_src->next;
+		gtp_current_set_check();
+		goto out;
+	}
+
+	if (current_gtp) {
+		gtp_report_tracepoint(current_gtp, gtp_rw_bufp,
+				      GTP_RW_BUFP_MAX);
+		gtp_rw_size += strlen(gtp_rw_bufp);
+		gtp_rw_bufp += strlen(gtp_rw_bufp);
+		current_gtp_action_cmd = current_gtp->action_cmd;
+		gtp_current_action_check();
+	} else {
+		if (GTP_RW_BUFP_MAX > 1) {
+			gtp_rw_bufp[0] = 'l';
+			gtp_rw_size += 1;
+			gtp_rw_bufp += 1;
+		}
+	}
+out:
+	return 1;
+}
+
+static int
+gtp_gdbrsp_qtfsv(int f)
+{
+	if (f) {
+		if (list_empty(&gtp_var_list))
+			current_gtp_var = NULL;
+		else
+			current_gtp_var = list_first_entry(&gtp_var_list,
+							   struct gtp_var,
+							   node);
+	}
+
+	if (current_gtp_var) {
+		snprintf(gtp_rw_bufp, GTP_RW_BUFP_MAX, "%x:%llx:%s",
+			 current_gtp_var->num,
+			 (unsigned long long)current_gtp_var->initial_val,
+			 current_gtp_var->src);
+		gtp_rw_size += strlen(gtp_rw_bufp);
+		gtp_rw_bufp += strlen(gtp_rw_bufp);
+
+		if (current_gtp_var->node.next != &gtp_var_list)
+			current_gtp_var = list_first_entry(&(current_gtp_var->node),
+							   struct gtp_var,
+							   node);
+		else
+			current_gtp_var = NULL;
+	} else {
+		if (GTP_RW_BUFP_MAX > 1) {
+			gtp_rw_bufp[0] = 'l';
+			gtp_rw_size += 1;
+			gtp_rw_bufp += 1;
+		}
+	}
+
+	return 1;
+}
+
+#ifdef GTP_RB
+static int
+gtp_rb_traceframe_get_tv(void *buf, u64 id, unsigned int num, uint64_t *val)
+{
+	struct gtp_rb_walk_s	rbws;
+	char			*tmp;
+
+	/* Handle $cpu_id.  */
+	if (num == GTP_VAR_CPU_ID) {
+		*val = gtp_frame_current_rb->cpu;
+		return 0;
+	}
+
+	rbws.flags = GTP_RB_WALK_PASS_PAGE | GTP_RB_WALK_CHECK_END
+		     | GTP_RB_WALK_CHECK_ID | GTP_RB_WALK_CHECK_TYPE;
+	rbws.end = gtp_frame_current_rb->w;
+	rbws.id = id;
+	rbws.type = FID_VAR;
+	tmp = buf;
+
+	while (1) {
+		struct gtp_frame_var	*vr;
+
+		tmp = gtp_rb_walk(&rbws, tmp);
+		if (rbws.reason != gtp_rb_walk_type)
+			break;
+
+		vr = (struct gtp_frame_var *)(tmp + FID_SIZE);
+		if (vr->num == num) {
+			*val = vr->val;
+			return 0;
+		}
+
+		tmp += FRAME_ALIGN(GTP_FRAME_VAR_SIZE);
+	}
+
+	return -1;
+}
+#endif
+
+static int
+gtp_gdbrsp_qtv(char *pkg)
+{
+	ULONGEST		num;
+	struct gtp_var		*var = NULL;
+	struct gtp_frame_var	*vr = NULL;
+	uint64_t		val = 0;
+	int			ret;
+
+	pkg = hex2ulongest(pkg, &num);
+
+#ifdef GTP_FRAME_SIMPLE
+	if (gtp_start || !gtp_frame_current) {
+#elif defined(GTP_FTRACE_RING_BUFFER) || defined(GTP_RB)
+	if (gtp_start || gtp_frame_current_num < 0) {
+#endif
+		var = gtp_var_find_num(num);
+		if (var == NULL)
+			goto out;
+
+		switch (var->type) {
+		case gtp_var_special:
+			if (var->u.hooks && var->u.hooks->gdb_get_val) {
+				ret = var->u.hooks->gdb_get_val(NULL,
+								var, &val);
+				if (ret)
+					return ret;
+			} else
+				var = NULL;
+			break;
+#ifdef GTP_PERF_EVENTS
+		case gtp_var_perf_event:
+		case gtp_var_perf_event_per_cpu: {
+			struct gtp_var_pe	*pe = gtp_var_get_pe(var);
+			if (pe->ptid == pe_tv_val
+			    || pe->ptid == pe_tv_enabled
+			    || pe->ptid == pe_tv_running) {
+				if (gtp_start)
+					pe->pe->val = perf_event_read_value(pe->pe->event,
+									    &(pe->pe->enabled),
+									    &(pe->pe->running));
+			}
+			switch (pe->ptid) {
+			case pe_tv_val:
+				val = (uint64_t)(pe->pe->val);
+				break;
+			case pe_tv_enabled:
+				val = (uint64_t)(pe->pe->enabled);
+				break;
+			case pe_tv_running:
+				val = (uint64_t)(pe->pe->running);
+				break;
+			default:
+				break;
+			}
+		}
+			break;
+#endif
+		case gtp_var_per_cpu:
+			val = gtp_var_get_pc(var)->u.val;
+			break;
+		default:
+			val = var->u.val;
+			break;
+		}
+	} else {
+#ifdef GTP_FRAME_SIMPLE
+		char	*next;
+
+		for (next = *(char **)(gtp_frame_current + FID_SIZE); next;
+		     next = *(char **)(next + FID_SIZE)) {
+			if (FID(next) == FID_VAR) {
+				vr = (struct gtp_frame_var *)
+				     (next + FID_SIZE + sizeof(char *));
+				if (vr->num == (unsigned int)num)
+					goto while_stop;
+			}
+		}
+#endif
+#ifdef GTP_FTRACE_RING_BUFFER
+		int				is_first = 1;
+		struct ring_buffer_event	*rbe;
+		char				*tmp;
+
+		/* Handle $cpu_id and $clock.  */
+		if (num == GTP_VAR_CLOCK_ID) {
+			val = gtp_frame_current_clock;
+			goto output_value;
+		}
+		else if (num == GTP_VAR_CPU_ID) {
+			val = gtp_frame_current_cpu;
+			goto output_value;
+		}
+re_find:
+		while (1) {
+			rbe = ring_buffer_iter_peek
+				(gtp_frame_iter[gtp_frame_current_cpu], NULL);
+			if (rbe == NULL)
+				break;
+			tmp = ring_buffer_event_data(rbe);
+			if (FID(tmp) == FID_HEAD)
+				break;
+			if (FID(tmp) == FID_VAR) {
+				vr = (struct gtp_frame_var *)(tmp + FID_SIZE);
+				if (vr->num == (unsigned int)num)
+					goto while_stop;
+			}
+			ring_buffer_read(gtp_frame_iter[gtp_frame_current_cpu],
+					 NULL);
+		}
+		if (is_first) {
+			gtp_frame_head_find_num(gtp_frame_current_num);
+			ring_buffer_read(gtp_frame_iter[gtp_frame_current_cpu],
+					 NULL);
+			is_first = 0;
+			goto re_find;
+		}
+#endif
+#if defined(GTP_FRAME_SIMPLE) || defined(GTP_FTRACE_RING_BUFFER)
+		vr = NULL;
+while_stop:
+		if (vr)
+			val = vr->val;
+	}
+#endif
+#ifdef GTP_RB
+		if (gtp_rb_traceframe_get_tv(gtp_frame_current_rb->rp,
+					     gtp_frame_current_id,
+					     (unsigned int)num, &val) == 0)
+			goto output_value;
+	}
+#endif
+
+out:
+	if (var || vr) {
+output_value:
+		snprintf(gtp_rw_bufp, GTP_RW_BUFP_MAX, "V%08x%08x",
+			 (unsigned int) (val >> 32),
+			 (unsigned int) (val & 0xffffffff));
+		gtp_rw_size += strlen(gtp_rw_bufp);
+		gtp_rw_bufp += strlen(gtp_rw_bufp);
+	} else {
+		if (GTP_RW_BUFP_MAX > 1) {
+			gtp_rw_bufp[0] = 'U';
+			gtp_rw_size += 1;
+			gtp_rw_bufp += 1;
+		}
+	}
+
+	return 1;
+}
+
+static int
+gtp_gdbrsp_qT(char *pkg)
+{
+	int	ret = 1;
+
+#ifdef GTP_DEBUG
+	printk(GTP_DEBUG "gtp_gdbrsp_qT: %s\n", pkg);
+#endif
+
+	if (strcmp("Status", pkg) == 0)
+		ret = gtp_gdbrsp_qtstatus();
+	else if (strcmp("fP", pkg) == 0)
+		ret = gtp_gdbrsp_qtfp();
+	else if (strcmp("sP", pkg) == 0)
+		ret = gtp_gdbrsp_qtsp();
+	else if (strcmp("fV", pkg) == 0)
+		ret = gtp_gdbrsp_qtfsv(1);
+	else if (strcmp("sV", pkg) == 0)
+		ret = gtp_gdbrsp_qtfsv(0);
+	else if (strncmp("V:", pkg, 2) == 0)
+		ret = gtp_gdbrsp_qtv(pkg + 2);
+
+	return ret;
+}
+
+#ifdef GTP_RB
+static char		*gtp_traceframe_info;
+static unsigned int	gtp_traceframe_info_len;
+
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,30))
+/* The 2.6.30 and older version have __module_address.  */
+
+static int		gtp_modules_traceframe_info_need_get;
+static char		*gtp_modules_traceframe_info;
+static unsigned int	gtp_modules_traceframe_info_len;
+
+static int
+gtp_modules_traceframe_info_get(void)
+{
+	struct module		*mod;
+	struct gtp_realloc_s	grs;
+	int			ret = 0;
+
+	gtp_realloc_alloc(&grs, 0);
+
+	if (gtp_modules_traceframe_info_len > 0) {
+		vfree(gtp_modules_traceframe_info);
+		gtp_modules_traceframe_info = NULL;
+		gtp_modules_traceframe_info_len = 0;
+	}
+
+	mutex_lock(&module_mutex);
+	list_for_each_entry_rcu(mod, &(THIS_MODULE->list), list) {
+		if (__module_address((unsigned long)mod)) {
+			char	buf[70];
+
+			snprintf(buf, 70,
+				 "<memory start=\"0x%lx\" length=\"0x%lx\"/>\n",
+				 (unsigned long)mod->module_core,
+				 (unsigned long)mod->core_text_size);
+			ret = gtp_realloc_str(&grs, buf, 0);
+			if (ret)
+				goto out;
+		}
+	}
+	gtp_modules_traceframe_info = grs.buf;
+	gtp_modules_traceframe_info_len = grs.size;
+out:
+	mutex_unlock(&module_mutex);
+	return ret;
+}
+#endif
+
+static int
+gtp_traceframe_info_get(void)
+{
+	struct gtp_realloc_s	grs;
+	int			ret;
+	struct gtp_rb_walk_s	rbws;
+	char			*tmp;
+
+	if (gtp_traceframe_info_len > 0) {
+		vfree(gtp_traceframe_info);
+		gtp_traceframe_info = NULL;
+		gtp_traceframe_info_len = 0;
+	}
+	/* 40 is size for "<traceframe-info>\n</traceframe-info>\n" */
+	ret = gtp_realloc_alloc(&grs, 40);
+	if (ret != 0)
+		return ret;
+
+	ret = gtp_realloc_str(&grs, "<traceframe-info>\n", 0);
+	if (ret != 0)
+		return ret;
+
+	rbws.flags = GTP_RB_WALK_PASS_PAGE
+			| GTP_RB_WALK_CHECK_END
+			| GTP_RB_WALK_CHECK_ID
+			| GTP_RB_WALK_CHECK_TYPE;
+	rbws.end = gtp_frame_current_rb->w;
+	rbws.id = gtp_frame_current_id;
+	rbws.type = FID_MEM;
+	tmp = gtp_frame_current_rb->rp;
+
+	while (1) {
+		struct gtp_frame_mem	*mr;
+		char			buf[70];
+
+		tmp = gtp_rb_walk(&rbws, tmp);
+		if (rbws.reason != gtp_rb_walk_type)
+			break;
+		mr = (struct gtp_frame_mem *) (tmp + FID_SIZE);
+		snprintf(buf, 70,
+				"<memory start=\"0x%llx\" length=\"0x%llx\"/>\n",
+				(ULONGEST)mr->addr, (ULONGEST)mr->size);
+		ret = gtp_realloc_str(&grs, buf, 0);
+		if (ret != 0)
+			return ret;
+		tmp += FRAME_ALIGN(GTP_FRAME_MEM_SIZE + mr->size);
+	}
+
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,30))
+	if (gtp_modules_traceframe_info_need_get) {
+		int	ret = gtp_modules_traceframe_info_get();
+		if (ret != 0)
+			return ret;
+		gtp_modules_traceframe_info_need_get = 0;
+	}
+	if (gtp_modules_traceframe_info_len > 0) {
+		tmp = gtp_realloc(&grs, gtp_modules_traceframe_info_len, 0);
+		if (tmp == NULL)
+			return -ENOMEM;
+		memcpy(tmp, gtp_modules_traceframe_info,
+		       gtp_modules_traceframe_info_len);
+	}
+#endif
+
+	ret = gtp_realloc_str(&grs, "</traceframe-info>\n", 1);
+	if (ret != 0)
+		return ret;
+
+	gtp_traceframe_info = grs.buf;
+	gtp_traceframe_info_len = grs.size;
+
+	return 0;
+}
+
+#ifdef GTP_RB
+
+static uint64_t	gtp_replay_step_id = 0;
+static ULONGEST	gtp_replay_step_tpe = 0;
+/* Point to the first entry of step.  */
+static void	*gtp_replay_step_begin = NULL;
+/* Point to the address that after last entry.  */
+static void	*gtp_replay_step_end = NULL;
+
+static void
+gtp_replay_reset(void)
+{
+	gtp_replay_step_id = 0;
+	gtp_replay_step_tpe = 0;
+
+	gtp_rb_read_reset();
+}
+
+#endif
+
+static int
+gtp_gdbrsp_qxfer_traceframe_info_read(char *pkg)
+{
+	ULONGEST	offset, len;
+
+#ifdef GTP_FRAME_SIMPLE
+	if (gtp_start || !gtp_frame_current)
+#endif
+#ifdef GTP_FTRACE_RING_BUFFER
+	if (gtp_start || gtp_frame_current_num < 0)
+#endif
+#ifdef GTP_RB
+	/* For gtp_replay_step_tpe, the KGTP is in replay mode.  Send traceframe_info
+	   will make GDB got error with access the memory.  So return -EINVAL.  */
+	if (gtp_start || gtp_frame_current_num < 0 || gtp_replay_step_tpe)
+#endif
+		return -EINVAL;
+
+	pkg = hex2ulongest(pkg, &offset);
+	if (pkg[0] != ',')
+		return -EINVAL;
+	pkg++;
+	pkg = hex2ulongest(pkg, &len);
+	if (len == 0)
+		return -EINVAL;
+
+	if (GTP_RW_BUFP_MAX < 10)
+		return -EINVAL;
+
+	if (offset == 0) {
+		int	ret = gtp_traceframe_info_get();
+		if (ret != 0)
+			return ret;
+	}
+
+	if (len > GTP_RW_BUFP_MAX - 1)
+		len = GTP_RW_BUFP_MAX - 1;
+
+	if (len >= gtp_traceframe_info_len - offset) {
+		len = gtp_traceframe_info_len - offset;
+		gtp_rw_bufp[0] = 'l';
+		gtp_rw_size += 1;
+		gtp_rw_bufp += 1;
+	} else {
+		if (GTP_RW_BUFP_MAX > 1) {
+			gtp_rw_bufp[0] = 'm';
+			gtp_rw_size += 1;
+			gtp_rw_bufp += 1;
+		}
+	}
+
+	memcpy(gtp_rw_bufp, gtp_traceframe_info + offset, len);
+	gtp_rw_size += len;
+	gtp_rw_bufp += len;
+
+	return 1;
+}
+#endif
+
+static uint8_t	gtp_m_buffer[0xffff];
+
+static int
+gtp_gdbrsp_m(char *pkg)
+{
+	int		i;
+	ULONGEST	addr, len;
+
+	/* Get add and len.  */
+	if (pkg[0] == '\0')
+		return -EINVAL;
+	pkg = hex2ulongest(pkg, &addr);
+	if (pkg[0] != ',')
+		return -EINVAL;
+	pkg++;
+	pkg = hex2ulongest(pkg, &len);
+	if (len == 0)
+		return -EINVAL;
+	len &= 0xffff;
+	len = (ULONGEST) min((int)(GTP_RW_BUFP_MAX / 2),
+			     (int)len);
+
+#ifdef GTP_DEBUG
+	printk(GTP_DEBUG "gtp_gdbrsp_m: addr = 0x%lx len = %d\n",
+		(unsigned long) addr, (int) len);
+#endif
+
+#ifdef GTP_FRAME_SIMPLE
+	if (gtp_start || !gtp_frame_current) {
+#elif defined(GTP_FTRACE_RING_BUFFER) || defined(GTP_RB)
+	if (gtp_start || gtp_frame_current_num < 0) {
+#endif
+		if (gtp_current_pid) {
+			int ret = gtp_task_read(gtp_current_pid, NULL, addr,
+						gtp_m_buffer, (int)len, 0);
+			if (ret < 0)
+				return ret;
+			if (ret != len)
+				return -EFAULT;
+
+			goto out;
+		} else {
+			if (probe_kernel_read(gtp_m_buffer,
+					      (void *)(CORE_ADDR)addr,
+					      (size_t)len))
+				return -EFAULT;
+		}
+	} else {
+#ifdef GTP_FRAME_SIMPLE
+		char	*next;
+#endif
+		int	ret;
+
+		/* XXX: Issue 1: The following part is for gtpro support.
+		   It is not available because it make disassemble cannot
+		   work when select a trace frame. */
+#if 0
+		struct gtpro_entry	*gtroe;
+
+		memset(gtp_m_buffer, 0, len);
+
+		/* Read the gtpro.  */
+		for (gtroe = gtpro_list; gtroe; gtroe = gtroe->next) {
+			CORE_ADDR	cur_start, cur_end;
+
+			cur_start = max(gtroe->start, (CORE_ADDR)addr);
+			cur_end = min(gtroe->end, ((CORE_ADDR)(addr + len)));
+			if (cur_start < cur_end) {
+#ifdef GTP_DEBUG
+				printk(GTP_DEBUG "gtp_gdbrsp_m: ro read "
+						 "start = 0x%lx end = 0x%lx\n",
+				       (unsigned long) cur_start,
+				       (unsigned long) cur_end);
+#endif
+				if (probe_kernel_read(gtp_m_buffer,
+						       (void *)cur_start,
+						       (size_t)(cur_end
+								- cur_start)))
+					return -EFAULT;
+			}
+		}
+#endif
+		ret = probe_kernel_read(gtp_m_buffer, (void *)(CORE_ADDR)addr,
+					(size_t)len);
+#ifdef GTP_FRAME_SIMPLE
+		for (next = *(char **)(gtp_frame_current + FID_SIZE); next;
+		     next = *(char **)(next + FID_SIZE)) {
+			if (FID(next) == FID_MEM) {
+				struct gtp_frame_mem	*mr;
+				ULONGEST		cur_start, cur_end;
+				uint8_t			*buf;
+
+				mr = (struct gtp_frame_mem *)
+				     (next + FID_SIZE + sizeof(char *));
+				buf = next + GTP_FRAME_MEM_SIZE;
+#ifdef GTP_DEBUG
+				printk(GTP_DEBUG "gtp_gdbrsp_m: section "
+						 "addr = 0x%lx size = %lu\n",
+				       (unsigned long) mr->addr,
+				       (unsigned long) mr->size);
+#endif
+				cur_start = max(((ULONGEST)mr->addr), addr);
+				cur_end = min(((ULONGEST)mr->addr
+						+ mr->size),
+					       (addr + len));
+#ifdef GTP_DEBUG
+				printk(GTP_DEBUG "gtp_gdbrsp_m: read "
+						 "start = 0x%lx end = 0x%lx\n",
+				       (unsigned long) cur_start,
+				       (unsigned long) cur_end);
+#endif
+				if (cur_start < cur_end) {
+					memcpy(gtp_m_buffer + cur_start - addr,
+						buf + cur_start - mr->addr,
+						cur_end - cur_start);
+					ret = 0;
+				}
+			}
+		}
+#endif
+#ifdef GTP_FTRACE_RING_BUFFER
+		gtp_frame_head_find_num(gtp_frame_current_num);
+		ring_buffer_read(gtp_frame_iter[gtp_frame_current_cpu], NULL);
+
+		while (1) {
+			struct ring_buffer_event	*rbe;
+			char				*tmp;
+
+			rbe = ring_buffer_iter_peek
+				(gtp_frame_iter[gtp_frame_current_cpu], NULL);
+			if (rbe == NULL)
+				break;
+			tmp = ring_buffer_event_data(rbe);
+			if (FID(tmp) == FID_HEAD)
+				break;
+			if (FID(tmp) == FID_MEM) {
+				struct gtp_frame_mem	*mr;
+				ULONGEST		cur_start, cur_end;
+				uint8_t			*buf;
+
+				mr = (struct gtp_frame_mem *)
+				     (tmp + FID_SIZE);
+				buf = tmp + GTP_FRAME_MEM_SIZE;
+#ifdef GTP_DEBUG
+				printk(GTP_DEBUG "gtp_gdbrsp_m: section "
+						 "addr = 0x%lx size = %lu\n",
+				       (unsigned long) mr->addr,
+				       (unsigned long) mr->size);
+#endif
+				cur_start = max(((ULONGEST)mr->addr), addr);
+				cur_end = min(((ULONGEST)mr->addr
+						+ mr->size),
+					       (addr + len));
+#ifdef GTP_DEBUG
+				printk(GTP_DEBUG "gtp_gdbrsp_m: read "
+						 "start = 0x%lx end = 0x%lx\n",
+				       (unsigned long) cur_start,
+				       (unsigned long) cur_end);
+#endif
+				if (cur_start < cur_end) {
+					memcpy(gtp_m_buffer + cur_start - addr,
+						buf + cur_start - mr->addr,
+						cur_end - cur_start);
+					ret = 0;
+				}
+			}
+			ring_buffer_read(gtp_frame_iter[gtp_frame_current_cpu],
+					 NULL);
+		}
+#endif
+#ifdef GTP_RB
+		{
+			struct gtp_rb_walk_s	rbws;
+			char			*tmp;
+
+			rbws.flags = GTP_RB_WALK_PASS_PAGE
+				     | GTP_RB_WALK_CHECK_END
+				     | GTP_RB_WALK_CHECK_ID
+				     | GTP_RB_WALK_CHECK_TYPE;
+			rbws.end = gtp_frame_current_rb->w;
+			rbws.id = gtp_frame_current_id;
+			rbws.type = FID_MEM;
+			tmp = gtp_frame_current_rb->rp;
+
+			while (1) {
+				struct gtp_frame_mem	*mr;
+				ULONGEST		cur_start, cur_end;
+				uint8_t			*buf;
+
+				tmp = gtp_rb_walk(&rbws, tmp);
+				if (rbws.reason != gtp_rb_walk_type)
+					break;
+
+				mr = (struct gtp_frame_mem *) (tmp + FID_SIZE);
+				buf = tmp + GTP_FRAME_MEM_SIZE;
+#ifdef GTP_DEBUG
+				printk(GTP_DEBUG "gtp_gdbrsp_m: section "
+						 "addr = 0x%lx size = %lu\n",
+				       (unsigned long) mr->addr,
+				       (unsigned long) mr->size);
+#endif
+				cur_start = max(((ULONGEST)mr->addr), addr);
+				cur_end = min(((ULONGEST)mr->addr
+						+ mr->size),
+					       (addr + len));
+#ifdef GTP_DEBUG
+				printk(GTP_DEBUG "gtp_gdbrsp_m: read "
+						 "start = 0x%lx end = 0x%lx\n",
+				       (unsigned long) cur_start,
+				       (unsigned long) cur_end);
+#endif
+				if (cur_start < cur_end) {
+					memcpy(gtp_m_buffer + cur_start - addr,
+						buf + cur_start - mr->addr,
+						cur_end - cur_start);
+					ret = 0;
+				}
+
+				tmp += FRAME_ALIGN(GTP_FRAME_MEM_SIZE
+						   + mr->size);
+			}
+		}
+#endif
+		if (ret)
+			return -EFAULT;
+	}
+
+out:
+	for (i = 0; i < (int)len; i++) {
+#ifdef GTP_DEBUG
+		printk(GTP_DEBUG "gtp_gdbrsp_m: %d %02x\n", i, gtp_m_buffer[i]);
+#endif
+		sprintf(gtp_rw_bufp, "%02x", gtp_m_buffer[i]);
+		gtp_rw_bufp += 2;
+		gtp_rw_size += 2;
+	}
+
+	return 1;
+}
+
+#ifdef GTP_RB
+static struct pt_regs *
+gtp_rb_traceframe_get_regs(void)
+{
+	if (gtp_frame_current_regs == NULL) {
+		struct gtp_rb_walk_s	rbws;
+		char			*tmp;
+
+		rbws.flags = GTP_RB_WALK_PASS_PAGE | GTP_RB_WALK_CHECK_END
+			     | GTP_RB_WALK_CHECK_ID | GTP_RB_WALK_CHECK_TYPE;
+		rbws.end = gtp_frame_current_rb->w;
+		rbws.id = gtp_frame_current_id;
+		rbws.type = FID_REG;
+		tmp = gtp_rb_walk(&rbws, gtp_frame_current_rb->rp);
+		if (rbws.reason == gtp_rb_walk_type)
+			gtp_frame_current_regs = (struct pt_regs *)(tmp + FID_SIZE);
+	}
+
+	return gtp_frame_current_regs;
+}
+#endif
+
+static int
+gtp_gdbrsp_g(void)
+{
+#ifdef GTP_FRAME_SIMPLE
+	char		*next;
+#endif
+	struct pt_regs	*regs;
+
+	if (GTP_RW_BUFP_MAX < GTP_REG_ASCII_SIZE)
+		return -E2BIG;
+
+#ifdef GTP_FRAME_SIMPLE
+	if (gtp_start || !gtp_frame_current) {
+#elif defined(GTP_FTRACE_RING_BUFFER) || defined(GTP_RB)
+	if (gtp_start || gtp_frame_current_num < 0) {
+#endif
+		memset(gtp_rw_bufp, '0', GTP_REG_ASCII_SIZE);
+		goto out;
+	}
+
+	/* Get the regs.  */
+#if defined(GTP_FTRACE_RING_BUFFER) || defined(GTP_FRAME_SIMPLE)
+	regs = NULL;
+#endif
+#ifdef GTP_FRAME_SIMPLE
+	for (next = *(char **)(gtp_frame_current + FID_SIZE); next;
+	     next = *(char **)(next + FID_SIZE)) {
+		if (FID(next) == FID_REG) {
+			regs = (struct pt_regs *)
+			       (next + FID_SIZE + sizeof(char *));
+			break;
+		}
+	}
+#endif
+#ifdef GTP_FTRACE_RING_BUFFER
+	{
+		int				is_first = 1;
+		struct ring_buffer_event	*rbe;
+		char				*tmp;
+
+re_find:
+		while (1) {
+			rbe = ring_buffer_iter_peek
+				(gtp_frame_iter[gtp_frame_current_cpu], NULL);
+			if (rbe == NULL)
+				break;
+			tmp = ring_buffer_event_data(rbe);
+			if (FID(tmp) == FID_HEAD)
+				break;
+			if (FID(tmp) == FID_REG) {
+				regs = (struct pt_regs *)(tmp + FID_SIZE);
+				is_first = 0;
+				break;
+			}
+			ring_buffer_read(gtp_frame_iter[gtp_frame_current_cpu],
+					 NULL);
+		}
+		if (is_first) {
+			gtp_frame_head_find_num(gtp_frame_current_num);
+			ring_buffer_read(gtp_frame_iter[gtp_frame_current_cpu],
+					 NULL);
+			is_first = 0;
+			goto re_find;
+		}
+	}
+#endif
+#ifdef GTP_RB
+	regs = gtp_rb_traceframe_get_regs();
+#endif
+	if (regs)
+		gtp_regs2ascii(regs, gtp_rw_bufp);
+	else {
+		struct pt_regs		pregs;
+		struct gtp_entry	*tpe;
+
+		memset(&pregs, '\0', sizeof(struct pt_regs));
+		tpe = gtp_list_find_without_addr_do_check(gtp_frame_current_tpe);
+		if (tpe)
+			GTP_REGS_PC(&pregs) = (unsigned long)tpe->addr;
+		gtp_regs2ascii(&pregs, gtp_rw_bufp);
+	}
+out:
+	gtp_rw_bufp += GTP_REG_ASCII_SIZE;
+	gtp_rw_size += GTP_REG_ASCII_SIZE;
+
+	return 1;
+}
+
+static int
+gtp_gdbrsp_vAttach(char *pkg)
+{
+	ULONGEST		pid;
+
+	if (pkg[0] == '\0')
+		return -EINVAL;
+	pkg = hex2ulongest(pkg, &pid);
+	if (pid == 0)
+		return -EINVAL;
+
+	gtp_current_pid = (pid_t)pid;
+
+	snprintf(gtp_rw_bufp, GTP_RW_BUFP_MAX, "S05");
+	gtp_rw_bufp += 3;
+	gtp_rw_size += 3;
+	return 1;
+}
+
+static void
+gtp_gdbrsp_D(char *pkg)
+{
+	if (pkg[0] == ';')
+		pkg++;
+	if (pkg[0] == 'p')
+		pkg++;
+
+	if (pkg[0] != '\0') {
+		/* Try to get pid.  */
+		ULONGEST	pid;
+
+		pkg = hex2ulongest(pkg, &pid);
+		if (gtp_current_pid == (pid_t)pid)
+			gtp_current_pid = 0;
+	} else
+		gtp_current_pid = 0;
+}
+
+/* Handle H + OP + thread-id packet. */
+
+static int
+gtp_gdbrsp_H(char *pkg)
+{
+	ULONGEST		pid;
+
+	if (pkg[0] != 'g')
+		return -EINVAL;
+	pkg++;
+	pkg = hex2ulongest(pkg, &pid);
+
+#ifdef GTP_RB
+	if (gtp_replay_step_id)
+		gtp_replay_reset();
+#endif
+
+	gtp_current_pid = (pid_t)pid;
+
+	return 0;
+}
+
+static int
+gtp_gdbrsp_qRcmd(char *pkg)
+{
+	int	buf_size = strlen(pkg) / 2;
+	char	buf[buf_size];
+
+	if (buf_size * 2 != strlen(pkg))
+		return -EINVAL;
+	hex2string(pkg, buf);
+
+#ifdef GTP_RB
+ 	if (strcmp(buf, "replay") == 0) {
+		if (gtp_replay_step_id) {
+			printk(KERN_WARNING "KGTP: already in step replay mode.\n");
+			return -EBUSY;
+		}
+
+		if (gtp_start || gtp_frame_current_num < 0) {
+			printk(KERN_WARNING "KGTP: cannot goto step replay mode because doesn't select any frame.\n");
+			return -EBUSY;
+		}
+
+		if (gtp_rb_traceframe_get_tv(gtp_frame_current_rb->rp,
+					     gtp_frame_current_id,
+					     GTP_STEP_ID_ID,
+					     &gtp_replay_step_id)) {
+			printk(KERN_WARNING "KGTP: cannot goto step replay mode because current frame doesn't have $step_id.\n");
+			return -EBUSY;
+		}
+
+		gtp_replay_step_tpe = gtp_frame_current_tpe;
+		gtp_replay_step_begin = NULL;
+		gtp_replay_step_end = NULL;
+
+		return 0;
+	} else if (strcmp(buf, "replay stop") == 0) {
+		if (gtp_replay_step_id == 0) {
+			printk(KERN_WARNING "KGTP: not in step replay mode.\n");
+			return -EBUSY;
+		}
+
+		gtp_replay_reset();
+
+		return 0;
+	}
+#endif
+
+	return 1;
+}
+
+struct gtp_breakpoints_s {
+	struct list_head	node;
+	ULONGEST		addr;
+};
+static LIST_HEAD(gtp_breakpoints);
+
+static void
+gtp_breakpoints_release(void)
+{
+	struct gtp_breakpoints_s	*b;
+	struct list_head		*cur, *tmp;
+
+	list_for_each_safe(cur, tmp, &gtp_breakpoints) {
+		b = list_entry(cur, struct gtp_breakpoints_s, node);
+		list_del(&b->node);
+		kfree(b);
+	}
+}
+
+static struct gtp_breakpoints_s *
+gtp_breakpoints_find(ULONGEST addr)
+{
+	struct list_head	*cur;
+
+	list_for_each(cur, &gtp_breakpoints) {
+		struct gtp_breakpoints_s	*b;
+
+		b = list_entry(cur, struct gtp_breakpoints_s, node);
+		if (b->addr == addr)
+			return b;
+	}
+
+	return NULL;
+}
+
+static int
+gtp_gdbrsp_breakpoint(char *pkg, int insert)
+{
+	ULONGEST			addr;
+	struct gtp_breakpoints_s	*b = NULL;
+
+	/* Get addr.  */
+	if (pkg[0] == '\0')
+		return -EINVAL;
+	pkg = hex2ulongest(pkg, &addr);
+	if (pkg[0] != ',')
+		return -EINVAL;
+
+	if (insert) {
+		b = (struct gtp_breakpoints_s *)kmalloc(sizeof(*b), GFP_KERNEL);
+		if (b == NULL)
+			return -ENOMEM;
+		b->addr = addr;
+		list_add_tail(&b->node, &gtp_breakpoints);
+	} else {
+		b = gtp_breakpoints_find(addr);
+		if (b) {
+			list_del(&b->node);
+			kfree(b);
+		} else
+			return -EINVAL;
+	}
+
+	return 0;
+}
+
+/* Get a new entry but still not have gtp_replay_step_end.
+   Check if ENTRY is belong to the current step entry list.
+   If yes, return true.  */
+
+static int
+gtp_traceframe_check(void *entry)
+{
+	if (*(u64 *)(entry + FID_SIZE + sizeof(u64)) != gtp_replay_step_tpe) {
+		/* Check the tracepoint id.  */
+		return 0;
+	} else {
+		uint64_t	val;
+
+		/* Check $step_id.  */
+		if (gtp_rb_traceframe_get_tv(entry + FRAME_ALIGN(GTP_FRAME_HEAD_SIZE),
+					     *(u64 *)(entry + FID_SIZE),
+					     GTP_STEP_ID_ID, &val))
+			return 0;
+		if (val != gtp_replay_step_id)
+			return 0;
+	}
+
+	return 1;
+}
+
+/* Step forward one step.
+   Return == 0 is OK.
+   Return > 0 is to the end.  */
+
+static int
+gtp_gdbrsp_step_forward(void)
+{
+	struct gtp_rb_walk_s	rbws;
+	void			*tmp;
+
+	if (gtp_replay_step_id == 0) {
+		printk(KERN_WARNING "KGTP: not in step replay mode.\n");
+		return -EBUSY;
+	}
+
+	rbws.flags = GTP_RB_WALK_PASS_PAGE | GTP_RB_WALK_CHECK_END;
+	if (gtp_replay_step_end)
+		rbws.end = gtp_replay_step_end;
+	else
+		rbws.end = gtp_frame_current_rb->w;
+	tmp = gtp_rb_walk(&rbws, gtp_frame_current_rb->rp);
+	if (rbws.reason != gtp_rb_walk_new_entry)
+		/* To the begin of gtp_frame_current_rb
+		   or to the begin of this step.
+		   Both of them can be set as the begin of this step.  */
+		goto end_out;
+	if (gtp_replay_step_end == NULL) {
+		/* Get a new entry but still not have gtp_replay_step_end.
+		   Need check if this is a entry of current step first.  */
+		if (!gtp_traceframe_check(tmp))
+			goto end_out;
+	}
+
+	gtp_frame_current_rb->rp = tmp;
+	gtp_rb_update_gtp_frame_current();
+	return 0;
+
+end_out:
+	/* Set it as gtp_replay_step_end if it is not belong to
+	   current step.  */
+	if (gtp_replay_step_end == NULL)
+		gtp_replay_step_end = tmp;
+	return 1;
+}
+
+/* Step reverse one step.
+   Return == 0 is OK.
+   Return > 0 is to the end.  */
+
+static int
+gtp_gdbrsp_step_reverse(void)
+{
+	void	*tmp;
+	void	*current_rp;
+
+	if (gtp_replay_step_id == 0) {
+		printk(KERN_WARNING "KGTP: not in step replay mode.\n");
+		return -EBUSY;
+	}
+
+	current_rp = gtp_frame_current_rb->rp - FRAME_ALIGN(GTP_FRAME_HEAD_SIZE);
+	tmp = gtp_rb_walk_reverse(current_rp,
+				  gtp_replay_step_begin ? gtp_replay_step_begin
+							: gtp_frame_current_rb->r);
+	if (tmp == NULL)
+		goto end_out;
+	
+	if (gtp_replay_step_begin == NULL) {
+		/* Get a new entry but still not have gtp_replay_step_begin.
+		   Need check if this is a entry of current step first.  */
+		if (!gtp_traceframe_check(tmp))
+			goto end_out;
+	}
+
+	gtp_frame_current_rb->rp = tmp;
+	gtp_rb_update_gtp_frame_current();
+
+	return 0;
+
+end_out:
+	if (gtp_replay_step_begin == NULL)
+		gtp_replay_step_begin = current;
+	return 1;
+}
+
+static int
+gtp_gdbrsp_resume(int step, int reverse)
+{
+	int	ret = 0;
+
+	if (gtp_replay_step_id == 0) {
+		printk(KERN_WARNING "KGTP: not in step replay mode.\n");
+		return -EBUSY;
+	}
+
+	do {
+		if (reverse)
+			ret = gtp_gdbrsp_step_reverse();
+		else
+			ret = gtp_gdbrsp_step_forward();
+
+		/* Check if in the begin or end of entry list.  */
+		if (ret)
+			break;
+
+		/* Check if exec stop by breakpoints.  */
+		if (!step && !list_empty(&gtp_breakpoints)) {
+			struct pt_regs	*regs;
+
+			regs = gtp_rb_traceframe_get_regs();
+			if (regs == NULL)
+				printk(KERN_WARNING "KGTP: a traceframe doesn't include regs.\n");
+			else {
+				if (gtp_breakpoints_find(GTP_REGS_PC(regs)) != NULL)
+					break;
+			}
+		}
+	} while (!step);
+
+	if (ret)
+		snprintf(gtp_rw_bufp, GTP_RW_BUFP_MAX,
+			 "T05replaylog:%s;", reverse ? "begin" : "end");
+	else
+		snprintf(gtp_rw_bufp, GTP_RW_BUFP_MAX, "S05");
+	gtp_rw_size += strlen(gtp_rw_bufp);
+	gtp_rw_bufp += strlen(gtp_rw_bufp);
+
+	return 1;
+}
+
+static DEFINE_SEMAPHORE(gtp_rw_lock);
+static DECLARE_WAIT_QUEUE_HEAD(gtp_rw_wq);
+static unsigned int	gtp_rw_count;
+static unsigned int	gtp_frame_count;
+
+static void
+gtp_frame_count_get(void)
+{
+	if (gtp_frame_count == 0)
+		gtp_plugin_mod_get();
+	
+	gtp_frame_count++;
+}
+
+static void
+gtp_frame_count_put(void)
+{
+	gtp_frame_count--;
+	if (gtp_frame_count == 0) {
+		gtp_plugin_mod_put();
+
+		if (!gtp_disconnected_tracing) {
+			gtp_gdbrsp_qtstop();
+			gtp_gdbrsp_qtinit();
+#ifdef GTP_RB
+			if (!GTP_RB_PAGE_IS_EMPTY)
+				gtp_rb_page_free();
+#endif
+#if defined(GTP_FRAME_SIMPLE) || defined(GTP_FTRACE_RING_BUFFER)
+			if (gtp_frame) {
+#ifdef GTP_FRAME_SIMPLE
+				vfree(gtp_frame);
+#endif
+#ifdef GTP_FTRACE_RING_BUFFER
+				ring_buffer_free(gtp_frame);
+#endif
+				gtp_frame = NULL;
+			}
+#endif
+		}
+	}
+}
+
+static int
+gtp_open(struct inode *inode, struct file *file)
+{
+	int	ret = 0;
+
+	down(&gtp_rw_lock);
+	if (gtp_gtp_pid >= 0) {
+		if (get_current()->pid != gtp_gtp_pid) {
+			ret = -EBUSY;
+			goto out;
+		}
+	}
+	gtp_noack_mode = 0;
+
+	if (gtp_rw_count == 0) {
+		gtp_read_ack = 0;
+		gtp_rw_buf = vmalloc(GTP_RW_MAX);
+		if (!gtp_rw_buf) {
+			ret = -ENOMEM;
+			goto out;
+		}
+		gtp_rw_bufp = gtp_rw_buf;
+		gtp_rw_size = 0;
+	}
+	gtp_rw_count++;
+
+	gtp_frame_count_get();
+
+	gtp_gtp_pid_count++;
+	if (gtp_gtp_pid < 0)
+		gtp_gtp_pid = get_current()->pid;
+
+out:
+	up(&gtp_rw_lock);
+	return ret;
+}
+
+static int
+gtp_release(struct inode *inode, struct file *file)
+{
+#ifdef GTP_DEBUG
+	printk(GTP_DEBUG "gtp_release\n");
+#endif
+	down(&gtp_rw_lock);
+	gtp_rw_count--;
+	if (gtp_rw_count == 0) {
+		vfree(gtp_rw_buf);
+
+		if (gtp_replay_step_id)
+			gtp_replay_reset();
+
+		gtp_breakpoints_release();
+	}
+
+	gtp_frame_count_put();
+
+	gtp_gtp_pid_count--;
+	if (gtp_gtp_pid_count == 0) {
+		gtp_current_pid = 0;
+		gtp_gtp_pid = -1;
+	}
+
+	up(&gtp_rw_lock);
+
+	return 0;
+}
+
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,35))
+static int
+gtp_ioctl(struct inode *inode, struct file *file,
+	  unsigned int cmd, unsigned long arg)
+{
+#ifdef GTP_DEBUG
+	printk(GTP_DEBUG "gtp_ioctl: %x\n", cmd);
+#endif
+
+	return 0;
+}
+#else
+static long
+gtp_ioctl(struct file *file, unsigned int cmd, unsigned long arg)
+{
+#ifdef GTP_DEBUG
+	printk(GTP_DEBUG "gtp_ioctl: %x\n", cmd);
+#endif
+
+	return 0;
+}
+#endif
+
+static ssize_t
+gtp_write(struct file *file, const char __user *buf, size_t size,
+	  loff_t *ppos)
+{
+	char		*rsppkg = NULL;
+	int		i, ret;
+	unsigned char	csum;
+	int		is_reverse;
+
+	if (down_interruptible(&gtp_rw_lock))
+		return -EINTR;
+
+	if (size == 0) {
+#ifdef GTP_DEBUG
+		printk(GTP_DEBUG "gtp_write: try write 0 size.\n");
+#endif
+		goto error_out;
+	}
+
+	size = min_t(size_t, size, GTP_RW_MAX);
+	if (copy_from_user(gtp_rw_buf, buf, size)) {
+		size = -EFAULT;
+		goto error_out;
+	}
+
+	if (gtp_rw_buf[0] == '+' || gtp_rw_buf[0] == '-'
+	    || gtp_rw_buf[0] == '\3' || gtp_rw_buf[0] == '\n') {
+		if (gtp_rw_buf[0] == '+')
+			gtp_rw_size = 0;
+		size = 1;
+		goto out;
+	}
+
+	if (size < 4) {
+		size = -EINVAL;
+		goto error_out;
+	}
+	/* Check format and get the rsppkg.  */
+	for (i = 0; i < size - 2; i++) {
+		if (gtp_rw_buf[i] == '$')
+			rsppkg = gtp_rw_buf + i + 1;
+		else if (gtp_rw_buf[i] == '#')
+			break;
+	}
+	if (rsppkg && gtp_rw_buf[i] == '#') {
+		/* Format is OK.  Check crc.  */
+		if (gtp_noack_mode < 1)
+			gtp_read_ack = 1;
+		size = i + 3;
+		gtp_rw_buf[i] = '\0';
+	} else {
+		printk(KERN_WARNING "gtp_write: format error\n");
+		size = -EINVAL;
+		goto error_out;
+	}
+
+	wake_up_interruptible_nr(&gtp_rw_wq, 1);
+
+	up(&gtp_rw_lock);
+	if (down_interruptible(&gtp_rw_lock))
+		return -EINTR;
+
+#ifdef GTP_DEBUG
+	printk(GTP_DEBUG "gtp_write: %s\n", rsppkg);
+#endif
+
+	/* Handle rsppkg and put return to gtp_rw_buf.  */
+	gtp_rw_buf[0] = '$';
+	gtp_rw_bufp = gtp_rw_buf + 1;
+	gtp_rw_size = 0;
+	ret = 1;
+	is_reverse = 0;
+	switch (rsppkg[0]) {
+	case '?':
+		snprintf(gtp_rw_bufp, GTP_RW_BUFP_MAX, "S05");
+		gtp_rw_bufp += 3;
+		gtp_rw_size += 3;
+		break;
+	case 'g':
+		ret = gtp_gdbrsp_g();
+		break;
+	case 'm':
+		ret = gtp_gdbrsp_m(rsppkg + 1);
+		break;
+	case 'Q':
+#ifdef GTP_RB
+		/* This check for "tfind -1" and let GDB into step replay.
+		   XXX: just test on X86_64.  */
+		if (gtp_replay_step_id) {
+			if (strcmp("QTFrame:ffffffff", rsppkg) == 0) {
+				ret = 0;
+				goto switch_done;
+			} else
+				gtp_replay_reset();
+		}
+#endif
+		if (rsppkg[1] == 'T')
+			ret = gtp_gdbrsp_QT(rsppkg + 2);
+		else if (strncmp("QStartNoAckMode", rsppkg, 15) == 0) {
+			ret = 0;
+			gtp_noack_mode = -1;
+		}
+		break;
+	case 'q':
+		if (rsppkg[1] == 'T')
+			ret = gtp_gdbrsp_qT(rsppkg + 2);
+		else if (rsppkg[1] == 'C') {
+			snprintf(gtp_rw_bufp, GTP_RW_BUFP_MAX, "QC%x",
+				 gtp_current_pid);
+			gtp_rw_size += strlen(gtp_rw_bufp);
+			gtp_rw_bufp += strlen(gtp_rw_bufp);
+			ret = 1;
+		} else if (strncmp("qSupported", rsppkg, 10) == 0) {
+#ifdef GTP_RB
+			snprintf(gtp_rw_bufp, GTP_RW_BUFP_MAX,
+				 "QStartNoAckMode+;ConditionalTracepoints+;"
+				 "TracepointSource+;DisconnectedTracing+;"
+				 "ReverseContinue+;ReverseStep+;"
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,30))
+				 "EnableDisableTracepoints+;"
+#endif
+				 "qXfer:traceframe-info:read+;");
+#endif
+#if defined(GTP_FRAME_SIMPLE) || defined(GTP_FTRACE_RING_BUFFER)
+			snprintf(gtp_rw_bufp, GTP_RW_BUFP_MAX,
+				 "QStartNoAckMode+;ConditionalTracepoints+;"
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,30))
+				 "EnableDisableTracepoints+;"
+#endif
+				 "TracepointSource+;DisconnectedTracing+;");
+#endif
+			gtp_rw_size += strlen(gtp_rw_bufp);
+			gtp_rw_bufp += strlen(gtp_rw_bufp);
+			ret = 1;
+		}
+#ifdef GTP_RB
+		else if (strncmp("qXfer:traceframe-info:read::",
+				   rsppkg, 28) == 0)
+			ret = gtp_gdbrsp_qxfer_traceframe_info_read(rsppkg
+								    + 28);
+#endif
+		else if (strncmp("qRcmd,", rsppkg, 6) == 0)
+			ret = gtp_gdbrsp_qRcmd(rsppkg + 6);
+		break;
+	case 'S':
+	case 'C':
+		ret = -1;
+		break;
+	case 'b':
+		rsppkg[0] = rsppkg[1];
+		is_reverse = 1;
+	case 's':
+	case 'c':
+		ret = gtp_gdbrsp_resume (rsppkg[0] == 's', is_reverse);
+		break;
+	case 'v':
+		if (strncmp("vAttach;", rsppkg, 8) == 0) {
+#ifdef GTP_RB
+			if (gtp_replay_step_id)
+				gtp_replay_reset();
+#endif
+			ret = gtp_gdbrsp_vAttach(rsppkg + 8);
+		}
+		break;
+	case 'D':
+#ifdef GTP_RB
+		if (gtp_replay_step_id)
+			gtp_replay_reset();
+#endif
+		gtp_gdbrsp_D(rsppkg + 1);
+		ret = 0;
+		break;
+	case 'H':
+		ret = gtp_gdbrsp_H(rsppkg + 1);
+		break;
+	case 'Z':
+	case 'z':
+		if (rsppkg[1] == '0')
+			ret = gtp_gdbrsp_breakpoint(rsppkg + 3,
+						    (rsppkg[0] == 'Z'));
+		break;
+	}
+switch_done:
+	if (ret == 0) {
+		snprintf(gtp_rw_bufp, GTP_RW_BUFP_MAX, "OK");
+		gtp_rw_bufp += 2;
+		gtp_rw_size += 2;
+	} else if (ret < 0) {
+		snprintf(gtp_rw_bufp, GTP_RW_BUFP_MAX, "E%02x", -ret);
+		gtp_rw_bufp += 3;
+		gtp_rw_size += 3;
+	}
+
+	gtp_rw_bufp[0] = '#';
+	csum = 0;
+	for (i = 1; i < gtp_rw_size + 1; i++)
+		csum += gtp_rw_buf[i];
+	gtp_rw_bufp[1] = INT2CHAR(csum >> 4);
+	gtp_rw_bufp[2] = INT2CHAR(csum & 0x0f);
+	gtp_rw_bufp = gtp_rw_buf;
+	gtp_rw_size += 4;
+
+out:
+	wake_up_interruptible_nr(&gtp_rw_wq, 1);
+error_out:
+	up(&gtp_rw_lock);
+	return size;
+}
+
+static ssize_t
+gtp_read(struct file *file, char __user *buf, size_t size,
+	 loff_t *ppos)
+{
+	int	err;
+
+#ifdef GTP_DEBUG
+	printk(GTP_DEBUG "gtp_read\n");
+#endif
+
+	if (size == 0)
+		return 0;
+
+	if (down_interruptible(&gtp_rw_lock))
+		return -EINTR;
+
+	if (gtp_noack_mode < 1 && gtp_read_ack) {
+		err = put_user('+', buf);
+		if (err) {
+			size = -err;
+			goto out;
+		}
+		gtp_read_ack = 0;
+		size = 1;
+		if (gtp_noack_mode < 0)
+			gtp_noack_mode = 1;
+		goto out;
+	}
+
+	size = min(gtp_rw_size, size);
+	if (size == 0)
+		goto out;
+	if (copy_to_user(buf, gtp_rw_bufp, size)) {
+		size = -EFAULT;
+		goto out;
+	}
+	gtp_rw_bufp += size;
+	gtp_rw_size -= size;
+
+out:
+	up(&gtp_rw_lock);
+	return size;
+}
+
+static unsigned int
+gtp_poll(struct file *file, poll_table *wait)
+{
+	unsigned int	mask = POLLOUT | POLLWRNORM;
+
+#ifdef GTP_DEBUG
+	printk(GTP_DEBUG "gtp_poll\n");
+#endif
+
+	down(&gtp_rw_lock);
+	poll_wait(file, &gtp_rw_wq, wait);
+	if (gtp_read_ack || gtp_rw_size)
+		mask |= POLLIN | POLLRDNORM;
+	up(&gtp_rw_lock);
+
+	return mask;
+}
+
+static int
+gtp_frame2file_r(struct gtp_realloc_s *grs, uint32_t *data_size, char *frame)
+{
+	char	*wbuf;
+
+	wbuf = gtp_realloc(grs, GTP_REG_BIN_SIZE + 1, 0);
+	if (!wbuf)
+		return -1;
+
+	wbuf[0] = 'R';
+#ifdef GTP_FRAME_SIMPLE
+	gtp_regs2bin((struct pt_regs *)(frame + FID_SIZE + sizeof(char *)),
+		     wbuf + 1);
+#endif
+#if defined(GTP_FTRACE_RING_BUFFER) || defined(GTP_RB)
+	gtp_regs2bin((struct pt_regs *)(frame + FID_SIZE), wbuf + 1);
+#endif
+
+	*data_size += GTP_REG_BIN_SIZE + 1;
+
+	return 0;
+}
+
+static int
+gtp_frame2file_m(struct gtp_realloc_s *grs, uint32_t *data_size, char *frame)
+{
+	struct gtp_frame_mem	*mr;
+	uint8_t			*buf;
+	ULONGEST		addr;
+	size_t			remaining;
+
+#ifdef GTP_FRAME_SIMPLE
+	mr = (struct gtp_frame_mem *) (frame + FID_SIZE + sizeof(char *));
+#endif
+#if defined(GTP_FTRACE_RING_BUFFER) || defined(GTP_RB)
+	mr = (struct gtp_frame_mem *) (frame + FID_SIZE);
+#endif
+	buf = frame + GTP_FRAME_MEM_SIZE;
+	addr = mr->addr;
+	remaining = mr->size;
+
+	while (remaining > 0) {
+		uint16_t	blocklen;
+		char		*wbuf;
+		size_t		sp;
+
+		blocklen = remaining > 65535 ? 65535 : remaining;
+
+		sp = 1 + sizeof(addr) + sizeof(blocklen) + blocklen;
+		wbuf = gtp_realloc(grs, sp, 0);
+		if (!wbuf)
+			return -1;
+
+		wbuf[0] = 'M';
+		wbuf += 1;
+
+		memcpy(wbuf, &addr, sizeof(addr));
+		wbuf += sizeof(addr);
+
+		memcpy(wbuf, &blocklen, sizeof(blocklen));
+		wbuf += sizeof(blocklen);
+
+		memcpy(wbuf, buf, blocklen);
+
+		addr += blocklen;
+		remaining -= blocklen;
+		buf += blocklen;
+
+		*data_size += sp;
+	}
+
+	return 0;
+}
+
+static int
+gtp_frame2file_v(struct gtp_realloc_s *grs, uint32_t *data_size, char *frame)
+{
+	struct gtp_frame_var	*vr;
+	size_t			sp = 1 + sizeof(unsigned int)
+				     + sizeof(uint64_t);
+	char			*wbuf;
+
+	wbuf = gtp_realloc(grs, sp, 0);
+	if (!wbuf)
+		return -1;
+
+#ifdef GTP_FRAME_SIMPLE
+	vr = (struct gtp_frame_var *) (frame + FID_SIZE + sizeof(char *));
+#endif
+#if defined(GTP_FTRACE_RING_BUFFER) || defined(GTP_RB)
+	vr = (struct gtp_frame_var *) (frame + FID_SIZE);
+#endif
+
+	wbuf[0] = 'V';
+	wbuf += 1;
+
+	memcpy(wbuf, &vr->num, sizeof(unsigned int));
+	wbuf += sizeof(unsigned int);
+
+	memcpy(wbuf, &vr->val, sizeof(uint64_t));
+	wbuf += sizeof(uint64_t);
+
+	*data_size += sp;
+
+	return 0;
+}
+
+static int
+#ifdef GTP_FRAME_SIMPLE
+gtp_frame2file(struct gtp_realloc_s *grs, char *frame)
+#endif
+#ifdef GTP_FTRACE_RING_BUFFER
+gtp_frame2file(struct gtp_realloc_s *grs, int cpu)
+#endif
+#ifdef GTP_RB
+/* gtp_frame_current_rb will step inside this function.  */
+gtp_frame2file(struct gtp_realloc_s *grs)
+#endif
+{
+	int16_t				*tmp16p;
+	char				*next;
+	char				*wbuf;
+	uint32_t			data_size;
+#ifdef GTP_FTRACE_RING_BUFFER
+	struct ring_buffer_event	*rbe;
+	u64				clock;
+#endif
+#ifdef GTP_RB
+	struct gtp_rb_walk_s		rbws;
+#endif
+
+	/* Head.  */
+	tmp16p = (int16_t *)gtp_realloc(grs, 2, 0);
+	if (!tmp16p)
+		return -1;
+#ifdef GTP_FRAME_SIMPLE
+	*tmp16p = (int16_t)*(ULONGEST *)(frame + FID_SIZE + sizeof(char *));
+#endif
+#ifdef GTP_FTRACE_RING_BUFFER
+	rbe = ring_buffer_read(gtp_frame_iter[cpu], &clock);
+	if (rbe == NULL) {
+		/* It will not happen, just for safe.  */
+		return -1;
+	}
+	next = ring_buffer_event_data(rbe);
+	*tmp16p = (int16_t)*(ULONGEST *)(next + FID_SIZE);
+#endif
+#ifdef GTP_RB
+	*tmp16p = (int16_t)gtp_frame_current_tpe;
+#endif
+	/* This part is for the data_size.  */
+	wbuf = gtp_realloc(grs, 4, 0);
+	if (!wbuf)
+		return -1;
+
+	/* Body.  */
+	data_size = 0;
+
+#ifdef GTP_FTRACE_RING_BUFFER
+	{
+		/* Handle $cpu_id and $clock.  */
+		struct gtp_frame_var	*vr;
+		char			frame[GTP_FRAME_VAR_SIZE];
+
+		vr = (struct gtp_frame_var *) (frame + FID_SIZE);
+		vr->num = GTP_VAR_CLOCK_ID;
+		vr->val = clock;
+		if (gtp_frame2file_v(grs, &data_size, frame))
+			return -1;
+		vr->num = GTP_VAR_CPU_ID;
+		vr->val = cpu;
+		if (gtp_frame2file_v(grs, &data_size, frame))
+			return -1;
+	}
+#endif
+
+#ifdef GTP_RB
+	{
+		/* Handle $cpu_id.  */
+		struct gtp_frame_var	*vr;
+		char			tmp[GTP_FRAME_VAR_SIZE];
+
+		vr = (struct gtp_frame_var *) (tmp + FID_SIZE);
+		vr->num = GTP_VAR_CPU_ID;
+		vr->val = gtp_frame_current_rb->cpu;
+		if (gtp_frame2file_v(grs, &data_size, tmp))
+			return -1;
+	}
+#endif
+
+#ifdef GTP_FRAME_SIMPLE
+	for (next = *(char **)(frame + FID_SIZE); next;
+	     next = *(char **)(next + FID_SIZE)) {
+#elif defined(GTP_FTRACE_RING_BUFFER)
+	while (1) {
+		rbe = ring_buffer_iter_peek(gtp_frame_iter[cpu], NULL);
+		if (rbe == NULL)
+			break;
+		next = ring_buffer_event_data(rbe);
+#endif
+#ifdef GTP_RB
+	rbws.flags = GTP_RB_WALK_PASS_PAGE | GTP_RB_WALK_CHECK_END
+		     | GTP_RB_WALK_CHECK_ID | GTP_RB_WALK_STEP;
+	rbws.end = gtp_frame_current_rb->w;
+	rbws.id = gtp_frame_current_id;
+	rbws.step = 0;
+	next = gtp_rb_walk(&rbws, gtp_frame_current_rb->rp);
+	rbws.step = 1;
+	while (rbws.reason == gtp_rb_walk_step) {
+#endif
+		switch (FID(next)) {
+		case FID_REG:
+			if (gtp_frame2file_r(grs, &data_size, next))
+				return -1;
+			break;
+		case FID_MEM:
+			if (gtp_frame2file_m(grs, &data_size, next))
+				return -1;
+			break;
+		case FID_VAR:
+			if (gtp_frame2file_v(grs, &data_size, next))
+				return -1;
+			break;
+#ifdef GTP_FTRACE_RING_BUFFER
+		case FID_HEAD:
+			goto out;
+			break;
+#endif
+		}
+#ifdef GTP_FTRACE_RING_BUFFER
+		ring_buffer_read(gtp_frame_iter[cpu], NULL);
+#endif
+#ifdef GTP_RB
+		next = gtp_rb_walk(&rbws, next);
+#endif
+	}
+
+#ifdef GTP_FTRACE_RING_BUFFER
+out:
+#endif
+#ifdef GTP_RB
+	gtp_frame_current_rb->rp = next;
+#endif
+	/* Set the data_size.  */
+	memcpy(grs->buf + grs->size - data_size - 4,
+	       &data_size, 4);
+
+	return 0;
+}
+
+static int
+gtp_frame_file_header(struct gtp_realloc_s *grs, int is_end)
+{
+	char			*wbuf;
+	struct gtp_entry	*tpe;
+	struct gtp_var		*var;
+	struct list_head	*cur;
+	int			tmpsize;
+	int			ret = -ENOMEM;
+
+	/* Head. */
+	wbuf = gtp_realloc(grs, 8, 0);
+	strcpy(wbuf, "\x7fTRACE0\n");
+
+	/* BUG: will be a new value.  */
+	wbuf = gtp_realloc(grs, 100, 0);
+	if (!wbuf)
+		goto out;
+	snprintf(wbuf, 100, "R %x\n", GTP_REG_BIN_SIZE);
+	gtp_realloc_sub_size(grs, 100 - strlen(wbuf));
+
+	if (gtp_realloc_str(grs, "status 0;", 0))
+		goto out;
+
+	wbuf = gtp_realloc(grs, 300, 0);
+	if (!wbuf)
+		goto out;
+	for (tpe = gtp_list; tpe; tpe = tpe->next) {
+		if (tpe->reason != gtp_stop_normal)
+			break;
+	}
+	tmpsize = gtp_get_status(tpe, wbuf, 300);
+	gtp_realloc_sub_size(grs, 300 - tmpsize);
+
+	if (gtp_realloc_str(grs, "\n", 0))
+		goto out;
+
+	/* Tval. */
+	list_for_each(cur, &gtp_var_list) {
+		var = list_entry(cur, struct gtp_var, node);
+		wbuf = gtp_realloc(grs, 200, 0);
+		if (!wbuf)
+			goto out;
+		snprintf(wbuf, 200, "tsv %x:%llx:%s\n", var->num,
+			 (unsigned long long)var->initial_val, var->src);
+		gtp_realloc_sub_size(grs, 200 - strlen(wbuf));
+	}
+
+	/* Tracepoint.  */
+	for (tpe = gtp_list; tpe; tpe = tpe->next) {
+		struct gtpsrc	*src;
+
+		/* Tpe.  */
+		if (gtp_realloc_str(grs, "tp ", 0))
+			goto out;
+		wbuf = gtp_realloc(grs, GTP_REPORT_TRACEPOINT_MAX, 0);
+		if (!wbuf)
+			goto out;
+		gtp_report_tracepoint(tpe, wbuf, GTP_REPORT_TRACEPOINT_MAX);
+		gtp_realloc_sub_size(grs,
+				     GTP_REPORT_TRACEPOINT_MAX - strlen(wbuf));
+		if (gtp_realloc_str(grs, "\n", 0))
+			goto out;
+		/* Action.  */
+		for (src = tpe->action_cmd; src; src = src->next) {
+			if (gtp_realloc_str(grs, "tp ", 0))
+				goto out;
+			tmpsize = gtp_report_action_max(tpe, src);
+			wbuf = gtp_realloc(grs, tmpsize, 0);
+			if (!wbuf)
+				goto out;
+			gtp_report_action(tpe, src, wbuf, tmpsize);
+			gtp_realloc_sub_size(grs, tmpsize - strlen(wbuf));
+			if (gtp_realloc_str(grs, "\n", 0))
+				goto out;
+		}
+		/* Src.  */
+		for (src = tpe->src; src; src = src->next) {
+			if (gtp_realloc_str(grs, "tp ", 0))
+				goto out;
+			tmpsize = gtp_report_src_max(tpe, src);
+			wbuf = gtp_realloc(grs, tmpsize, 0);
+			if (!wbuf)
+				goto out;
+			gtp_report_src(tpe, src, wbuf, tmpsize);
+			gtp_realloc_sub_size(grs, tmpsize - strlen(wbuf));
+			if (gtp_realloc_str(grs, "\n", 0))
+				goto out;
+		}
+	}
+
+	if (gtp_realloc_str(grs, "\n", is_end))
+		goto out;
+
+	ret = 0;
+out:
+	return ret;
+}
+
+static ssize_t
+gtpframe_read(struct file *file, char __user *buf, size_t size,
+	      loff_t *ppos)
+{
+	ssize_t	ret = -ENOMEM;
+#if defined(GTP_FTRACE_RING_BUFFER) || defined(GTP_RB)
+	/* -2 means don't need set the frame back old number.  */
+	int	old_num = -2;
+#endif
+
+recheck:
+	down(&gtp_rw_lock);
+	if (gtp_start) {
+		up(&gtp_rw_lock);
+		if (wait_event_interruptible(gtpframe_wq,
+					     !gtp_start) == -ERESTARTSYS)
+			return -EINTR;
+#ifdef GTP_DEBUG
+		printk(GTP_DEBUG "gtpframe_read: goto recheck\n");
+#endif
+		goto recheck;
+	}
+
+	/* Set gtp_frame_file if need.  */
+	if (!gtp_frame_file) {
+		char			*wbuf;
+#ifdef GTP_FRAME_SIMPLE
+		char			*frame;
+#endif
+		struct gtp_realloc_s	gr;
+		int			lret;
+
+#ifdef GTP_FRAME_SIMPLE
+		if (gtp_frame_is_circular)
+			gr.real_size = GTP_FRAME_SIZE;
+		else
+			gr.real_size = gtp_frame_w_start - gtp_frame;
+#endif
+#ifdef GTP_FTRACE_RING_BUFFER
+		gr.real_size =
+			ring_buffer_entries(gtp_frame) * GTP_FRAME_HEAD_SIZE;
+#endif
+#ifdef GTP_RB
+		if (atomic_read(&gtp_frame_create) != 0) {
+			int	cpu;
+
+			for_each_online_cpu(cpu) {
+				struct gtp_rb_s	*rb
+				= (struct gtp_rb_s *)per_cpu_ptr(gtp_rb, cpu);
+				void		*tmp;
+				unsigned long	flags;
+
+				GTP_RB_LOCK_IRQ(rb, flags);
+				gr.real_size = GTP_RB_END(rb->r) - rb->r;
+				for (tmp = GTP_RB_NEXT(rb->r);
+				     GTP_RB_HEAD(tmp) != GTP_RB_HEAD(rb->w);
+				     tmp = GTP_RB_NEXT(tmp))
+					gr.real_size += GTP_RB_DATA_MAX;
+				gr.real_size += rb->w - GTP_RB_DATA(rb->w);
+				GTP_RB_UNLOCK_IRQ(rb, flags);
+			}
+		}
+#endif
+		gr.real_size += 200;
+		lret = gtp_realloc_alloc(&gr, gr.real_size);
+		if (lret != 0) {
+			ret = lret;
+			goto out;
+		}
+
+		lret = gtp_frame_file_header(&gr, 0);
+		if (lret != 0) {
+			ret = lret;
+			goto out;
+		}
+
+		/* Frame.  */
+		if (atomic_read(&gtp_frame_create) == 0)
+			goto end;
+#ifdef GTP_FRAME_SIMPLE
+		frame = gtp_frame_r_start;
+		do {
+			if (frame == gtp_frame_end)
+				frame = gtp_frame;
+
+			if (FID(frame) == FID_HEAD) {
+				if (gtp_frame2file(&gr, frame))
+					goto out;
+			}
+
+			frame = gtp_frame_next(frame);
+			if (!frame)
+				break;
+		} while (frame != gtp_frame_w_start);
+#endif
+#ifdef GTP_FTRACE_RING_BUFFER
+		old_num = gtp_frame_current_num;
+		gtp_frame_iter_reset();
+		while (1) {
+			int	cpu;
+
+			cpu = gtp_frame_iter_peek_head();
+			if (cpu < 0)
+				break;
+
+			if (gtp_frame2file(&gr, cpu))
+				goto out;
+		}
+#endif
+#ifdef GTP_RB
+		old_num = gtp_frame_current_num;
+		gtp_rb_read_reset();
+		while (1) {
+			if (gtp_rb_read() != 0)
+				break;
+			gtp_frame2file(&gr);
+		}
+#endif
+
+end:
+		/* End.  */
+		wbuf = gtp_realloc(&gr, 2, 1);
+		if (!wbuf)
+			goto out;
+		wbuf[0] = '\0';
+		wbuf[1] = '\0';
+
+		gtp_frame_file = gr.buf;
+		gtp_frame_file_size = gr.size;
+	}
+
+	/* Set buf.  */
+	ret = size;
+	if (*ppos + ret > gtp_frame_file_size) {
+		ret = gtp_frame_file_size - *ppos;
+		if (ret <= 0) {
+			ret = 0;
+			goto out;
+		}
+	}
+	if (copy_to_user(buf, gtp_frame_file + *ppos, ret)) {
+		ret = -EFAULT;
+		goto out;
+	}
+	*ppos += ret;
+
+out:
+#ifdef GTP_FTRACE_RING_BUFFER
+	if (old_num == -1)
+		gtp_frame_iter_reset();
+	else if (old_num >= 0) {
+		gtp_frame_head_find_num(old_num);
+		ring_buffer_read(gtp_frame_iter[gtp_frame_current_cpu], NULL);
+	}
+#endif
+#ifdef GTP_RB
+	if (old_num == -1)
+		gtp_rb_reset();
+	else if (old_num >= 0)
+		gtp_frame_head_find_num(old_num);
+#endif
+	up(&gtp_rw_lock);
+	return ret;
+}
+
+static int
+gtpframe_open(struct inode *inode, struct file *file)
+{
+recheck:
+	down(&gtp_rw_lock);
+#ifdef GTP_RB
+	if (GTP_RB_PAGE_IS_EMPTY) {
+#elif defined(GTP_FRAME_SIMPLE) || defined(GTP_FTRACE_RING_BUFFER)
+	if (!gtp_frame) {
+#endif
+		up(&gtp_rw_lock);
+#ifdef GTP_RB
+		if (wait_event_interruptible(gtpframe_wq,
+					     !GTP_RB_PAGE_IS_EMPTY)
+		    == -ERESTARTSYS)
+#elif defined(GTP_FRAME_SIMPLE) || defined(GTP_FTRACE_RING_BUFFER)
+		if (wait_event_interruptible(gtpframe_wq,
+					     gtp_frame) == -ERESTARTSYS)
+#endif
+			return -EINTR;
+#ifdef GTP_DEBUG
+		printk(GTP_DEBUG "gtpframe_open: goto recheck\n");
+#endif
+		goto recheck;
+	}
+
+	if (gtp_gtpframe_pipe_pid >= 0) {
+		up(&gtp_rw_lock);
+		return -EBUSY;
+	}
+
+	if (gtp_gtpframe_pid >= 0) {
+		if (get_current()->pid != gtp_gtpframe_pid) {
+			up(&gtp_rw_lock);
+			return -EBUSY;
+		}
+	}
+
+	gtp_frame_count_get();
+
+	gtp_gtpframe_pid_count++;
+	if (gtp_gtpframe_pid < 0)
+		gtp_gtpframe_pid = get_current()->pid;
+
+	up(&gtp_rw_lock);
+	return 0;
+}
+
+static int
+gtpframe_release(struct inode *inode, struct file *file)
+{
+	down(&gtp_rw_lock);
+	gtp_frame_count_put();
+
+	gtp_gtpframe_pid_count--;
+	if (gtp_gtpframe_pid_count == 0)
+		gtp_gtpframe_pid = -1;
+	up(&gtp_rw_lock);
+
+	return 0;
+}
+
+#if defined(GTP_FTRACE_RING_BUFFER) || defined(GTP_RB)
+struct gtpframe_pipe_s {
+	loff_t			begin;
+	struct gtp_realloc_s	*grs;
+	int			llseek_move;
+#ifdef GTP_RB
+	void			**page;
+	u64			*page_id;
+#endif
+};
+
+static int
+gtpframe_pipe_open(struct inode *inode, struct file *file)
+{
+	int			ret = -ENOMEM;
+	struct gtpframe_pipe_s	*gps = NULL;
+
+	down(&gtp_rw_lock);
+
+	if (gtp_frame_current_num >= 0 || gtp_gtpframe_pipe_pid >= 0) {
+		ret = -EBUSY;
+		goto out;
+	}
+	gtp_gtpframe_pipe_pid = get_current()->pid;
+
+recheck:
+#ifdef GTP_RB
+	if (GTP_RB_PAGE_IS_EMPTY) {
+#elif defined(GTP_FTRACE_RING_BUFFER)
+	if (!gtp_frame) {
+#endif
+		up(&gtp_rw_lock);
+		atomic_inc(&gtpframe_pipe_wq_v);
+#ifdef GTP_RB
+		if (wait_event_interruptible(gtpframe_pipe_wq,
+			!GTP_RB_PAGE_IS_EMPTY) == -ERESTARTSYS) {
+#elif defined(GTP_FTRACE_RING_BUFFER)
+		if (wait_event_interruptible(gtpframe_pipe_wq,
+					     gtp_frame) == -ERESTARTSYS) {
+#endif
+			ret = -EINTR;
+			goto out;
+		}
+#ifdef GTP_DEBUG
+		printk(GTP_DEBUG "gtpframe_pipe_open: goto recheck\n");
+#endif
+		down(&gtp_rw_lock);
+		goto recheck;
+	}
+
+	gps = kzalloc(sizeof(struct gtpframe_pipe_s), GFP_KERNEL);
+	if (gps == NULL)
+		goto out;
+	gps->grs = kzalloc(sizeof(struct gtp_realloc_s), GFP_KERNEL);
+	if (gps->grs == NULL)
+		goto out;
+#ifdef GTP_RB
+	gps->page = kcalloc(gtp_cpu_number, sizeof(void *), GFP_KERNEL);
+	if (gps->page == NULL)
+		goto out;
+	gps->page_id = kcalloc(gtp_cpu_number, sizeof(u64), GFP_KERNEL);
+	if (gps->page_id == NULL)
+		goto out;
+#endif
+
+	file->private_data = gps;
+
+	gtp_frame_count_get();
+
+	ret = 0;
+out:
+	if (ret) {
+		gtp_gtpframe_pipe_pid = -1;
+		if (gps) {
+			kfree(gps->grs);
+#ifdef GTP_RB
+			kfree(gps->page);
+			kfree(gps->page_id);
+#endif
+			kfree(gps);
+		}
+	}
+	up(&gtp_rw_lock);
+	return ret;
+}
+
+static int
+gtpframe_pipe_release(struct inode *inode, struct file *file)
+{
+	struct gtpframe_pipe_s	*gps = file->private_data;
+
+	down(&gtp_rw_lock);
+	gtp_frame_count_put();
+
+	gtp_gtpframe_pipe_pid = -1;
+
+	up(&gtp_rw_lock);
+
+	if (gps) {
+#ifdef GTP_RB
+		int	cpu;
+
+		for_each_online_cpu(cpu) {
+			struct gtp_rb_s	*rb
+				= (struct gtp_rb_s *)per_cpu_ptr(gtp_rb, cpu);
+			if (gps->page[cpu])
+				gtp_rb_put_page(rb, gps->page[cpu], 0);
+		}
+
+		kfree(gps->page);
+		kfree(gps->page_id);
+#endif
+		if (gps->grs) {
+			if (gps->grs->buf)
+				vfree(gps->grs->buf);
+			kfree(gps->grs);
+		}
+		kfree(gps);
+	}
+
+	return 0;
+}
+
+#ifdef GTP_RB
+static int
+gtpframe_pipe_peek(struct gtpframe_pipe_s *gps)
+{
+	int			cpu;
+	u64			min_id = ULLONG_MAX;
+	int			ret = -1;
+	struct gtp_rb_walk_s	rbws;
+
+	rbws.flags = 0;
+
+	for_each_online_cpu(cpu) {
+		struct gtp_rb_s	*rb
+			= (struct gtp_rb_s *)per_cpu_ptr(gtp_rb, cpu);
+
+		if (gps->page_id[cpu] == 0) {
+			/* Get new page.  */
+			if (gps->page[cpu] == NULL) {
+get_new_page:
+				gps->page[cpu] = gtp_rb_get_page(rb);
+				if (gps->page[cpu] == NULL)
+					continue;
+			}
+			/* Get new entry.  */
+			gps->page[cpu] = gtp_rb_walk(&rbws, gps->page[cpu]);
+			if (rbws.reason != gtp_rb_walk_new_entry) {
+				/* Put the page back and get a new page.  */
+				gtp_rb_put_page(rb, gps->page[cpu], 1);
+				goto get_new_page;
+			}
+			/* Get id.  */
+			gps->page_id[cpu] = *(u64 *)(gps->page[cpu] + FID_SIZE);
+		}
+
+		if (gps->page_id[cpu] < min_id) {
+			min_id = gps->page_id[cpu];
+			ret = cpu;
+		}
+	}
+
+	return ret;
+}
+#else
+static int
+gtpframe_pipe_peek(void)
+{
+	u64				min = 0;
+	u64				ts;
+	int				cpu;
+	struct ring_buffer_event	*rbe;
+	char				*next;
+	int				ret = -1;
+
+	for_each_online_cpu(cpu) {
+		while (1) {
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,35)) \
+    && !defined(GTP_SELF_RING_BUFFER)
+			rbe = ring_buffer_peek(gtp_frame, cpu, &ts);
+#else
+			rbe = ring_buffer_peek(gtp_frame, cpu, &ts, NULL);
+#endif
+			if (rbe == NULL)
+				break;
+			next = ring_buffer_event_data(rbe);
+			if (FID(next) == FID_HEAD)
+				break;
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,35)) \
+    && !defined(GTP_SELF_RING_BUFFER)
+			ring_buffer_consume(gtp_frame, cpu, &ts);
+#else
+			ring_buffer_consume(gtp_frame, cpu, &ts, NULL);
+#endif
+		}
+
+		if (rbe) {
+			if ((min && ts < min) || !min) {
+				min = ts;
+				ret = cpu;
+			}
+		}
+	}
+
+	return ret;
+}
+#endif
+
+static int
+#ifdef GTP_RB
+gtpframe_pipe_get_entry(struct gtpframe_pipe_s *gps)
+#endif
+#ifdef GTP_FTRACE_RING_BUFFER
+gtpframe_pipe_get_entry(struct gtp_realloc_s *grs)
+#endif
+{
+	int				cpu;
+	int16_t				*tmp16p;
+	uint32_t			data_size;
+#ifdef GTP_FTRACE_RING_BUFFER
+	char				*next;
+	struct ring_buffer_event	*rbe;
+	u64				ts;
+#endif
+
+#ifdef GTP_RB
+	struct gtp_rb_walk_s		rbws;
+	struct gtp_realloc_s		*grs = gps->grs;
+#endif
+	/* Because this function only be called when gtp_realloc_is_empty,
+	   so grs don't need reset. */
+
+#ifdef GTP_RB
+#define GTP_PIPE_PEEK	(cpu = gtpframe_pipe_peek(gps))
+#endif
+#ifdef GTP_FTRACE_RING_BUFFER
+recheck:
+#define GTP_PIPE_PEEK	(cpu = gtpframe_pipe_peek())
+#endif
+	GTP_PIPE_PEEK;
+	if (cpu < 0) {
+		/* Didn't get the buffer that have event.
+		   Wait and recheck.*/
+		atomic_inc(&gtpframe_pipe_wq_v);
+		if (wait_event_interruptible(gtpframe_pipe_wq,
+					     GTP_PIPE_PEEK >= 0)
+			== -ERESTARTSYS)
+			return -EINTR;
+	}
+#undef GTP_PIPE_PEEK
+
+	/* Head.  */
+#ifdef GTP_FTRACE_RING_BUFFER
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,35)) \
+    && !defined(GTP_SELF_RING_BUFFER)
+	rbe = ring_buffer_consume(gtp_frame, cpu, &ts);
+#else
+	rbe = ring_buffer_consume(gtp_frame, cpu, &ts, NULL);
+#endif
+	if (rbe == NULL)
+		goto recheck;
+	next = ring_buffer_event_data(rbe);
+	if (FID(next) != FID_HEAD)
+		goto recheck;
+#endif
+	tmp16p = (int16_t *)gtp_realloc(grs, 2, 0);
+	if (!tmp16p)
+		return -ENOMEM;
+#ifdef GTP_RB
+	*tmp16p = (int16_t)*(ULONGEST *)(gps->page[cpu] + FID_SIZE
+					 + sizeof(u64));
+	gps->page[cpu] += FRAME_ALIGN(GTP_FRAME_HEAD_SIZE);
+#endif
+#ifdef GTP_FTRACE_RING_BUFFER
+	*tmp16p = (int16_t)*(ULONGEST *)(next + FID_SIZE);
+#endif
+	/* This part is for the data_size.  */
+	if (gtp_realloc(grs, 4, 0) == NULL)
+		return -ENOMEM;
+	data_size = 0;
+
+#ifdef GTP_RB
+	{
+		/* Handle $cpu_id.  */
+		struct gtp_frame_var	*vr;
+		char			frame[GTP_FRAME_VAR_SIZE];
+
+		vr = (struct gtp_frame_var *) (frame + FID_SIZE);
+		vr->num = GTP_VAR_CPU_ID;
+		vr->val = cpu;
+		if (gtp_frame2file_v(grs, &data_size, frame))
+			return -ENOMEM;
+	}
+#endif
+#ifdef GTP_FTRACE_RING_BUFFER
+	{
+		/* Handle $cpu_id and $clock.  */
+		struct gtp_frame_var	*vr;
+		char			frame[GTP_FRAME_VAR_SIZE];
+
+		vr = (struct gtp_frame_var *) (frame + FID_SIZE);
+		vr->num = GTP_VAR_CLOCK_ID;
+		vr->val = ts;
+		if (gtp_frame2file_v(grs, &data_size, frame))
+			return -ENOMEM;
+		vr->num = GTP_VAR_CPU_ID;
+		vr->val = cpu;
+		if (gtp_frame2file_v(grs, &data_size, frame))
+			return -ENOMEM;
+	}
+#endif
+
+#ifdef GTP_RB
+	rbws.flags = GTP_RB_WALK_CHECK_ID | GTP_RB_WALK_STEP;
+	rbws.id = gps->page_id[cpu];
+re_walk:
+	rbws.step = 0;
+	gps->page[cpu] = gtp_rb_walk(&rbws, gps->page[cpu]);
+	rbws.step = 1;
+	while (rbws.reason == gtp_rb_walk_step) {
+		switch (FID(gps->page[cpu])) {
+		case FID_REG:
+			if (gtp_frame2file_r(grs, &data_size, gps->page[cpu]))
+				return -ENOMEM;
+			break;
+
+		case FID_MEM:
+			if (gtp_frame2file_m(grs, &data_size, gps->page[cpu]))
+				return -ENOMEM;
+			break;
+
+		case FID_VAR:
+			if (gtp_frame2file_v(grs, &data_size, gps->page[cpu]))
+				return -ENOMEM;
+			break;
+		}
+		gps->page[cpu] = gtp_rb_walk(&rbws, gps->page[cpu]);
+	}
+	if (rbws.reason == gtp_rb_walk_end_page
+	    || rbws.reason == gtp_rb_walk_error) {
+		/* Put this page back.  */
+		gtp_rb_put_page((struct gtp_rb_s *)per_cpu_ptr(gtp_rb, cpu),
+				gps->page[cpu], 1);
+		gps->page[cpu] = gtp_rb_get_page((struct gtp_rb_s *)per_cpu_ptr
+							(gtp_rb, cpu));
+		if (gps->page[cpu])
+			goto re_walk;
+	}
+	gps->page_id[cpu] = 0;
+#endif
+#ifdef GTP_FTRACE_RING_BUFFER
+	while (1) {
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,35)) \
+    && !defined(GTP_SELF_RING_BUFFER)
+#define GTP_PIPE_CONSUME (rbe = ring_buffer_consume(gtp_frame, cpu, NULL))
+#else
+#define GTP_PIPE_CONSUME (rbe = ring_buffer_consume(gtp_frame, cpu, NULL, NULL))
+#endif
+		GTP_PIPE_CONSUME;
+		if (rbe == NULL) {
+			if (!gtp_start)
+				break;
+
+			atomic_inc(&gtpframe_pipe_wq_v);
+			if (wait_event_interruptible(gtpframe_pipe_wq,
+							GTP_PIPE_CONSUME
+							!= NULL)
+					== -ERESTARTSYS)
+				return -EINTR;
+			continue;
+		}
+#undef GTP_PIPE_CONSUME
+		next = ring_buffer_event_data(rbe);
+		switch (FID(next)) {
+		case FID_REG:
+			if (gtp_frame2file_r(grs, &data_size, next))
+				return -ENOMEM;
+			break;
+
+		case FID_MEM:
+			if (gtp_frame2file_m(grs, &data_size, next))
+				return -ENOMEM;
+			break;
+
+		case FID_VAR:
+			if (gtp_frame2file_v(grs, &data_size, next))
+				return -ENOMEM;
+			break;
+
+		case FID_HEAD:
+		case FID_END:
+			goto while_out;
+			break;
+		}
+	}
+while_out:
+#endif
+	/* Set the data_size.  */
+	memcpy(grs->buf + grs->size - data_size - 4, &data_size, 4);
+
+	return 0;
+}
+
+static ssize_t
+gtpframe_pipe_read(struct file *file, char __user *buf, size_t size,
+		   loff_t *ppos)
+{
+	ssize_t			ret;
+	struct gtpframe_pipe_s	*gps = file->private_data;
+	loff_t			entry_offset;
+
+#ifdef GTP_DEBUG
+	printk(GTP_DEBUG "gtpframe_pipe_read: size=%u *ppos=%lld\n",
+	       size, *ppos);
+#endif
+
+	if (!gtp_realloc_is_alloced(gps->grs)) {
+		ret = gtp_realloc_alloc(gps->grs, 200);
+		if (ret)
+			goto out;
+	} else if (*ppos < gps->begin
+		   || *ppos >= (gps->begin + gps->grs->size)) {
+		gtp_realloc_reset(gps->grs);
+
+		if (gps->llseek_move) {
+			/* clear user will return NULL.
+			   Then GDB tfind got a fail.  */
+			if (size > 2)
+				size = 2;
+			if (clear_user(buf, size)) {
+				ret = -EFAULT;
+				goto out;
+			}
+			gps->begin = 0;
+			gps->llseek_move = 0;
+			ret = size;
+			goto out;
+		}
+	}
+
+	if (gtp_realloc_is_empty(gps->grs)) {
+		if (*ppos == 0) {
+			ret = gtp_frame_file_header(gps->grs, 1);
+			if (ret)
+				goto out;
+#ifdef GTP_DEBUG
+			printk(GTP_DEBUG "gtpframe_pipe_read: Get header.\n");
+#endif
+		} else {
+#ifdef GTP_RB
+			ret = gtpframe_pipe_get_entry(gps);
+#endif
+#ifdef GTP_FTRACE_RING_BUFFER
+			ret = gtpframe_pipe_get_entry(gps->grs);
+#endif
+			if (ret)
+				goto out;
+#ifdef GTP_DEBUG
+			printk(GTP_DEBUG "gtpframe_pipe_read: Get entry.\n");
+#endif
+		}
+		gps->begin = *ppos;
+	}
+
+#ifdef GTP_DEBUG
+	printk(GTP_DEBUG "gtpframe_pipe_read: gps->begin=%lld "
+			 "gps->grs->size=%u\n",
+	       gps->begin, gps->grs->size);
+#endif
+
+	entry_offset = *ppos - gps->begin;
+	ret = size;
+	if (entry_offset + size > gps->grs->size)
+		ret = gps->grs->size - entry_offset;
+	if (copy_to_user(buf, gps->grs->buf + entry_offset, ret)) {
+		ret = -EFAULT;
+		goto out;
+	}
+	*ppos += ret;
+
+out:
+	return ret;
+}
+
+static loff_t
+gtpframe_pipe_llseek(struct file *file, loff_t offset, int origin)
+{
+	struct gtpframe_pipe_s	*gps = file->private_data;
+	loff_t			ret = default_llseek(file, offset, origin);
+
+	if (ret < 0)
+		return ret;
+
+	/* True means that GDB tfind to next frame entry.  */
+	if (ret >= gps->begin + gps->grs->size && gps->begin)
+		gps->llseek_move = 1;
+
+	return ret;
+}
+#endif
+
+static const struct file_operations gtp_operations = {
+	.owner		= THIS_MODULE,
+	.open		= gtp_open,
+	.release	= gtp_release,
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,35))
+	.ioctl		= gtp_ioctl,
+#else
+	.unlocked_ioctl	= gtp_ioctl,
+	.compat_ioctl	= gtp_ioctl,
+#endif
+	.read		= gtp_read,
+	.write		= gtp_write,
+	.poll		= gtp_poll,
+};
+
+static const struct file_operations gtpframe_operations = {
+	.owner		= THIS_MODULE,
+	.open		= gtpframe_open,
+	.release	= gtpframe_release,
+	.read		= gtpframe_read,
+	.llseek		= default_llseek,
+};
+
+#if defined(GTP_FTRACE_RING_BUFFER) || defined(GTP_RB)
+static const struct file_operations gtpframe_pipe_operations = {
+	.owner		= THIS_MODULE,
+	.open		= gtpframe_pipe_open,
+	.release	= gtpframe_pipe_release,
+	.read		= gtpframe_pipe_read,
+	.llseek		= gtpframe_pipe_llseek,
+};
+#endif
+
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,30))
+static int
+gtp_modules_load_del_notify(struct notifier_block *self, unsigned long val,
+			    void *data)
+{
+	if (val == MODULE_STATE_COMING)
+		return 0;
+
+	down(&gtp_rw_lock);
+	gtp_modules_traceframe_info_need_get = 1;
+	up(&gtp_rw_lock);
+
+	return 0;
+}
+
+static struct notifier_block	gtp_modules_load_del_nb = {
+	.notifier_call = gtp_modules_load_del_notify,
+};
+#endif
+
+#ifndef USE_PROC
+struct dentry	*gtp_dir;
+struct dentry	*gtpframe_dir;
+#if defined(GTP_FTRACE_RING_BUFFER) || defined(GTP_RB)
+struct dentry	*gtpframe_pipe_dir;
+#endif
+#endif
+
+struct gtp_plugin_mod
+{
+	struct list_head	node;
+	struct module 		*mod;
+};
+
+static LIST_HEAD(gtp_plugin_mod_list);
+
+static void
+gtp_plugin_mod_get(void)
+{
+	struct gtp_plugin_mod	*plugin;
+	struct list_head	*cur;
+
+	list_for_each(cur, &gtp_plugin_mod_list) {
+		plugin = list_entry(cur, struct gtp_plugin_mod, node);
+		if (!try_module_get(plugin->mod))
+			printk(KERN_WARNING "Try to get KGTP plugin module fail.\n");
+	}
+}
+
+static void
+gtp_plugin_mod_put(void)
+{
+	struct gtp_plugin_mod	*plugin;
+	struct list_head	*cur;
+
+	list_for_each(cur, &gtp_plugin_mod_list) {
+		plugin = list_entry(cur, struct gtp_plugin_mod, node);
+		module_put(plugin->mod);
+	}
+}
+
+int
+gtp_plugin_mod_register(struct module *mod)
+{
+	int 			ret = -EBUSY;
+	struct gtp_plugin_mod	*plugin;
+
+	down(&gtp_rw_lock);
+
+	if (gtp_frame_count || gtp_disconnected_tracing)
+		goto out;
+
+	plugin = (struct gtp_plugin_mod *)kmalloc(sizeof(*plugin),
+						  GFP_KERNEL);
+	if (plugin == NULL) {
+		ret = -ENOMEM;
+		goto out;
+	}
+	plugin->mod = mod;
+
+	list_add(&plugin->node, &gtp_plugin_mod_list);
+
+	ret = 0;
+out:
+	up(&gtp_rw_lock);
+	return ret;
+}
+EXPORT_SYMBOL(gtp_plugin_mod_register);
+
+int
+gtp_plugin_mod_unregister(struct module *mod)
+{
+	int 			ret = -EBUSY;
+	struct gtp_plugin_mod	*plugin;
+	struct list_head	*cur, *tmp;
+
+	down(&gtp_rw_lock);
+
+	if (gtp_frame_count || gtp_disconnected_tracing)
+		goto out;
+
+	list_for_each_safe(cur, tmp, &gtp_plugin_mod_list) {
+		plugin = list_entry(cur, struct gtp_plugin_mod, node);
+		if (plugin->mod == mod) {
+			list_del(&plugin->node);
+			kfree(plugin);
+			ret = 0;
+			goto out;
+		}
+	}
+	ret = -EINVAL;
+
+out:
+	up(&gtp_rw_lock);
+	return ret;
+}
+EXPORT_SYMBOL(gtp_plugin_mod_unregister);
+
+struct gtp_var *
+gtp_plugin_var_add(char *name, int64_t val, struct gtp_var_hooks *hooks)
+{
+	struct gtp_var	*var = ERR_PTR(-EBUSY);
+
+	down(&gtp_rw_lock);
+
+	if (gtp_frame_count || gtp_disconnected_tracing)
+		goto out;
+
+	var = gtp_var_special_add(0, 1, val, name, hooks);
+
+out:
+	up(&gtp_rw_lock);
+	return var;
+}
+EXPORT_SYMBOL(gtp_plugin_var_add);
+
+int
+gtp_plugin_var_del(struct gtp_var *var)
+{
+	int			ret = -EBUSY;
+	struct list_head	*cur, *tmp;
+
+	down(&gtp_rw_lock);
+
+	if (gtp_frame_count || gtp_disconnected_tracing)
+		goto out;
+
+	list_for_each_safe(cur, tmp, &gtp_var_list) {
+		if (var == list_entry(cur, struct gtp_var, node)) {
+			list_del(&var->node);
+			gtp_var_num--;
+			kfree(var->src);
+			kfree(var);
+			ret = 0;
+			goto out;
+		}
+	}
+
+	ret = -EINVAL;
+
+out:
+	up(&gtp_rw_lock);
+	return ret;
+}
+EXPORT_SYMBOL(gtp_plugin_var_del);
+
+static void
+gtp_release_all_mod(void)
+{
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,30))
+	unregister_module_notifier(&gtp_modules_load_del_nb);
+#endif
+
+#ifdef USE_PROC
+	remove_proc_entry("gtp", NULL);
+	remove_proc_entry("gtpframe", NULL);
+#if defined(GTP_FTRACE_RING_BUFFER) || defined(GTP_RB)
+	remove_proc_entry("gtpframe_pipe", NULL);
+#endif
+#else
+	if (gtp_dir)
+		debugfs_remove(gtp_dir);
+	if (gtpframe_dir)
+		debugfs_remove(gtpframe_dir);
+#if defined(GTP_FTRACE_RING_BUFFER) || defined(GTP_RB)
+	if (gtpframe_pipe_dir)
+		debugfs_remove(gtpframe_pipe_dir);
+#endif
+#endif
+
+	gtp_gdbrsp_qtstop();
+	gtp_gdbrsp_qtinit();
+#ifdef GTP_RB
+	if (!GTP_RB_PAGE_IS_EMPTY)
+		gtp_rb_page_free();
+#endif
+#if defined(GTP_FRAME_SIMPLE) || defined(GTP_FTRACE_RING_BUFFER)
+	if (gtp_frame) {
+#ifdef GTP_FRAME_SIMPLE
+		vfree(gtp_frame);
+#endif
+#ifdef GTP_FTRACE_RING_BUFFER
+		ring_buffer_free(gtp_frame);
+#endif
+		gtp_frame = NULL;
+	}
+#endif
+
+	if (gtp_wq)
+		destroy_workqueue(gtp_wq);
+
+#ifdef GTP_RB
+	gtp_rb_release();
+#endif
+	gtp_var_release(1);
+
+#ifdef GTP_RB
+	if (gtp_traceframe_info)
+		vfree(gtp_traceframe_info);
+#endif
+
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,30))
+	if (gtp_modules_traceframe_info)
+		vfree(gtp_modules_traceframe_info);
+#endif
+}
+
+static int __init gtp_init(void)
+{
+	int		ret;
+
+#ifdef CONFIG_X86
+	gtp_have_watch_tracepoint = 0;
+	gtp_have_step = 0;
+#endif
+	gtp_gtp_pid = -1;
+	gtp_gtp_pid_count = 0;
+	gtp_gtpframe_pid = -1;
+	gtp_gtpframe_pid_count = 0;
+#if defined(GTP_FTRACE_RING_BUFFER) || defined(GTP_RB)
+	gtp_gtpframe_pipe_pid = -1;
+#endif
+	gtp_list = NULL;
+	gtp_read_ack = 0;
+	gtp_rw_bufp = NULL;
+	gtp_rw_size = 0;
+	gtp_start = 0;
+	gtp_disconnected_tracing = 0;
+	gtp_circular = 0;
+#if defined(GTP_FTRACE_RING_BUFFER)			\
+    && (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,39))	\
+    && !defined(GTP_SELF_RING_BUFFER)
+	gtp_circular_is_changed = 0;
+#endif
+	gtp_var_array = NULL;
+	current_gtp_var = NULL;
+	gtp_var_num = 0;
+#if defined(GTP_FRAME_SIMPLE) || defined(GTP_FTRACE_RING_BUFFER)
+	gtp_frame = NULL;
+#endif
+	gtp_frame_current_num = -1;
+	gtp_frame_current_tpe = 0;
+#ifdef GTP_FRAME_SIMPLE
+	gtp_frame_r_start = NULL;
+	gtp_frame_w_start = NULL;
+	gtp_frame_end = NULL;
+	gtp_frame_current = NULL;
+	gtp_frame_is_circular = 0;
+#endif
+#ifdef GTP_FTRACE_RING_BUFFER
+	{
+		int	cpu;
+
+		for_each_online_cpu(cpu)
+			gtp_frame_iter[cpu] = NULL;
+	}
+	gtp_frame_current_cpu = 0;
+#endif
+#if defined(GTP_FTRACE_RING_BUFFER) || defined(GTP_RB)
+	atomic_set(&gtpframe_pipe_wq_v, 0);
+#endif
+	atomic_set(&gtp_frame_create, 0);
+	gtp_rw_count = 0;
+	gtp_frame_count = 0;
+	current_gtp = NULL;
+	current_gtp_action_cmd = NULL;
+	current_gtp_src = NULL;
+	gtpro_list = NULL;
+	gtp_frame_file = NULL;
+	gtp_frame_file_size = 0;
+#ifndef USE_PROC
+	gtp_dir = NULL;
+	gtpframe_dir = NULL;
+#if defined(GTP_FTRACE_RING_BUFFER) || defined(GTP_RB)
+	gtpframe_pipe_dir = NULL;
+#endif
+#endif
+	{
+		int	cpu;
+
+		gtp_cpu_number = 0;
+		for_each_online_cpu(cpu) {
+			if (cpu > gtp_cpu_number)
+				gtp_cpu_number = cpu;
+		}
+		gtp_cpu_number++;
+	}
+	gtp_start_last_errno = 0;
+	gtp_start_ignore_error = 0;
+	gtp_pipe_trace = 0;
+	gtp_bt_size = 512;
+	gtp_noack_mode = 0;
+	gtp_current_pid = 0;
+#ifdef GTP_RB
+	gtp_traceframe_info = NULL;
+	gtp_traceframe_info_len = 0;
+#endif
+
+#ifdef CONFIG_X86
+	{
+		/* Init data of while-stepping.  */
+		int	cpu;
+		for_each_online_cpu(cpu) {
+			struct gtp_step_s	*step = &per_cpu(gtp_step, cpu);
+			spin_lock_init(&step->lock);
+			step->step = 0;
+			step->tpe = NULL;
+		}
+	}
+#endif
+
+#ifdef GTP_RB
+	ret = gtp_rb_init();
+	if (ret != 0)
+		goto out;
+#endif
+
+	ret = -ENOMEM;
+	gtp_wq = create_singlethread_workqueue("gtpd");
+	if (gtp_wq == NULL)
+		goto out;
+#ifdef USE_PROC
+	if (proc_create("gtp", S_IFIFO | S_IRUSR | S_IWUSR, NULL,
+			&gtp_operations) == NULL)
+		goto out;
+	if (proc_create("gtpframe", S_IFIFO | S_IRUSR, NULL,
+			&gtpframe_operations) == NULL)
+		goto out;
+#if defined(GTP_FTRACE_RING_BUFFER) || defined(GTP_RB)
+	if (proc_create("gtpframe_pipe", S_IFIFO | S_IRUSR, NULL,
+			&gtpframe_pipe_operations) == NULL)
+		goto out;
+#endif
+#else
+	ret = -ENODEV;
+	gtp_dir = debugfs_create_file("gtp", S_IRUSR | S_IWUSR, NULL,
+				      NULL, &gtp_operations);
+	if (gtp_dir == NULL || gtp_dir == ERR_PTR(-ENODEV)) {
+		gtp_dir = NULL;
+		goto out;
+	}
+	gtpframe_dir = debugfs_create_file("gtpframe", S_IRUSR, NULL,
+					   NULL, &gtpframe_operations);
+	if (gtpframe_dir == NULL || gtpframe_dir == ERR_PTR(-ENODEV)) {
+		gtpframe_dir = NULL;
+		goto out;
+	}
+#if defined(GTP_FTRACE_RING_BUFFER) || defined(GTP_RB)
+	gtpframe_pipe_dir = debugfs_create_file("gtpframe_pipe",
+						S_IRUSR, NULL, NULL,
+						&gtpframe_pipe_operations);
+	if (gtpframe_pipe_dir == NULL
+	    || gtpframe_pipe_dir == ERR_PTR(-ENODEV)) {
+		gtpframe_pipe_dir = NULL;
+		goto out;
+	}
+#endif
+#endif
+
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,30))
+	gtp_modules_traceframe_info_need_get = 1;
+	gtp_modules_traceframe_info = NULL;
+	gtp_modules_traceframe_info_len = 0;
+	if (register_module_notifier(&gtp_modules_load_del_nb))
+		goto out;
+#endif
+
+	ret = gtp_var_special_add_all();
+	if (ret)
+		goto out;
+
+	ret = 0;
+out:
+	if (ret < 0)
+		gtp_release_all_mod();
+
+	return ret;
+}
+
+static void __exit gtp_exit(void)
+{
+	gtp_release_all_mod();
+}
+
+module_init(gtp_init)
+module_exit(gtp_exit)
+
+MODULE_AUTHOR("Hui Zhu <teawater@gmail.com>");
+MODULE_LICENSE("GPL");
--- /dev/null
+++ b/lib/gtp.h
@@ -0,0 +1,160 @@
+#ifndef _GTP_PLUGIN_H_
+#define _GTP_PLUGIN_H_
+
+/* Follow part for ARCH.  */
+#ifdef CONFIG_X86
+#define ULONGEST		uint64_t
+#define LONGEST			int64_t
+#define CORE_ADDR		unsigned long
+
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2,6,24))
+#define GTP_REGS_PC(regs)	((regs)->ip)
+#else
+#ifdef CONFIG_X86_32
+#define GTP_REGS_PC(regs)	((regs)->eip)
+#else
+#define GTP_REGS_PC(regs)	((regs)->rip)
+#endif
+#endif
+
+#ifdef CONFIG_X86_32
+#define GTP_REG_ASCII_SIZE	128
+#define GTP_REG_BIN_SIZE	64
+
+#define GTP_SP_NUM		4
+#define GTP_PC_NUM		8
+#else
+#define GTP_REG_ASCII_SIZE	296
+#define GTP_REG_BIN_SIZE	148
+
+#define GTP_SP_NUM		7
+#define GTP_PC_NUM		16
+#endif
+
+#define GTP_X86_NEED_ADJUST_PC(gts)	(!(gts)->step && !(gts)->hwb)
+#endif
+
+#ifdef CONFIG_MIPS
+#define ULONGEST		uint64_t
+#define LONGEST			int64_t
+#define CORE_ADDR		unsigned long
+
+#define GTP_REGS_PC(regs)	((regs)->cp0_epc)
+
+#ifdef CONFIG_32BIT
+#define GTP_REG_ASCII_SIZE	304
+#define GTP_REG_BIN_SIZE	152
+#else
+#define GTP_REG_ASCII_SIZE	608
+#define GTP_REG_BIN_SIZE	304
+#endif
+
+#define GTP_SP_NUM		29
+#define GTP_PC_NUM		37
+#endif
+
+#ifdef CONFIG_ARM
+#define ULONGEST		uint64_t
+#define LONGEST			int64_t
+#define CORE_ADDR		unsigned long
+
+#define GTP_REGS_PC(regs)	((regs)->uregs[15])
+
+#define GTP_REG_ASCII_SIZE	336
+#define GTP_REG_BIN_SIZE	168
+
+#define GTP_SP_NUM		13
+#define GTP_PC_NUM		15
+#endif
+
+struct gtp_var;
+
+struct gtp_trace_s {
+	struct gtp_entry		*tpe;
+	struct pt_regs			*regs;
+
+#ifdef CONFIG_X86_32
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,26))
+	unsigned long			x86_32_sp;
+#else
+	long				x86_32_sp;
+#endif
+#endif
+
+	long				(*read_memory)(void *dst,
+						       void *src,
+						       size_t size);
+#ifdef GTP_FRAME_SIMPLE
+	/* Next part set it to prev part.  */
+	char				**next;
+#endif
+#ifdef GTP_FTRACE_RING_BUFFER
+	/* NULL means doesn't have head.  */
+	char				*next;
+#endif
+#ifdef GTP_RB
+	/* rb of current cpu.  */
+	struct gtp_rb_s			*next;
+	u64				id;
+#endif
+
+	/* Not 0 if this is step action.
+	   Its value is step number that need exec (include current step).
+	   For example, if a tracepoint have 1 step,
+	   its step action gts->step will be 1.  */
+	int				step;
+
+	struct kretprobe_instance	*ri;
+	int				*run;
+	struct timespec			xtime;
+
+	/* $watch_id will set to WATCH_TPE.  */
+	struct gtp_entry		*watch_tpe;
+	/* $watch_type will set to WATCH_TYPE.  */
+	int				watch_type;
+	/* $watch_size will set to WATCH_SIZE.  */
+	int				watch_size;
+	/* The return of $watch_start or $watch_stop.
+	   0 is success.  */
+	int				watch_start_ret;
+	int				watch_stop_ret;
+
+	/* If this is a session is for a hardware breakpoint.
+	   HWB point to the struct.
+	   If not, it will set to NULL.  */
+	struct gtp_hwb_s		*hwb;
+	/* hwb_current_val have the value of hwb address watch
+	   when hwb_current_val_gotten is true.  */
+	int64_t				hwb_current_val;
+	int				hwb_current_val_gotten;
+
+	/* For set $current.  */
+	struct pt_regs			*tmp_regs;
+
+	int64_t				printk_tmp;
+	unsigned int			printk_level;
+	unsigned int			printk_format;
+	struct gtpsrc			*printk_str;
+};
+
+struct gtp_var_hooks {
+	int	(*gdb_set_val)(struct gtp_trace_s *unused, struct gtp_var *var,
+			       int64_t val);
+	int	(*gdb_get_val)(struct gtp_trace_s *unused, struct gtp_var *var,
+			       int64_t *val);
+	int	(*agent_set_val)(struct gtp_trace_s *gts, struct gtp_var *var,
+				 int64_t val);
+	int	(*agent_get_val)(struct gtp_trace_s *gts, struct gtp_var *var,
+				 int64_t *val);
+};
+
+extern int gtp_plugin_mod_register(struct module *mod);
+extern int gtp_plugin_mod_unregister(struct module *mod);
+
+extern struct gtp_var *gtp_plugin_var_add(char *name, int64_t val,
+					  struct gtp_var_hooks *hooks);
+extern int gtp_plugin_var_del(struct gtp_var *var);
+
+extern ULONGEST gtp_action_reg_read(struct gtp_trace_s *gts, int num);
+
+#endif /* _GTP_PLUGIN_H_ */
--- /dev/null
+++ b/lib/gtp_rb.c
@@ -0,0 +1,584 @@
+/*
+ * Ring buffer of kernel GDB tracepoint module.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ *
+ * Copyright(C) KGTP team (https://code.google.com/p/kgtp/), 2011, 2012
+ *
+ */
+
+/* Following macros is for page of ring buffer.  */
+#define ADDR_SIZE		sizeof(size_t)
+#define GTP_RB_HEAD(addr)	((void *)((size_t)(addr) & PAGE_MASK))
+#define GTP_RB_DATA(addr)	(GTP_RB_HEAD(addr) + ADDR_SIZE)
+#define GTP_RB_END(addr)	(GTP_RB_HEAD(addr) + PAGE_SIZE - ADDR_SIZE)
+#define GTP_RB_PREV(addr)	(*(void **)GTP_RB_HEAD(addr))
+#define GTP_RB_NEXT(addr)	(*(void **)GTP_RB_END(addr))
+#define GTP_RB_DATA_MAX		(PAGE_SIZE - ADDR_SIZE - ADDR_SIZE - FID_SIZE \
+				 - sizeof(u64))
+
+struct gtp_rb_s {
+	spinlock_t	lock;
+
+	/* Pointer to the prev frame entry head.
+	   */
+	void		*prev_frame;
+
+	/* When write, this is the next address to be write.
+	   When read, this is the end of read.  */
+	void		*w;
+
+	/* When alloc memory from rb, record prev value W to PREV_W.
+	   When this memory doesn't need, set W back to PREV_W to release
+	   this memroy.  */
+	void		*prev_w;
+
+	/* Point to the begin of ring buffer.  Read will begin from R.  */
+	void		*r;
+
+	/* Point to the trace frame entry head of current read.  */
+	void		*rp;
+
+	/* This the id of rp point to.
+	   0 means rp doesn't point to a trace frame entry.
+	   So it need call gtp_rb_walk first.  */
+	u64		rp_id;
+
+	/* The cpu id.  */
+	int		cpu;
+};
+
+static struct gtp_rb_s __percpu	*gtp_rb;
+#if defined(CONFIG_ARM) && (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,34))
+static atomic_t				gtp_rb_count;
+#else
+static atomic64_t			gtp_rb_count;
+#endif
+static unsigned int		gtp_rb_page_count;
+static atomic_t			gtp_rb_discard_page_number;
+
+static int
+gtp_rb_init(void)
+{
+	int	cpu;
+
+	gtp_rb = alloc_percpu(struct gtp_rb_s);
+	if (!gtp_rb)
+		return -ENOMEM;
+
+	for_each_online_cpu(cpu) {
+		struct gtp_rb_s	*rb
+			= (struct gtp_rb_s *)per_cpu_ptr(gtp_rb, cpu);
+		memset(rb, 0, sizeof(struct gtp_rb_s));
+		rb->lock = __SPIN_LOCK_UNLOCKED(rb->lock);
+		rb->cpu = cpu;
+	}
+	gtp_rb_page_count = 0;
+	atomic_set(&gtp_rb_discard_page_number, 0);
+
+	return 0;
+}
+
+static void
+gtp_rb_release(void)
+{
+	if (gtp_rb) {
+		free_percpu(gtp_rb);
+		gtp_rb = NULL;
+	}
+}
+
+static void
+gtp_rb_reset(void)
+{
+	int	cpu;
+
+	for_each_online_cpu(cpu) {
+		struct gtp_rb_s	*rb
+			= (struct gtp_rb_s *)per_cpu_ptr(gtp_rb, cpu);
+		rb->w = GTP_RB_DATA(rb->w);
+		rb->r = rb->w;
+		rb->rp = NULL;
+		rb->rp_id = 0;
+		rb->prev_frame = NULL;
+	}
+
+#if defined(CONFIG_ARM) && (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,34))
+	atomic_set(&gtp_rb_count, 0);
+#else
+	atomic64_set(&gtp_rb_count, 0);
+#endif
+	atomic_set(&gtp_rb_discard_page_number, 0);
+}
+
+static inline u64
+gtp_rb_clock(void)
+{
+	u64	ret;
+
+re_inc:
+#if defined(CONFIG_ARM) && (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,34))
+	ret = (u64)atomic_inc_return(&gtp_rb_count);
+#else
+	ret = atomic64_inc_return(&gtp_rb_count);
+#endif
+	if (ret == 0)
+		goto re_inc;
+
+	return ret;
+}
+
+#define GTP_RB_PAGE_IS_EMPTY	(gtp_rb_page_count == 0)
+
+static int
+gtp_rb_page_alloc(int size)
+{
+	int	cpu;
+
+	for_each_online_cpu(cpu) {
+		struct gtp_rb_s	*rb
+			= (struct gtp_rb_s *)per_cpu_ptr(gtp_rb, cpu);
+		void		*last = NULL, *next = NULL;
+		struct page	*page;
+		int		current_size;
+
+		gtp_rb_page_count = 0;
+		current_size = size;
+
+		while (1) {
+			if (current_size > 0)
+				current_size -= PAGE_SIZE;
+			else
+				break;
+
+			page = alloc_pages_node(cpu_to_node(cpu),
+						GFP_KERNEL, 0);
+			if (!page)
+				return -1;
+			gtp_rb_page_count++;
+			rb->w = GTP_RB_DATA(page_address(page));
+			GTP_RB_NEXT(rb->w) = next;
+			if (next)
+				GTP_RB_PREV(next) = rb->w;
+			next = rb->w;
+			if (!last)
+				last = rb->w;
+		}
+
+		GTP_RB_NEXT(last) = next;
+		GTP_RB_PREV(next) = last;
+		rb->r = rb->w;
+
+		if (gtp_rb_page_count < 3)
+			return -1;
+	}
+
+	return 0;
+}
+
+static void
+gtp_rb_page_free(void)
+{
+	int	cpu;
+
+	for_each_online_cpu(cpu) {
+		struct gtp_rb_s	*rb
+			= (struct gtp_rb_s *)per_cpu_ptr(gtp_rb, cpu);
+		void		*need_free = NULL;
+		int		is_first = 1;
+
+		for (rb->r = rb->w = GTP_RB_DATA(rb->w);
+		     is_first || rb->w != rb->r;
+		     rb->w = GTP_RB_NEXT(rb->w)) {
+			if (need_free)
+				free_page((unsigned long)need_free);
+			need_free = GTP_RB_HEAD(rb->w);
+			is_first = 0;
+		}
+		if (need_free)
+			free_page((unsigned long)need_free);
+	}
+
+	gtp_rb_page_count = 0;
+}
+
+#define GTP_RB_LOCK(r)			spin_lock(&r->lock)
+#define GTP_RB_UNLOCK(r)		spin_unlock(&r->lock)
+#define GTP_RB_LOCK_IRQ(r, flags)	spin_lock_irqsave(&r->lock, flags)
+#define GTP_RB_UNLOCK_IRQ(r, flags)	spin_unlock_irqrestore(&r->lock, flags)
+#define GTP_RB_RELEASE(r)		(r->prev_w = r->w)
+
+static inline void *
+gtp_rb_prev_frame_get(struct gtp_rb_s *rb)
+{
+	return rb->prev_frame;
+}
+
+static inline void
+gtp_rb_prev_frame_set(struct gtp_rb_s *rb, void *prev_frame)
+{
+	rb->prev_frame = prev_frame;
+}
+
+static void *
+gtp_rb_alloc(struct gtp_rb_s *rb, size_t size, u64 id)
+{
+	void		*ret;
+
+	size = FRAME_ALIGN(size);
+
+	if (size > GTP_RB_DATA_MAX) {
+		printk(KERN_WARNING "gtp_rb_alloc: The size %zu is too big"
+				    "for the KGTP ring buffer.  "
+				    "The max size that KGTP ring buffer "
+				    "support is %lu (Need sub some size for "
+				    "inside structure).\n", size, GTP_RB_DATA_MAX);
+		return NULL;
+	}
+
+	rb->prev_w = rb->w;
+
+	if (rb->w + size > GTP_RB_END(rb->w)) {
+		/* Don't have enough size in current page, insert a
+		   FID_PAGE_END and try to get next page.  */
+		if (GTP_RB_END(rb->w) - rb->w >= FID_SIZE)
+			FID(rb->w) = FID_PAGE_END;
+
+		if (GTP_RB_HEAD(GTP_RB_NEXT(rb->w)) == GTP_RB_HEAD(rb->r)) {
+			if (gtp_circular) {
+				rb->r = GTP_RB_NEXT(rb->r);
+				atomic_inc(&gtp_rb_discard_page_number);
+			} else
+				return NULL;
+		}
+		rb->w = GTP_RB_NEXT(rb->w);
+
+		if (id) {
+			/* Need insert a FID_PAGE_BEGIN.  */
+			FID(rb->w) = FID_PAGE_BEGIN;
+			*((u64 *)(rb->w + FID_SIZE)) = id;
+			rb->w += FRAME_ALIGN(GTP_FRAME_PAGE_BEGIN_SIZE);
+		}
+	}
+
+	ret = rb->w;
+	rb->w += size;
+
+	return ret;
+}
+
+enum gtp_rb_walk_reason {
+	gtp_rb_walk_end = 0,
+	gtp_rb_walk_end_page,
+	gtp_rb_walk_end_entry,
+	gtp_rb_walk_new_entry,
+	gtp_rb_walk_type,
+	gtp_rb_walk_step,
+	gtp_rb_walk_error,
+};
+
+/* Check *end.  */
+#define GTP_RB_WALK_CHECK_END	0x1
+
+/* When to the end of a page, goto next one.  */
+#define GTP_RB_WALK_PASS_PAGE	0x2
+
+/* When to the end of a entry, goto next one.
+   If not set, stop in the first address of next entry and
+   set S->REASON to gtp_rb_walk_new_entry.  */
+#define GTP_RB_WALK_PASS_ENTRY	0x4
+
+/* Check with id and FID_PAGE_BEGIN to make sure this is the current frame.  */
+#define GTP_RB_WALK_CHECK_ID	0x8
+
+/* Return and set S->REASON to gtp_rb_walk_type if type is same entry type.  */
+#define GTP_RB_WALK_CHECK_TYPE	0x10
+
+/* Walk STEP step in ring_buffer, just record FID_REG, FID_MEM, FID_VAR.  */
+#define GTP_RB_WALK_STEP	0x20
+
+struct gtp_rb_walk_s {
+	unsigned int		flags;
+
+	/* Reason for return.  */
+	enum gtp_rb_walk_reason	reason;
+
+	/* GTP_RB_WALK_CHECK_END,
+	   it will point to the end of this ring buffer.  */
+	void			*end;
+
+	/* GTP_RB_WALK_CHECK_ID */
+	u64			id;
+
+	/* GTP_RB_WALK_CHECK_TYPE */
+	FID_TYPE		type;
+
+	/* GTP_RB_WALK_STEP */
+	int			step;
+};
+
+/* Walk in ring buffer RET according to S.  And return the new pointer.  */
+
+static void *
+gtp_rb_walk(struct gtp_rb_walk_s *s, void *ret)
+{
+	int	step;
+	void	*page_end = GTP_RB_END(ret);
+
+	if (s->flags & GTP_RB_WALK_STEP)
+		step = 0;
+
+	while (1) {
+		FID_TYPE	fid;
+
+		if ((s->flags & GTP_RB_WALK_CHECK_END) && ret == s->end) {
+			s->reason = gtp_rb_walk_end;
+			break;
+		}
+
+		if (ret == page_end || page_end - ret < FID_SIZE
+		    || FID(ret) == FID_PAGE_END) {
+			if (!(s->flags & GTP_RB_WALK_PASS_PAGE)) {
+				s->reason = gtp_rb_walk_end_page;
+				break;
+			}
+			ret = GTP_RB_NEXT(ret);
+			page_end = GTP_RB_END(ret);
+			continue;
+		}
+
+		fid = FID(ret);
+
+		if ((s->flags & GTP_RB_WALK_CHECK_TYPE) && s->type == fid) {
+			s->reason = gtp_rb_walk_type;
+			break;
+		}
+
+		if ((s->flags & GTP_RB_WALK_STEP)
+		    && (fid == FID_REG || fid == FID_MEM || fid == FID_VAR)) {
+			if (step >= s->step) {
+				s->reason = gtp_rb_walk_step;
+				break;
+			}
+			step++;
+		}
+
+		switch (fid) {
+		case FID_HEAD:
+			if (!(s->flags & GTP_RB_WALK_PASS_ENTRY)) {
+				s->reason = gtp_rb_walk_new_entry;
+				goto out;
+			}
+			ret += FRAME_ALIGN(GTP_FRAME_HEAD_SIZE);
+			break;
+		case FID_REG:
+			ret += FRAME_ALIGN(GTP_FRAME_REG_SIZE);
+			break;
+		case FID_MEM: {
+				struct gtp_frame_mem	*gfm;
+
+				gfm = (struct gtp_frame_mem *) (ret + FID_SIZE);
+				ret += FRAME_ALIGN(GTP_FRAME_MEM_SIZE
+						   + gfm->size);
+			}
+			break;
+		case FID_VAR:
+			ret += FRAME_ALIGN(GTP_FRAME_VAR_SIZE);
+			break;
+		case FID_PAGE_BEGIN:
+			if ((s->flags & GTP_RB_WALK_CHECK_ID)
+			    && s->id != *(u64 *)(ret + FID_SIZE)) {
+				s->reason = gtp_rb_walk_end_entry;
+				goto out;
+			}
+			ret += FRAME_ALIGN(GTP_FRAME_PAGE_BEGIN_SIZE);
+			break;
+		default:
+			printk(KERN_WARNING
+			       "Walk in gtp ring buffer got error id 0x%x "
+			       "in 0x%p.\n",
+			       fid, ret);
+			s->reason = gtp_rb_walk_error;
+			goto out;
+			break;
+		}
+	}
+
+out:
+	return ret;
+}
+
+static void *
+gtp_rb_walk_reverse(void *buf, void *begin)
+{
+	if (buf == begin)
+		return NULL;
+	buf = *(void **)(buf + FID_SIZE + sizeof(u64) + sizeof(ULONGEST));
+
+	return buf;
+}
+
+static struct gtp_rb_s	*gtp_frame_current_rb;
+static u64		gtp_frame_current_id;
+static struct pt_regs	*gtp_frame_current_regs;
+
+static void
+gtp_rb_read_reset(void)
+{
+	int	cpu;
+
+	for_each_online_cpu(cpu) {
+		struct gtp_rb_s	*rb
+			= (struct gtp_rb_s *)per_cpu_ptr(gtp_rb, cpu);
+
+		rb->rp = rb->r;
+		rb->rp_id = 0;
+	}
+	gtp_frame_current_num = -1;
+	gtp_frame_current_rb = NULL;
+}
+
+static void
+gtp_rb_update_gtp_frame_current(void)
+{
+	gtp_frame_current_id = *(u64 *)(gtp_frame_current_rb->rp + FID_SIZE);
+	gtp_frame_current_tpe = *(ULONGEST *)(gtp_frame_current_rb->rp
+					      + FID_SIZE + sizeof(u64));
+	gtp_frame_current_rb->rp += FRAME_ALIGN(GTP_FRAME_HEAD_SIZE);
+	gtp_frame_current_regs = NULL;
+}
+
+static int
+gtp_rb_read(void)
+{
+	int			cpu;
+	u64			min_id = ULLONG_MAX;
+	struct gtp_rb_walk_s	rbws;
+
+	gtp_frame_current_rb = NULL;
+
+	rbws.flags = GTP_RB_WALK_PASS_PAGE | GTP_RB_WALK_CHECK_END;
+
+	for_each_online_cpu(cpu) {
+		struct gtp_rb_s	*rb
+			= (struct gtp_rb_s *)per_cpu_ptr(gtp_rb, cpu);
+
+		if (rb->rp == NULL)
+			rb->rp = rb->r;
+
+		if (rb->rp_id == 0) {
+			rbws.end = rb->w;
+			rb->rp = gtp_rb_walk(&rbws, rb->rp);
+			if (rbws.reason != gtp_rb_walk_new_entry)
+				continue;
+			rb->rp_id = *(u64 *)(rb->rp + FID_SIZE);
+		}
+		if (rb->rp_id < min_id) {
+			min_id = rb->rp_id;
+			gtp_frame_current_rb = rb;
+		}
+	}
+
+	if (gtp_frame_current_rb == NULL) {
+		gtp_rb_read_reset();
+		return -1;
+	}
+
+	gtp_frame_current_rb->rp_id = 0;
+	gtp_rb_update_gtp_frame_current();
+	gtp_frame_current_num += 1;
+
+	return 0;
+}
+
+static void *
+gtp_rb_get_page(struct gtp_rb_s *rb)
+{
+	void		*ret = NULL;
+	unsigned long	flags;
+
+	GTP_RB_LOCK_IRQ(rb, flags);
+
+	if (GTP_RB_HEAD(rb->r) == GTP_RB_HEAD(rb->w)) {
+		if (rb->r == rb->w)
+			goto out;
+		/* Move rb->w to next page.  */
+		if (GTP_RB_END(rb->w) - rb->w >= FID_SIZE)
+			FID(rb->w) = FID_PAGE_END;
+		rb->w = GTP_RB_NEXT(rb->w);
+	}
+
+	ret = rb->r;
+	{
+		/* Move this page out of ring.  */
+		void	*prev = GTP_RB_PREV(rb->r);
+		void	*next = GTP_RB_NEXT(rb->r);
+
+		GTP_RB_NEXT(prev) = next;
+		GTP_RB_PREV(next) = prev;
+		rb->r = next;
+	}
+
+out:
+	GTP_RB_UNLOCK_IRQ(rb, flags);
+	return ret;
+}
+
+static void
+gtp_rb_put_page(struct gtp_rb_s *rb, void *page, int page_is_empty)
+{
+	void	*prev, *next;
+	unsigned long	flags;
+
+	GTP_RB_LOCK_IRQ(rb, flags);
+
+	if (page_is_empty) {
+		page = GTP_RB_DATA(page);
+		if (rb->w == GTP_RB_DATA(rb->w)) {
+			/* Set page before rb->w and set it as rb->w.
+			   If need, set it as rb->r.  */
+			prev = GTP_RB_PREV(rb->w);
+			next = rb->w;
+			if (rb->r == rb->w)
+				rb->r = page;
+			rb->w = page;
+		} else {
+			/* Set page after rb->w.  */
+			prev = GTP_RB_DATA(rb->w);
+			next = GTP_RB_NEXT(rb->w);
+		}
+	} else {
+		if (rb->r == GTP_RB_DATA(rb->r)) {
+			/* Current rb->r page is point to the begin of a page.
+			   Set page before rb->r and set it as rb->r.  */
+			prev = GTP_RB_PREV(rb->r);
+			next = rb->r;
+		} else {
+			/* Current rb->r page is not point to the begin of a
+			   page, give up this data.
+			   Set page after rb->r and set it as rb->r.  */
+			prev = GTP_RB_DATA(rb->r);
+			next = GTP_RB_NEXT(rb->r);
+		}
+		rb->r = page;
+	}
+
+	GTP_RB_NEXT(prev) = GTP_RB_DATA(page);
+	GTP_RB_PREV(next) = GTP_RB_DATA(page);
+	GTP_RB_PREV(page) = prev;
+	GTP_RB_NEXT(page) = next;
+
+	GTP_RB_UNLOCK_IRQ(rb, flags);
+}
--- /dev/null
+++ b/scripts/gtp/add-ons/hotcode.py
@@ -0,0 +1,745 @@
+#!/usr/bin/python
+
+# This script is used to find the hotcode in some tasks
+# GPL
+# Copyright(C) Hui Zhu (teawater@gmail.com), 2012
+
+import gdb
+import tempfile
+import os
+import signal
+import sys
+import traceback
+import time
+
+class hotcode_list:
+	def __init__(self):
+		self.function_list = {}
+		self.file_list = {}
+		self.line_list = {}
+		self.function_list_line = {}
+		self.file_list_line = {}
+		self.num = 0
+
+class task:
+	def __init__(self, fid, user_dir):
+		self.fid = fid
+		self.user_dir = user_dir
+		self.kernel = hotcode_list()
+		self.user = hotcode_list()
+
+debug_dir = "/usr/lib/debug/"
+task_list = {}
+no_task = False
+kernel_hotcode_list = hotcode_list()
+
+output_html = True
+output_html_file = "./hotcode.html"
+show_line_number_default = 20
+show_line_number = show_line_number_default
+
+#--------------------------------------------------------------------------------------------------
+#For signal handler
+
+from operator import itemgetter
+def dict_sort(d, reverse=False):
+	#proposed in PEP 265, using  the itemgetter
+	return sorted(d.iteritems(), key=itemgetter(1), reverse=True)
+
+def hotcode_show_code_list(string, code_list):
+	if len(code_list) > 0:
+		print "\t", string
+		i = 1
+		for c in dict_sort(code_list):
+			print "\t", c[0], "\t\t", c[1]
+			i += 1
+			if i > show_line_number:
+				break
+		print
+
+def hotcode_show():
+	if no_task:
+		hotcode_show_code_list("Hotest function", kernel_hotcode_list.function_list)
+		hotcode_show_code_list("Hotest file", kernel_hotcode_list.file_list)
+		hotcode_show_code_list("Hotest line", kernel_hotcode_list.line_list)
+	else:
+		for pid in task_list:
+			print "task", str(pid), task_list[pid].user_dir
+			print "Kernel hotcode:"
+			hotcode_show_code_list("Hotest function", task_list[pid].kernel.function_list)
+			hotcode_show_code_list("Hotest file", task_list[pid].kernel.file_list)
+			hotcode_show_code_list("Hotest line", task_list[pid].kernel.line_list)
+			print "User hotcode:"
+			hotcode_show_code_list("Hotest function", task_list[pid].user.function_list)
+			hotcode_show_code_list("Hotest file", task_list[pid].user.file_list)
+			hotcode_show_code_list("Hotest line", task_list[pid].user.line_list)
+			print
+
+html_id = 0
+
+def hotcode_list_to_output_html_fd_1(llist, tlist, fd):
+	global html_id
+	i = 1
+	for c in dict_sort(llist):
+		if tlist != None:
+			fd.write('''<tr><td onclick='sh("'''+str(html_id)+'''");'>'''+str(c[0])+'''</td><td style=" width: 10%; text-align: right;">'''+str(c[1])+'''</td></tr>''')
+			fd.write('''<tr><td style="text-align: center; display: none;" colspan="2" id="''' + str(html_id) + '''"><table style="width: 100%;" border="1" cellpadding="0" cellspacing="0"><tbody>''')
+			for d in dict_sort(tlist[c[0]]):
+				fd.write("<tr><td>" + str(d[0]) + '''</td><td style=" width: 10%; text-align: right;">''' + str(d[1]) + "</td></tr>")
+			fd.write('</tbody></table>')
+		else:
+			fd.write('<tr><td>'+str(c[0])+'''</td><td style=" width: 10%; text-align: right;">'''+str(c[1])+'''</td></tr>''')
+		i += 1
+		html_id += 1
+		if i > show_line_number:
+			break
+
+def hotcode_list_to_output_html_fd(hlist, fd):
+	global html_id
+	fd.write('''<tr><td style="text-align: center;" colspan="2">Hot functions list</td></tr>''')
+	hotcode_list_to_output_html_fd_1(hlist.function_list, hlist.function_list_line, fd)
+
+	fd.write('''<tr><td style="text-align: center;" colspan="2">Hot file list</td></tr>''')
+	hotcode_list_to_output_html_fd_1(hlist.file_list, hlist.file_list_line, fd)
+
+	fd.write('''<tr><td style="text-align: center;" colspan="2">Hot line list</td></tr>''')
+	hotcode_list_to_output_html_fd_1(hlist.line_list, None, fd)
+
+def hotcode_to_output_html_file():
+	global html_id
+	html_id = 0
+	fd = open(output_html_file, "w")
+	fd.write('''
+<html><head><title>Hotcode</title>
+<script>
+<!--
+function sh(id)
+{
+	if(document.getElementById(id).style.display=='none') {
+		document.getElementById(id).style.display='block';
+	}
+	else {
+		document.getElementById(id).style.display='none';
+	}
+}
+-->
+</script></head>
+<body>
+<div style="text-align: center;">This file is generated by KGTP (<a href="http://code.google.com/p/kgtp/">http://code.google.com/p/kgtp/</a>) in ''' + time.strftime("%Y-%m-%d %H:%M:%S", time.localtime()) + '''.</div>
+<div style="text-align: center;">Click the function name or file name to see the detailed info.</div>''')
+	if show_line_number > 0:
+		fd.write('''<div style="text-align: center;">Just show top 20 of each list.</div>''')
+	if no_task:
+		fd.write('<br><br>')
+		fd.write('''<table style="margin-left: auto; margin-right: auto;" border="1" cellpadding="2" cellspacing="0"><tbody>''')
+		fd.write('''<tr><td><strong>Kernel space hotcode list</strong></td><td style=" width: 10%; text-align: right;">'''+str(kernel_hotcode_list.num)+'''</td></tr>''')
+		hotcode_list_to_output_html_fd(kernel_hotcode_list, fd)
+		fd.write('</tbody></table>')
+	else:
+		for pid in task_list:
+			fd.write('<br><br>')
+			fd.write('''<table style="margin-left: auto; margin-right: auto;" border="1" cellpadding="2" cellspacing="0"><tbody>''')
+			fd.write('''<tr><td style="text-align: center;" colspan="2">pid:''' + str(pid) + " " + task_list[pid].user_dir + "</td></tr>")
+			if trace_user:
+				fd.write('''<tr><td style="text-align: center;" colspan="2">User space hotcode list </td></tr>''')
+				fd.write('''<tr><td><strong>User space hotcode list</strong></td><td style=" width: 10%; text-align: right;">'''+str(task_list[pid].user.num)+'''</td></tr>''')
+				hotcode_list_to_output_html_fd(task_list[pid].user, fd)
+			if trace_kernel:
+				if trace_user:
+					fd.write('''<tr><td style="text-align: center;" colspan="2"></td></tr>''')
+				fd.write('''<tr><td><strong>Kernel space hotcode list</strong></td><td style=" width: 10%; text-align: right;">'''+str(task_list[pid].kernel.num)+'''</td></tr>''')
+				hotcode_list_to_output_html_fd(task_list[pid].kernel, fd)
+			fd.write('</tbody></table>')
+	fd.write('</body></html>')
+	fd.close()
+	print "Save", html_id, "entries."
+
+def sigint_handler(num, e):
+	if output_html:
+		hotcode_to_output_html_file()
+	else:
+		hotcode_show()
+	try:
+		s = raw_input('Conitnue? [(y)es], (n)o:')
+	except:
+		s = 'y'
+	finally:
+		if s[0:1] != 'n' and s[0:1] != 'N':
+			return;
+	#gdb.execute("inferior 1")
+	try:
+		gdb.execute("tfind -1", True, False)
+		gdb.execute("target remote /sys/kernel/debug/gtp", True, False)
+		gdb.execute("set disconnected-tracing off", True, False)
+	except:
+		print "Try to stop GTP got error, please use command \"sudo rmmod gtp.ko\" stop it."
+	exit(1);
+#--------------------------------------------------------------------------------------------------
+#init
+
+def add_inferior():
+	fid = gdb.execute("add-inferior", False, True)
+	if fid.find("Added inferior ") != 0:
+		return -1
+	fid = int(fid[len("Added inferior "):])
+	return fid
+
+gdb.execute("set target-async on", True, False)
+gdb.execute("set pagination off", True, False)
+gdb.execute("set confirm off", True, False)
+gdb.execute("set circular-trace-buffer on", True, False)
+gdb.execute("set debug-file-directory "+debug_dir, True, False)
+try:
+	gdb.execute("kill", True, False)
+except:
+	pass
+
+trace_user = True
+trace_kernel = True
+while 1:
+	tmp = "both"
+	try:
+		tmp = raw_input('Which part of code you want trace? [(b)oth], (u)ser, (k)ernel:')
+	except:
+		continue
+	if tmp[0:1] == 'U' or tmp[0:1] == 'u':
+		trace_kernel = False
+	elif tmp[0:1] == 'K' or tmp[0:1] == 'k':
+		trace_user = False
+	break
+
+#Get which task pid why want to trace
+print("Please input the pid of task that you want to trace - one per line.")
+print("If not set any task, will trace all code in the Linux kernel.")
+while 1:
+	pid = -1
+	try:
+		pid = input('task pid (use empty to stop pid input):')
+	except:
+		pass
+	if pid <= 0:
+		break
+	if pid in task_list:
+		print("This pid already in the list.")
+		continue
+	user_dir = ""
+	fid = 0
+	if trace_user:
+		try:
+			orig_user_dir = user_dir = os.path.realpath("/proc/"+str(pid)+"/exe")
+		except:
+			#maybe this is the kernel task
+			print "Cannot get the user code info of this pid, will not parse the user level code symbol"
+			task_list[pid] = task(fid, user_dir)
+			continue
+		if os.path.exists(debug_dir+user_dir):
+			user_dir = debug_dir+user_dir
+		while 1:
+			tmp = ""
+			try:
+				tmp = raw_input('Please input the debug binary of task if you want to change it ['+user_dir+']:')
+			except:
+				continue
+			if tmp != "":
+				user_dir = os.path.realpath(tmp)
+			break
+		if not os.path.exists(user_dir):
+			print "Cannot get the user code info of this pid, will not parse the user level code symbol"
+			task_list[pid] = task(fid, user_dir)
+			continue
+		print "Use "+user_dir+" as debug binary."
+		fid = add_inferior()
+		if fid < 0:
+			print "Try to load task got error."
+			continue
+		gdb.execute("inferior "+str(fid))
+		pfile = open("/proc/"+str(pid)+"/maps", "r")
+		tmplist = pfile.read().split(os.linesep)
+		pfile.close()
+		for c in tmplist:
+			c_list = c.split(" ")
+			filename = c_list[-1].strip()
+			if filename != orig_user_dir and os.path.exists(filename) and len(c_list) > 2 and len(c_list[1]) > 3 and c_list[1][2] == 'x':
+				addr = "0x"+c_list[0][0:c.find('-')]
+				gdb.execute("file "+filename)
+				info_files = gdb.execute("info files", True, True)
+				info_files_list = info_files.split(os.linesep)
+				text_offset = "0x0"
+				for line in info_files_list:
+					line_list = line.split(" is ")
+					if len(line_list) == 2 and line_list[1].strip() == ".text":
+						line_list[0] = line_list[0].strip()
+						text_offset = line_list[0][0:line_list[0].find(' - ')]
+				print ("add-symbol-file "+filename+" ("+addr+"+"+text_offset+")")
+				gdb.execute("add-symbol-file "+filename+" ("+addr+"+"+text_offset+")")
+		gdb.execute("file "+user_dir)
+		gdb.execute("inferior 1")
+	task_list[pid] = task(fid, user_dir)
+
+def get_addr_range_list(fun):
+	buf = gdb.execute("info line "+fun, False, True)
+	line_list = buf.split(os.linesep)
+	ret = []
+	begin = -1
+	end = -1
+	for line in line_list:
+		addr_begin = line.find("starts at address ")
+		if addr_begin >= 0:
+			line = line[addr_begin + len("starts at address "):]
+			addr_end = line.find(" <"+fun)
+			if addr_end >= 0:
+				begin = int(line[:addr_end], 0)
+				line = line[addr_end + len(" <"+fun):]
+		addr_begin = line.find("ends at ")
+		if addr_begin >= 0:
+			line = line[addr_begin + len("ends at "):]
+			addr_end = line.find(" <"+fun)
+			if addr_end > 0:
+				end = int(line[:addr_end], 0)
+				if begin != -1:
+					ret.append([begin, end])
+				begin = -1
+				end = -1
+
+	if len(ret) > 0:
+		buf = gdb.execute("disassemble "+fun, False, True)
+		line_list = buf.split(os.linesep)
+		line_list.reverse()
+		end = 0
+		for line in line_list:
+			addr_begin = line.find("0x")
+			if addr_begin >= 0:
+				line = line[addr_begin:]
+				addr_end = line.find(" <+")
+				if addr_end > 0:
+					end = int(line[:addr_end], 0) + 1
+					break
+		if end != 0:
+			offset = 0
+			for c in ret:
+				if c[1] < end:
+					if offset == 0 or offset > (end - c[1]):
+						offset = end - c[1]
+			for c in ret:
+				c[1] += offset
+
+	return ret
+
+def get_ignore_str(function):
+	ret = ""
+	try:
+		s = raw_input('Do you want to ignore function \"'+function+'\"? [(y)es], (n)o:')
+	except:
+		s = 'y'
+	if s[0:1] != 'n' and s[0:1] != 'N':
+		r_list = get_addr_range_list(function)
+		for r in r_list:
+			if ret != "":
+				ret += " && "
+			else:
+				ret += "&& ("
+			#(regs->ip < r[0] || regs->ip > r[1])
+			ret += "($p_ip < "+str(r[0])+" || $p_ip > "+str(r[1])+")"
+		if ret != "":
+			ret += ")"
+	return ret
+
+if len(task_list) == 0:
+	trace_user = False
+	trace_kernel = True
+	no_task = True
+
+try:
+	s = raw_input('Which way you want to output hotcode info when ctrl-c? [(h)tml], (t)ty:')
+except:
+	s = 'h'
+if s[0:1] == 't' or s[0:1] == 'T':
+	output_html = False
+else:
+	output_html = True
+
+if output_html:
+	while 1:
+		try:
+			s = raw_input('Which file you want to save the html output? [' + output_html_file + ']:')
+			if os.path.exists(s):
+				if os.path.isfile(s):
+					s = raw_input('File ' + s +' exist, do you want to over write it? (y)es, [(n)o]:')
+					if s[0:1] != 'y' and s[0:1] != 'Y':
+						continue
+				else:
+					print 'File ' + s +' exist, but it cannot be written.  Please choice another file.'
+					continue
+		except:
+			continue
+		if len(s) > 0:
+			output_html_file = s
+		break
+
+try:
+	show_line_number = input('Show line number (0 meas all)? ['+str(show_line_number)+']:')
+except:
+	show_line_number = show_line_number_default
+
+#Set tracepoint
+gdb.execute("target remote /sys/kernel/debug/gtp", True, False)
+
+try:
+	gdb.execute("tstop", True, False)
+	gdb.execute("delete", True, False)
+except:
+	pass
+
+
+def getmod():
+	#following code is get from ../getmod.py
+	#use the code directly because sys.argv = [''] inside GDB
+	def format_file(name):
+		tmp = ""
+		for c in name:
+			if c == "_":
+				c = "-"
+			tmp += c
+		return tmp
+
+	#Check if the target is available
+	if str(gdb.selected_thread()) == "None":
+		raise gdb.error("Please connect to Linux Kernel before use the script.")
+
+	#Output the help
+	print "Use GDB command \"set $mod_search_dir=dir\" to set an directory for search the modules."
+
+	ignore_gtp_ko = gdb.parse_and_eval("$ignore_gtp_ko")
+	if ignore_gtp_ko.type.code == gdb.TYPE_CODE_INT:
+		ignore_gtp_ko = int(ignore_gtp_ko)
+	else:
+		ignore_gtp_ko = 1
+
+	#Get the mod_search_dir
+	mod_search_dir_list = []
+	#Get dir from $mod_search_dir
+	tmp_dir = gdb.parse_and_eval("$mod_search_dir")
+	if tmp_dir.type.code == gdb.TYPE_CODE_ARRAY:
+		tmp_dir = str(tmp_dir)
+		tmp_dir = tmp_dir[1:len(tmp_dir)]
+		tmp_dir = tmp_dir[0:tmp_dir.index("\"")]
+		mod_search_dir_list.append(tmp_dir)
+	#Get dir that same with current vmlinux
+	tmp_dir = str(gdb.execute("info files", False, True))
+	tmp_dir = tmp_dir[tmp_dir.index("Symbols from \"")+len("Symbols from \""):len(tmp_dir)]
+	tmp_dir = tmp_dir[0:tmp_dir.index("\"")]
+	tmp_dir = tmp_dir[0:tmp_dir.rindex("/")]
+	mod_search_dir_list.append(tmp_dir)
+	#Get the dir of current Kernel
+	tmp_dir = "/lib/modules/" + str(os.uname()[2])
+	if os.path.isdir(tmp_dir):
+		mod_search_dir_list.append(tmp_dir)
+	#Let user choice dir
+	mod_search_dir = ""
+	while mod_search_dir == "":
+		for i in range(0, len(mod_search_dir_list)):
+			print str(i)+". "+mod_search_dir_list[i]
+		try:
+			s = input('Select a directory for search the modules [0]:')
+		except SyntaxError:
+			s = 0
+		except:
+			continue
+		if s < 0 or s >= len(mod_search_dir_list):
+			continue
+		mod_search_dir = mod_search_dir_list[s]
+
+	mod_list_offset = long(gdb.parse_and_eval("((size_t) &(((struct module *)0)->list))"))
+	mod_list = long(gdb.parse_and_eval("(&modules)"))
+	mod_list_current = mod_list
+
+	while 1:
+		mod_list_current = long(gdb.parse_and_eval("((struct list_head *) "+str(mod_list_current)+")->next"))
+
+		#check if need break the loop
+		if mod_list == mod_list_current:
+			break
+
+		mod = mod_list_current - mod_list_offset
+
+		#get mod_name
+		mod_name = str(gdb.parse_and_eval("((struct module *)"+str(mod)+")->name"))
+		mod_name = mod_name[mod_name.index("\"")+1:len(mod_name)]
+		mod_name = mod_name[0:mod_name.index("\"")]
+		if mod_name == "fglrx":
+			contiue
+		mod_name += ".ko"
+		mod_name = format_file(mod_name)
+
+		#get mod_dir_name
+		mod_dir_name = ""
+		for root, dirs, files in os.walk(mod_search_dir):
+			for afile in files:
+				tmp_file = format_file(afile)
+				if tmp_file == mod_name:
+					mod_dir_name = os.path.join(root,afile)
+					break
+			if mod_dir_name != "":
+				break
+
+		command = " "
+
+		#Add module_core to command
+		command += str(gdb.parse_and_eval("((struct module *)"+str(mod)+")->module_core"))
+
+		#Add each sect_attrs->attrs to command
+		#get nsections
+		nsections = int(gdb.parse_and_eval("((struct module *)"+str(mod)+")->sect_attrs->nsections"))
+		sect_attrs = long(gdb.parse_and_eval("(u64)((struct module *)"+str(mod)+")->sect_attrs"))
+		for i in range(0, nsections):
+			command += " -s"
+			tmp = str(gdb.parse_and_eval("((struct module_sect_attrs *)"+str(sect_attrs)+")->attrs["+str(i)+"].name"))
+			tmp = tmp[tmp.index("\"")+1:len(tmp)]
+			tmp = tmp[0:tmp.index("\"")]
+			command += " "+tmp
+			tmp = str(gdb.parse_and_eval("((struct module_sect_attrs *)"+str(sect_attrs)+")->attrs["+str(i)+"].address"))
+			command += " "+tmp
+
+		if mod_dir_name == "":
+			print "Cannot find out",mod_name,"from directory."
+			print "Please use following command load the symbols from it:"
+			print "add-symbol-file some_dir/"+mod_name+command
+		else:
+			if ignore_gtp_ko and mod_name == "gtp.ko":
+				pass
+			else:
+				#print "add-symbol-file "+mod_dir_name+command
+				gdb.execute("add-symbol-file "+mod_dir_name+command, False, False)
+
+if trace_kernel:
+	try:
+		s = raw_input('Do you load the symbol from LKM? (y)es, [(n)o]:')
+	except:
+		s = 'n'
+	if s[0:1] == 'y' or s[0:1] == 'Y':
+		getmod()
+
+cpu_number = int(gdb.parse_and_eval("$cpu_number"))
+tempfilename = tempfile.mktemp()
+tempfile = open(tempfilename, "w")
+if no_task:
+	ignore_str = ""
+	#Setup first tracepoint
+	ignore_str += get_ignore_str("arch_local_irq_enable")
+	ignore_str += get_ignore_str("intel_idle")
+	# GDB have bug with long conditon so close them
+	#ignore_str += get_ignore_str("__do_softirq")
+	#ignore_str += get_ignore_str("_raw_spin_unlock_irqrestore")
+
+	tempfile.write("tvariable $p_ip\n")
+	tempfile.write("tvariable $p_cs\n")
+	tempfile.write("trace handle_irq\n")
+	tempfile.write("commands\n")
+	tempfile.write("teval $p_ip=(u64)regs->ip\n")
+	tempfile.write("teval $p_cs=(u64)regs->cs\n")
+	tempfile.write("end\n")
+	#Setup second tracepoint
+	tempfile.write("trace handle_irq\n")
+	cond_str = " (($p_cs & 3) == 0)"
+	tempfile.write("condition $bpnum "+cond_str+ignore_str+"\n")
+	tempfile.write("commands\n")
+	tempfile.write("collect $no_self_trace\n")
+	tempfile.write("collect $p_ip\n")
+	tempfile.write("end\n")
+	tempfile.write("trace smp_apic_timer_interrupt\n")
+	tempfile.write("commands\n")
+	tempfile.write("teval $p_ip=(u64)regs->ip\n")
+	tempfile.write("teval $p_cs=(u64)regs->cs\n")
+	tempfile.write("end\n")
+	#Setup second tracepoint
+	tempfile.write("trace smp_apic_timer_interrupt\n")
+	cond_str = " (($p_cs & 3) == 0)"
+	tempfile.write("condition $bpnum "+cond_str+ignore_str+"\n")
+	tempfile.write("commands\n")
+	tempfile.write("collect $no_self_trace\n")
+	tempfile.write("collect $p_ip\n")
+	tempfile.write("end\n")
+else:
+	pid_str = ""
+	for pid in task_list:
+		if pid_str != "":
+			pid_str += " || "
+		else:
+			pid_str += "("
+		pid_str += "($current_task_pid == "+str(pid)+") "
+	if pid_str != "":
+		pid_str += ")"
+	cond_str = ""
+	if not trace_user:
+		if pid_str != "":
+			cond_str += " && "
+		cond_str += " ((regs->cs & 3) == 0)"
+	elif not trace_kernel:
+		if pid_str != "":
+			cond_str += "&&"
+		cond_str += " ((regs->cs & 3) == 3)"
+	tempfile.write("trace handle_irq\n")
+	tempfile.write("condition $bpnum "+pid_str+cond_str+"\n")
+	tempfile.write("commands\n")
+	tempfile.write("collect regs->ip\n")
+	if trace_user and trace_kernel:
+		tempfile.write("collect regs->cs\n")
+	tempfile.write("collect $current_task_pid\n")
+	tempfile.write("end\n")
+	tempfile.write("trace smp_apic_timer_interrupt\n")
+	tempfile.write("condition $bpnum "+pid_str+cond_str+"\n")
+	tempfile.write("commands\n")
+	tempfile.write("collect regs->ip\n")
+	if trace_user and trace_kernel:
+		tempfile.write("collect regs->cs\n")
+	tempfile.write("collect $current_task_pid\n")
+	tempfile.write("end\n")
+tempfile.close()
+tempfile = open(tempfilename, "r")
+print "Tracepoint command:"
+print tempfile.read()
+tempfile.close()
+gdb.execute("source "+tempfilename, True, False)
+os.remove(tempfilename)
+gdb.execute("set disconnected-tracing on", True, False)
+gdb.execute("tstart")
+gdb.execute("kill", True, False)
+
+signal.signal(signal.SIGINT, sigint_handler);
+signal.siginterrupt(signal.SIGINT, False);
+
+#Connect to pipe
+gdb.execute("target tfile /sys/kernel/debug/gtpframe_pipe")
+
+#--------------------------------------------------------------------------------------------------
+#cycle
+
+def add_line_to_list(line, line_list):
+	if line in line_list:
+		line_list[line] += 1
+	else:
+		line_list[line] = 1
+
+#info[0] line_num, info[1] file_name, info[2] function_name
+def add_info_to_code_list(info, code_list):
+	line = str(info[1]) + ":" + str(info[0])
+	#function_list
+	if info[2] in code_list.function_list:
+		code_list.function_list[info[2]] += 1
+	else:
+		code_list.function_list[info[2]] = 1
+		code_list.function_list_line[info[2]] = {}
+	add_line_to_list(line, code_list.function_list_line[info[2]])
+	#file_list
+	if info[1] in code_list.file_list:
+		code_list.file_list[info[1]] += 1
+	else:
+		code_list.file_list[info[1]] = 1
+		code_list.file_list_line[info[1]] = {}
+	add_line_to_list(line, code_list.file_list_line[info[1]])
+	#line_list
+	add_line_to_list(line, code_list.line_list)
+	#num
+	code_list.num += 1
+
+def task_list_add_line(is_user, pid, info):
+	global task_list
+	if no_task:
+		add_info_to_code_list (info, kernel_hotcode_list)
+	else:
+		if is_user:
+			add_info_to_code_list (info, task_list[pid].user)
+		else:
+			add_info_to_code_list (info, task_list[pid].kernel)
+
+def get_line_from_sym(sym):
+	sym = sym.rstrip(os.linesep)
+
+	#Get line_num and file_name
+	begin = sym.find("Line ")
+	end = sym.find("\" starts at address")
+	line_num = None
+	file_name = None
+	if begin >= 0 and end > 0 and begin + len("Line ") < end:
+		line = sym[begin + len("Line "):end]
+		line = line.split(" of \"")
+		if len(line) == 2:
+			line_num = line[0]
+			file_name = line[1]
+		sym = sym[end:]
+
+	#Get function_name
+	begin = sym.find("<")
+	end = sym.find(">")
+	if begin >= 0 and end > 0 and begin + 1 < end:
+		function_name = sym[begin + 1:end]
+		end = function_name.rfind("+")
+		if end > 0:
+			function_name = function_name[:end]
+		sym = gdb.execute("info symbol "+function_name, True, True).rstrip(os.linesep)
+		begin = sym.rfind(" of ")
+		if begin > 0:
+			begin += len(" of ")
+			function_name = sym[begin:] + ":" + function_name
+	else:
+		function_name = None
+	return (line_num, file_name, function_name)
+
+if no_task:
+	while 1:
+		try:
+			gdb.execute("tfind 0", False, True)
+			sym = gdb.execute("info line *($p_ip - 1)", True, True)
+			line = get_line_from_sym(sym)
+			task_list_add_line(False, 0, line)
+		except gdb.error, x:
+			print("Drop one entry because:")
+			for file, lineno, function, text in traceback.extract_tb(sys.exc_info()[2]):
+				print file, lineno, function, text
+		except gdb.MemoryError, x:
+			print("Drop one entry because:")
+			for file, lineno, function, text in traceback.extract_tb(sys.exc_info()[2]):
+				print file, lineno, function, text
+		try:
+			gdb.execute("tfind 1", False, True)
+		except:
+			pass
+else:
+	while 1:
+		try:
+			gdb.execute("tfind 0", False, True)
+			is_user = False
+			pid = long(gdb.parse_and_eval("$current_task_pid"))
+			if not pid in task_list:
+				raise gdb.error ("Cannot find inferior for pid "+ str(pid) +", drop one entry.")
+			if trace_user and (not trace_kernel or long(gdb.parse_and_eval("regs->cs & 3")) == 3):
+				is_user = True
+				ip = long(gdb.parse_and_eval("regs->ip - 1"))
+				gdb.execute("inferior "+str(task_list[pid].fid), False, True)
+				sym = gdb.execute("info line *"+str(ip), True, True)
+			else:
+				sym = gdb.execute("info line *(regs->ip - 1)", True, True)
+			line = get_line_from_sym(sym)
+			if is_user:
+				gdb.execute("inferior 1", False, True)
+			task_list_add_line(is_user, pid, line)
+		except gdb.error, x:
+			print("Drop one entry because:")
+			for file, lineno, function, text in traceback.extract_tb(sys.exc_info()[2]):
+				print file, lineno, function, text
+			try:
+				gdb.execute("inferior 1", False, True)
+			except:
+				pass
+		except gdb.MemoryError, x:
+			print("Drop one entry because:")
+			for file, lineno, function, text in traceback.extract_tb(sys.exc_info()[2]):
+				print file, lineno, function, text
+			try:
+				gdb.execute("inferior 1", False, True)
+			except:
+				pass
+		try:
+			gdb.execute("tfind 1", False, True)
+		except:
+			pass
--- /dev/null
+++ b/scripts/gtp/add-ons/pe.py
@@ -0,0 +1,729 @@
+#!/usr/bin/python
+
+# This script is used to show the performance counters in graph mode
+# GPL
+# Copyright(C) Hui Zhu (teawater@gmail.com), 2011
+
+
+pe_list = []
+#0 type, 1 config, 2 name
+#typt and config can get from https://code.google.com/p/kgtp/wiki/HOWTO#How_to_use_performance_counters
+pe_list.append(["0","0", "CPU_CYCLES"])
+pe_list.append(["0","1", "INSTRUCTIONS"])
+pe_list.append(["0","2", "CACHE_REFERENCES"])
+pe_list.append(["0","3", "CACHE_MISSES"])
+pe_list.append(["0","4", "BRANCH_INSTRUCTIONS"])
+pe_list.append(["0","5", "BRANCH_MISSES"])
+pe_list.append(["0","6", "BUS_CYCLES"])
+#pe_list.append(["3","0", "L1D_READ_ACCESS"])
+#pe_list.append(["3","1", "L1I_READ_ACCESS"])
+
+#sleep time
+sleep_sec = 1
+
+#0 text 1 gtk
+gui_type = 1
+
+in_gdb = False
+
+
+pe_list_type = 0
+pe_list_config = 1
+pe_list_name = 2
+pe_list_prev = 3
+pe_list_qtv = 4
+
+if in_gdb:
+	import gdb
+else:
+	import os
+
+
+class kgtp:
+	fd = -1
+	retry_count = 3
+	buf_max = 1024
+	tvariable = {}
+	tvariable_next_number = 0
+
+	def __init__(self):
+		#Open fd
+		try:
+			self.fd = os.open("/sys/kernel/debug/gtp", os.O_RDWR)
+		except:
+			print "Please do not forget insmod and sudo."
+			exit(0)
+
+	def __del__(self):
+		if self.fd >= 0:
+			os.close(self.fd)
+
+	def read_fd(self):
+		try:
+			buf = os.read(self.fd, self.buf_max)
+		except:
+			return False
+		return buf
+
+	def write_fd(self, msg):
+		try:
+			buf = os.write(self.fd, msg)
+		except:
+			return False
+		return True
+
+	def read(self):
+		for i in range(0, self.retry_count):
+			if i != 0:
+				self.write_fd("-")
+
+			buf = self.read_fd()
+			if buf == False:
+				continue
+			buf_len = len(buf)
+			if buf_len < 4:
+				continue
+
+			csum = 0
+			for i in range(0, buf_len - 2):
+				if i == 0:
+					if buf[i] != "$":
+						retry = True
+						break
+				elif buf[i] == '#':
+					break
+				else:
+					csum += ord(buf[i])
+			if i == 0 or buf[i] != "#":
+				continue
+			if int("0x"+buf[i+1:i+3], 16) != (csum & 0xff):
+				continue
+			buf = buf[1:i]
+			self.write_fd("+")
+
+			#print "KGTP read: "+buf
+			return buf
+
+		print "KGTP read got error"
+		return False
+
+	def write(self, msg):
+		for i in range(0, self.retry_count):
+			if i != 0:
+				self.write_fd("-")
+
+			csum = 0
+			for c in msg:
+				csum += ord(c)
+			msg = "$"+msg+"#"+"%02x" % (csum & 0xff)
+
+			if self.write_fd(msg) == False:
+				continue
+			if self.read_fd() != "+":
+				continue
+
+			#print "KGTP write: "+msg
+			return True
+
+		print "KGTP write got error"
+		return False
+
+	def simple_cmd(self, cmd):
+		if gtp.write(cmd) == False:
+			return False
+		if gtp.read() != "OK":
+			return False
+		return True
+
+	def tvariable_init(self):
+		tvariable = {}
+		tvariable_next_number = 0
+
+		if gtp.write("qTfV") == False:
+			return False
+		ret = gtp.read()
+		while 1:
+			if ret == False:
+				return False
+			if ret == "l":
+				return True
+			ret = ret.split(":")
+			if len(ret) < 4:
+				print "KGTP GDBRSP package format error"
+				return False
+			if len(ret[3]) % 2 != 0:
+				print "KGTP GDBRSP package format error"
+				return False
+
+			#Get name
+			letter = ""
+			name = ""
+			for c in ret[3]:
+				letter += c
+				if len(letter) == 2:
+					name += chr(int("0x"+letter, 16))
+					letter = ""
+
+			number = int("0x"+ret[0], 16)
+			self.tvariable[name] = number
+			if (number >= self.tvariable_next_number):
+				self.tvariable_next_number = number + 1
+
+			if gtp.write("qTsV") == False:
+				return False
+			ret = gtp.read()
+
+	def tvariable_val(self, number):
+		return self.tvariable_val_raw("qTV:"+"%x" % number)
+
+	def tvariable_val_raw(self, buf):
+		if gtp.write(buf) == False:
+			return
+		ret = gtp.read()
+		if ret == False:
+			return
+		if ret[0] != "V":
+			return
+
+		return long("0x"+ret[1:], 16)
+
+	def tvariable_add(self, name, val):
+		if self.tvariable_next_number == 0:
+			print "Must call tvariable_init before add tvariable"
+			return
+
+		buf = "QTDV:" + "%x" % self.tvariable_next_number + ":" + "%x" % val + ":0:"
+		for c in name:
+			buf += "%02x" % ord(c)
+		if gtp.write(buf) == False:
+			return
+		if gtp.read() != "OK":
+			print "Get something wrong when add tvariable to KGTP"
+			return
+
+		self.tvariable_next_number += 1
+		return (self.tvariable_next_number - 1)
+
+	def qtinit(self):
+		return self.simple_cmd("QTinit")
+
+	def tstart(self):
+		return self.simple_cmd("QTStart")
+
+	def tstop(self):
+		return self.simple_cmd("QTStop")
+
+
+def each_entry(callback):
+	global pe_list, cpu_number
+	for i in range(0, cpu_number):
+		for e in pe_list:
+			callback(i, e)
+
+
+def init_pe(i, e):
+	if (len(e) < pe_list_prev + 1):
+		e.append([])
+	e[pe_list_prev].append(0)
+	if (len(e) < pe_list_qtv + 1):
+		e.append([])
+
+	if in_gdb:
+		gdb.execute("tvariable $p_pe_type_"+e[pe_list_type]+e[pe_list_config]+"_"+str(i)+"="+e[pe_list_type], True, False)
+		gdb.execute("tvariable $p_pe_config_"+e[pe_list_type]+e[pe_list_config]+"_"+str(i)+"="+e[pe_list_config], True, False)
+		gdb.execute("tvariable $p_pe_val_"+e[pe_list_type]+e[pe_list_config]+"_"+str(i)+"=0", True, False)
+		gdb.execute("tvariable $p_pe_en_"+e[pe_list_type]+e[pe_list_config]+"_"+str(i)+"=1", True, False)
+	else:
+		if gtp.tvariable_add("p_pe_type_"+e[pe_list_type]+e[pe_list_config]+"_"+str(i), int(e[pe_list_type])) == None:
+			exit(0)
+		if gtp.tvariable_add("p_pe_config_"+e[pe_list_type]+e[pe_list_config]+"_"+str(i), int(e[pe_list_config])) == None:
+			exit(0)
+		number = gtp.tvariable_add("p_pe_val_"+e[pe_list_type]+e[pe_list_config]+"_"+str(i), 0)
+		if number == None:
+			exit(0)
+		if gtp.tvariable_add("p_pe_en_"+e[pe_list_type]+e[pe_list_config]+"_"+str(i), 1) == None:
+			exit(0)
+		e[pe_list_qtv].append("qTV:"+"%x" % number)
+
+def init_kgtp():
+	global cpu_number
+
+	if in_gdb:
+		cpu_number = int(gdb.parse_and_eval("$cpu_number"))
+		#Set the empty tracepoint
+		gdb.execute("delete tracepoints", False, False)
+		gdb.execute("trace *0", True, False)
+	else:
+		cpu_number = gtp.tvariable_val(gtp.tvariable["cpu_number"])
+		if cpu_number == None:
+			exit(0)
+
+	#Set the pe
+	each_entry(init_pe)
+
+import signal
+def sigint_handler(num, e):
+	if in_gdb:
+		gdb.execute("tstop", True, False)
+	else:
+		gtp.tstop()
+	exit(0)
+
+
+if in_gdb:
+	#close pagination
+	gdb.execute("set pagination off", True, False);
+	#Connect to KGTP if need
+	if str(gdb.selected_thread()) == "None":
+		gdb.execute("target remote /sys/kernel/debug/gtp", True, False)
+else:
+	gtp = kgtp()
+	if gtp.qtinit == False:
+		exit(0)
+	if gtp.tvariable_init() == False:
+		exit(0)
+
+#Init the status to KGTP
+cpu_number = 0
+init_kgtp()
+signal.signal(signal.SIGINT, sigint_handler)
+
+
+#start
+if in_gdb:
+	gdb.execute("tstart", True, False)
+else:
+	gtp.tstart()
+
+
+#text gui ---------------------------------------------------------------------
+#pe_list will be set to:type, config, name, prev_value_list
+if gui_type == 0:
+	import time
+	def output_pe(i, e):
+		if in_gdb:
+			current_value = long(gdb.parse_and_eval("$p_pe_val_"+e[pe_list_type]+e[pe_list_config]+"_"+str(i)))
+		else:
+			current_value = gtp.tvariable_val_raw(e[pe_list_qtv][i])
+			if current_value == None:
+				print "Fail when get val from KGTP"
+				exit(0)
+		print "cpu"+str(i),e[pe_list_name],current_value-e[pe_list_prev][i]
+		e[pe_list_prev][i] = current_value
+
+	while 1:
+		each_entry(output_pe)
+		print
+		time.sleep(sleep_sec)
+
+
+#gtk gui ----------------------------------------------------------------------
+#pe_list will be set to:0 type, 1 config, 2 name, 3 prev_value_list,
+#			4 value_list, 5 x_list, 6 button_list,
+#			7 button_color_list, 8 line_color_list
+if gui_type == 1:
+	#This script need python-gtk2
+	import gtk
+	import glib
+
+	pe_list_value = 5
+	pe_list_x = 6
+	pe_list_button = 7
+	pe_list_bcolor = 8
+	pe_list_lcolor = 9
+
+	pe_color = (0xffb0ff, 0x006000)
+
+	class PyApp(gtk.Window):
+		#Init ----------------------------------------------------------
+		def __init__(self):
+			global pe_list, cpu_number
+
+			super(PyApp, self).__init__()
+
+			self.max_value = 0
+			self.prev_width = 0
+			self.prev_height = 0
+			self.y_ratio = 0
+			self.entry_width = 10
+			self.logfd = False
+
+			#Set the pe
+			each_entry(self.pe_init_callback)
+
+			#Set the color
+			num = len(pe_list) * cpu_number
+			block = (pe_color[0] - pe_color[1]) / float(num)
+			color = pe_color[1]
+			for i in range(0, cpu_number):
+				for e in pe_list:
+					e[pe_list_bcolor].append(gtk.gdk.Color("#"+ "%06x" % int(color)))
+					e[pe_list_lcolor].append((((int(color) >> 16) / float(0xff) * 1), ((int(color) >> 8 & 0xff) / float(0xff) * 1), ((int(color) & 0xff) / float(0xff) * 1)))
+					color += block
+
+			#Set window
+			self.set_title("KGTP")
+			self.connect("destroy", gtk.main_quit)
+			gtk.Window.maximize(self)
+
+			#menubar
+			mb = gtk.MenuBar()
+			#file
+			filemenu = gtk.Menu()
+			filem = gtk.MenuItem("File")
+			filem.set_submenu(filemenu)
+			save = gtk.CheckMenuItem("Save log to a CSV file")
+			save.connect("activate", self.mb_save)
+			save.set_active(False)
+			exit = gtk.MenuItem("Exit")
+			exit.connect("activate", gtk.main_quit)
+			filemenu.append(save)
+			filemenu.append(gtk.SeparatorMenuItem())
+			filemenu.append(exit)
+			mb.append(filem)
+			#set
+			setmenu = gtk.Menu()
+			setm = gtk.MenuItem("Settings")
+			setm.set_submenu(setmenu)
+			show_buttons = gtk.CheckMenuItem("Show buttons")
+			show_buttons.set_active(True)
+			show_buttons.connect("activate", self.show_buttons)
+			setmenu.append(show_buttons)
+			mb.append(setm)
+
+			#Widget
+			#Creat self.darea
+			self.darea = gtk.DrawingArea()
+			self.darea.connect("expose-event", self.expose)
+			self.darea.modify_bg(gtk.STATE_NORMAL, gtk.gdk.Color("#FFFFFF"))
+			#Creat all ToggleButton for each pe
+			each_entry(self.pe_gtk_creat_button)
+			#Creat button_hboxes
+			self.button_hboxes = self.pe_gtk_creat_button_hboxes_first()
+
+			#Add mb and widget to window
+			self.vbox = gtk.VBox(False, 0)
+			self.vbox.pack_start(mb, False, False, 0)
+			self.vbox.pack_start(self.darea, True, True, 0)
+			for e in self.button_hboxes:
+				self.vbox.pack_start(e, False, False, 0)
+			self.add(self.vbox)
+
+			#First show to get the right size
+			self.show_all()
+			size = self.pe_gtk_get_size()
+
+			#Reset the button_hboxes
+			each_entry(self.pe_gtk_remove_creat_button_hboxes)
+			for e in self.button_hboxes:
+				self.vbox.remove(e)
+			self.button_hboxes = self.pe_gtk_creat_button_hboxes_second(size)
+			for e in self.button_hboxes:
+				self.vbox.pack_start(e, False, False, 0)
+			self.show_all()
+
+			#Reset the value of each button
+			each_entry(self.button_reset)
+
+			#Add timer
+			glib.timeout_add(int(sleep_sec * 1000), self.timer_cb)
+			#Remove the first entry because it already record a big value
+			glib.timeout_add(int(sleep_sec * 1100), self.timer_remove_first_record)
+
+		def __del__(self):
+			if self.logfd:
+				self.logfd.close()
+				self.logfd = False
+
+		def pe_init_callback(self, i, e):
+			if (len(e) < pe_list_value + 1):
+				e.append([])
+			e[pe_list_value].append([])
+			if (len(e) < pe_list_x + 1):
+				e.append([])
+			e[pe_list_x].append([])
+			if (len(e) < pe_list_button + 1):
+				e.append([])
+			if (len(e) < pe_list_button + 1):
+				e.append([])
+			if (len(e) < pe_list_bcolor + 1):
+				e.append([])
+			if (len(e) < pe_list_lcolor + 1):
+				e.append([])
+
+		def pe_gtk_creat_button(self, i, e):
+			e[pe_list_button].append(gtk.ToggleButton(e[pe_list_name]+":"+str(18446744073709551615)))
+			self.set_button_color(e[pe_list_button][i], e[pe_list_bcolor][i])
+			e[pe_list_button][i].connect("clicked", self.button_click)
+
+		def pe_gtk_creat_button_hboxes_first(self):
+			global pe_list, cpu_number
+
+			hboxes = []
+			self.label_list = []
+			for i in range(0, cpu_number):
+				hboxes.append(gtk.HBox(False, 0))
+				self.label_list.append(gtk.Label("CPU"+str(i)))
+				hboxes[i].pack_start(self.label_list[i], False, False, 0)
+				for e in pe_list:
+					hboxes[i].pack_start(e[pe_list_button][i], False, False, 0)
+
+			return hboxes
+
+		def pe_gtk_get_size(self):
+			global pe_list, cpu_number
+
+			#0 label size 1 button size
+			size = ([],[])
+			for i in range(0, cpu_number):
+				size[0].append(self.label_list[i].allocation.width)
+				size[1].append([])
+				for e in pe_list:
+					size[1][i].append(e[pe_list_button][i].allocation.width)
+
+			return size
+
+		def pe_gtk_remove_creat_button_hboxes(self, i, e):
+			self.button_hboxes[i].remove(e[pe_list_button][i])
+
+		def pe_gtk_creat_button_hboxes_second(self, size):
+			global pe_list, cpu_number
+
+			hboxes = []
+			hbox_id = -1
+			for i in range(0, cpu_number):
+				keep_going = True
+				prev_entry_id = 0
+				while keep_going == True:
+					width = self.allocation.width
+					keep_going = False
+					hbox_id += 1
+					hboxes.append(gtk.HBox(False, 0))
+					width -= size[0][i]
+					hboxes[hbox_id].pack_start(gtk.Label("CPU"+str(i)), False, False, 0)
+					for j in range(prev_entry_id, len(pe_list)):
+						if width - size[1][i][j] <= 0:
+							prev_entry_id = j
+							keep_going = True
+							break
+						width -= size[1][i][j] + 200
+						hboxes[hbox_id].pack_start(pe_list[j][pe_list_button][i], False, False, 0)
+
+			return hboxes
+
+		def button_reset(self, i, e):
+			e[pe_list_button][i].set_label(e[pe_list_name]+":0")
+
+		#Dialog -------------------------------------------------------
+		def dialog_error(self, msg):
+			md = gtk.MessageDialog(self,gtk.DIALOG_DESTROY_WITH_PARENT, gtk.MESSAGE_ERROR, gtk.BUTTONS_CLOSE, msg)
+			md.run()
+			md.destroy()
+
+		#Menubar -------------------------------------------------------
+		def show_buttons(self, widget):
+			if widget.active:
+				for e in self.button_hboxes:
+					e.show()
+			else:
+				for e in self.button_hboxes:
+					e.hide()
+
+		def log_write_name(self, i, e):
+			self.logfd.write("CPU"+str(i)+" "+e[pe_list_name]+",")
+
+		def mb_save(self, widget):
+			if widget.active:
+				md = gtk.FileChooserDialog(title="Save log to a CSV file", action=gtk.FILE_CHOOSER_ACTION_SAVE, buttons = (gtk.STOCK_CANCEL,gtk.RESPONSE_CANCEL,gtk.STOCK_OK, gtk.RESPONSE_OK))
+				md.set_do_overwrite_confirmation(True)
+				md.set_current_name("pe.csv")
+				if md.run() == gtk.RESPONSE_OK:
+					try:
+						self.logfd = open(md.get_filename(), "w")
+						each_entry(self.log_write_name)
+						self.logfd.write("\n")
+					except:
+						self.dialog_error("Try to open file "+md.get_filename()+" got error")
+						widget.set_active(False)
+						if self.logfd:
+							self.logfd.close()
+							self.logfd = False
+				else:
+					widget.set_active(False)
+				md.destroy()
+			else:
+				if self.logfd:
+					self.logfd.close()
+					self.logfd = False
+
+		#Button --------------------------------------------------------
+		def refind_max_value(self, i, e):
+			if e[pe_list_button][i].get_active():
+				return
+			for i in e[pe_list_value][i]:
+				if i > self.max_value:
+					self.max_value = i
+					self.y_ratio = 0
+
+		def set_button_color(self, button, color):
+			style = button.get_style().copy()
+			style.bg[gtk.STATE_NORMAL] = color
+			style.bg[gtk.STATE_ACTIVE] = color
+			style.bg[gtk.STATE_PRELIGHT] = color
+			style.bg[gtk.STATE_SELECTED] = color
+			style.bg[gtk.STATE_INSENSITIVE] = color
+			button.set_style(style)
+
+		def button_click(self, widget):
+			if widget.get_active():
+				self.set_button_color(widget, gtk.gdk.Color("#FFFFFF"))
+			else:
+				color = False
+				for i in range(0, cpu_number):
+					for e in pe_list:
+						if e[pe_list_button][i] == widget:
+							color = e[pe_list_bcolor][i]
+							break
+					if color:
+						break
+				if color:
+					self.set_button_color(widget, color)
+				each_entry(self.refind_max_value)
+			self.darea.queue_draw()
+
+		#Timer ---------------------------------------------------------
+		def write_csv(self, msg):
+			try:
+				self.logfd.write(msg)
+			except:
+				self.dialog_error("Writ CSV file got error")
+				widget.set_active(False)
+				self.logfd.close()
+				self.logfd = False
+
+		def pe_gtk_add(self, i, e):
+			if in_gdb:
+				current_value = long(gdb.parse_and_eval("$p_pe_val_"+e[pe_list_type]+e[pe_list_config]+"_"+str(i)))
+			else:
+				current_value = gtp.tvariable_val_raw(e[pe_list_qtv][i])
+				if current_value == None:
+					print "Fail when get val from KGTP"
+					exit(0)
+			this_value = current_value-e[pe_list_prev][i]
+			e[pe_list_value][i].append(this_value)
+			if this_value > self.max_value and not e[pe_list_button][i].get_active():
+				self.max_value = this_value
+				self.y_ratio = 0
+			e[pe_list_x][i].append(-1)
+			e[pe_list_prev][i] = current_value
+			e[pe_list_button][i].set_label(e[pe_list_name]+":"+str(this_value))
+			if self.logfd:
+				write_csv(str(this_value)+",")
+
+		def timer_cb(self):
+			each_entry(self.pe_gtk_add)
+			if self.logfd:
+				write_csv("\n")
+			self.darea.queue_draw()
+			return True
+
+		def timer_remove_first_record(self):
+			if len(pe_list[0][pe_list_value][0]) >= 1:
+				self.pe_remove_entry_num = 1
+				each_entry(self.pe_remove_entry)
+				return False
+			else:
+				return True
+
+		#DrawingArea ---------------------------------------------------
+		def pe_gtk_line(self, i, e):
+			if len(e[pe_list_value][i]) < 2:
+				return
+			if e[pe_list_button][i].get_active():
+				return
+
+			self.cr.set_source_rgb(e[pe_list_lcolor][i][0], e[pe_list_lcolor][i][1], e[pe_list_lcolor][i][2])
+			x = 0
+			for num in range(0, len(e[pe_list_value][i])):
+				if e[pe_list_value][i][num] > self.line_max:
+					self.line_max = e[pe_list_value][i][num]
+				if self.height_change or e[pe_list_x][i][num] < 0:
+					e[pe_list_x][i][num] = self.prev_height - e[pe_list_value][i][num] * self.y_ratio
+				if num == 0:
+					self.cr.move_to(x, e[pe_list_x][i][num])
+				else:
+					self.cr.line_to(x, e[pe_list_x][i][num])
+				x += self.entry_width
+			self.cr.stroke()
+
+		def pe_remove_entry(self, i, e):
+			del(e[pe_list_value][i][0:self.pe_remove_entry_num])
+			del(e[pe_list_x][i][0:self.pe_remove_entry_num])
+
+		def expose(self, widget, event):
+			self.cr = widget.window.cairo_create()
+
+			#y
+			if self.prev_height != self.darea.allocation.height:
+				self.height_change = True
+				self.prev_height = self.darea.allocation.height
+			else:
+				self.height_change = False
+			if self.max_value > 0 and (self.height_change or self.y_ratio == 0):
+				self.max_value += 100 - self.max_value % 100
+				self.y_ratio = float(self.prev_height)/self.max_value
+				self.height_change = True
+
+			#x
+			x_size = len(pe_list[0][pe_list_value][0])
+			entry_number = 0
+			if self.entry_width * x_size > self.darea.allocation.width:
+				entry_number = self.darea.allocation.width // self.entry_width
+				self.pe_remove_entry_num = x_size - entry_number
+				each_entry(self.pe_remove_entry)
+
+			#dash
+			self.cr.set_source_rgb(0, 0, 0)
+			self.cr.set_dash((1, 5))
+			#dash line for x
+			if entry_number == 0:
+				entry_number = self.darea.allocation.width // self.entry_width
+			x = 0
+			while x < self.darea.allocation.width:
+				x += self.entry_width * 10
+				self.cr.move_to(x, 0)
+				self.cr.line_to(x, self.prev_height)
+			#dash line for y
+			self.cr.move_to(0, 10)
+			self.cr.show_text(str(self.max_value))
+
+			self.cr.move_to(0, self.darea.allocation.height/4*3)
+			self.cr.show_text(str(self.max_value/4*3))
+			self.cr.line_to(self.darea.allocation.width, self.darea.allocation.height/4*3)
+
+			self.cr.move_to(0, self.darea.allocation.height/2)
+			self.cr.show_text(str(self.max_value/2))
+			self.cr.line_to(self.darea.allocation.width, self.darea.allocation.height/2)
+
+			self.cr.move_to(0, self.darea.allocation.height/4)
+			self.cr.show_text(str(self.max_value/4))
+			self.cr.line_to(self.darea.allocation.width, self.darea.allocation.height/4)
+
+			self.cr.stroke()
+			self.cr.set_dash(())
+
+			self.line_max = 0
+			each_entry(self.pe_gtk_line)
+			if self.line_max > 0 and self.line_max * 2 < self.max_value:
+				self.max_value = self.line_max
+				self.y_ratio = 0
+
+			self.height_change = False
+
+	PyApp()
+	gtk.main()
+	if in_gdb:
+		gdb.execute("tstop", True, False)
+	else:
+		gtp.tstop()
+	exit(0)
--- /dev/null
+++ b/scripts/gtp/getgtprsp.pl
@@ -0,0 +1,182 @@
+#!/usr/bin/perl
+
+# This script to get the GDB tracepoint RSP package and save it
+# to ./gtpstart and ./gtpstop file.
+# GPL
+# Copyright(C) KGTP team (https://code.google.com/p/kgtp/), 2010-2013
+
+binmode STDIN, ":raw";
+$| = 1;
+
+$status = 0;
+$circular = 0;
+$var_count = 0;
+
+while (1) {
+	sysread STDIN, $c, 1 or next;
+	if ($c eq '') {
+		next;
+	} elsif ($c eq '+' || $c eq '-') {
+		$c = '';
+	}
+
+	sysread STDIN, $line, 1024 or next;
+	print '+';
+	$line = $c.$line;
+
+	open(LOG, ">>./log");
+	print LOG $line."\n";
+	close (LOG);
+
+	if ($status == 0) {
+		if ($line eq '$?#3f') {
+			print '$S05#b8';
+		} elsif ($line eq '$g#67') {
+			print '$00000000#80';
+		} elsif ($line eq '$k#6b') {
+			exit;
+		} elsif ($line =~ /^\$m/ || $line =~ /^\$p/) {
+			print '$00000000#80';
+		} elsif ($line eq '$qTStatus#49') {
+			print '$T0;tnotrun:0;tframes:0;tcreated:0;tsize:';
+			print '500000;tfree:500000;circular:0;disconn:0#d1';
+		} elsif ($line eq '$QTBuffer:circular:1#f9') {
+			print '$OK#9a';
+			$circular = 1;
+		} elsif ($line eq '$QTBuffer:circular:0#f8') {
+			print '$OK#9a';
+			$circular = 0;
+		} elsif ($line eq '$QTStop#4b') {
+			print '$OK#9a';
+		} elsif ($line =~ /^\$qSupported/) {
+			print '$ConditionalTracepoints+;TracepointSource+#1b';
+		} elsif ($line eq '$QTinit#59') {
+			$status = 1;
+			open(STARTFILE, ">./gtpstart");
+			print STARTFILE '$QTDisconnected:1#e3'."\n";
+			if ($circular) {
+				print STARTFILE '$QTBuffer:circular:1#f9';
+			} else {
+				print STARTFILE '$QTBuffer:circular:0#f8';
+			}
+		} elsif ($line eq '$qTfV#81') {
+			print '$18:0:1:6972715f636f756e74#ca';
+		} elsif ($line eq '$qTsV#8e') {
+			#Support from GTP_VAR_VERSION_ID(0x1) to GTP_STEP_ID_ID(0x2d)
+			if ($var_count == 0) {
+				print '$17:0:1:736f66746972715f636f756e74#a6';
+			} elsif ($var_count == 1) {
+				print '$16:0:1:686172646972715f636f756e74#70';
+			} elsif ($var_count == 2) {
+				print '$15:0:1:6c6173745f6572726e6f#59';
+			} elsif ($var_count == 3) {
+				print '$14:0:1:69676e6f72655f6572726f72#38';
+			} elsif ($var_count == 4) {
+				print '$13:0:1:7874696d655f6e736563#35';
+			} elsif ($var_count == 5) {
+				print '$12:0:1:7874696d655f736563#99';
+			} elsif ($var_count == 6) {
+				print '$11:0:1:6b726574#48';
+			} elsif ($var_count == 7) {
+				print '$10:0:1:705f70655f656e#e5';
+			} elsif ($var_count == 8) {
+				print '$f:0:1:6370755f6e756d626572#29';
+			} elsif ($var_count == 9) {
+				print '$e:0:1:73656c665f7472616365#f8';
+			} elsif ($var_count == 10) {
+				print '$d:0:1:64756d705f737461636b#22';
+			} elsif ($var_count == 11) {
+				print '$c:0:1:7072696e746b5f666f726d6174#c7';
+			} elsif ($var_count == 12) {
+				print '$b:8:1:7072696e746b5f6c6576656c#66';
+			} elsif ($var_count == 13) {
+				print '$a:0:1:7072696e746b5f746d70#54';
+			} elsif ($var_count == 14) {
+				print '$9:0:1:6774705f72625f646973636172645f706167655f6e756d626572#2d';
+			} elsif ($var_count == 15) {
+				print '$8:0:1:636f6f6b65645f7264747363#01';
+			} elsif ($var_count == 16) {
+				print '$7:0:1:7264747363#57';
+			} elsif ($var_count == 17) {
+				print '$6:0:1:636f6f6b65645f636c6f636b#8d';
+			} elsif ($var_count == 18) {
+				print '$5:0:1:636c6f636b#e3';
+			} elsif ($var_count == 19) {
+				print '$4:0:1:63757272656e745f7468726561645f696e666f#21';
+			} elsif ($var_count == 20) {
+				print '$3:0:1:63757272656e745f7461736b#c9';
+			} elsif ($var_count == 21) {
+				print '$2:0:1:6370755f6964#f1';
+			} elsif ($var_count == 22) {
+				print '$1:bfe30fc:1:6774705f76657273696f6e#94';
+			} elsif ($var_count == 23) {
+				print '$19:0:1:706970655f7472616365#cb';
+			} elsif ($var_count == 24) {
+				print '$1a:0:1:63757272656e745f7461736b5f706964#03';
+			} elsif ($var_count == 25) {
+				print '$1d:200:1:6274#d9';
+			} elsif ($var_count == 26) {
+				print '$1b:0:1:63757272656e745f7461736b5f75736572#6e';
+			} elsif ($var_count == 27) {
+				print '$1c:0:1:63757272656e74#bb';
+			} elsif ($var_count == 28) {
+				print '$1f:0:1:64697361626c65#bc';
+			} elsif ($var_count == 29) {
+				print '$1e:0:1:656e61626c65#7e';
+			} elsif ($var_count == 30) {
+				print '$18:0:1:6972715f636f756e74#ca';
+			} elsif ($var_count == 31) {
+				print '$20:0:1:77617463685f737461746963#a2';
+			} elsif ($var_count == 32) {
+				print '$21:0:1:77617463685f74797065#d1';
+			} elsif ($var_count == 33) {
+				print '$22:1:1:77617463685f73697a65#02';
+			} elsif ($var_count == 34) {
+				print '$23:0:1:77617463685f7365745f6964#da';
+			} elsif ($var_count == 35) {
+				print '$24:0:1:77617463685f7365745f61646472#a6';
+			} elsif ($var_count == 36) {
+				print '$25:0:1:77617463685f7374617274#38';
+			} elsif ($var_count == 37) {
+				print '$26:0:1:77617463685f73746f70#01';
+			} elsif ($var_count == 38) {
+				print '$27:0:1:77617463685f74726163655f6e756d#75';
+			} elsif ($var_count == 39) {
+				print '$28:0:1:77617463685f74726163655f61646472#79';
+			} elsif ($var_count == 40) {
+				print '$29:0:1:77617463685f61646472#d0';
+			} elsif ($var_count == 41) {
+				print '$2a:0:1:77617463685f76616c#c1';
+			} elsif ($var_count == 42) {
+				print '$2b:0:1:77617463685f636f756e74#cc';
+			} elsif ($var_count == 43) {
+				print '$2c:0:1:737465705f636f756e74#5d';
+			} elsif ($var_count == 44) {
+				print '$2d:0:1:737465705f6964#c0';
+			} else {
+				print '$l#6c';
+			}
+			$var_count++;
+		} else {
+			print '$#00';
+		}
+	}
+
+	if ($status == 1) {
+		print '$OK#9a';
+
+		if (length($line) > 0) {
+			print STARTFILE "\n".$line;
+		}
+
+		if ($line eq '$QTStart#b3') {
+			$status = 0;
+
+			close(STARTFILE);
+
+			open(STOPFILE, ">./gtpstop");
+			print STOPFILE '$QTStop#4b';
+			close(STOPFILE);
+		}
+	}
+}
--- /dev/null
+++ b/scripts/gtp/getmod.py
@@ -0,0 +1,151 @@
+#!/usr/bin/python
+
+# This script is used by GDB to load the symbols from Linux kernel modules
+# GPL
+# Copyright(C) KGTP team (https://code.google.com/p/kgtp/), 2011, 2012
+
+#Set special mod_search_dir
+#set $mod_search_dir="dir"
+#Clear special mod_search_dir
+#set $mod_search_dir=(void)1
+#Not ignore gtp.ko
+#set $ignore_gtp_ko=0
+
+import gdb
+import os
+
+def get_pagination():
+	buf = gdb.execute("show pagination", False, True)
+	begin = buf.find("State of pagination is ") + len("State of pagination is ")
+	if begin < 0:
+		raise NotImplementedError("Cannot get pagination")
+	buf = buf[begin:]
+	end = buf.rfind(".")
+	buf = buf[:end]
+
+	return buf
+
+pagination = get_pagination()
+gdb.execute("set pagination off", False, False)
+
+def format_file(name):
+	tmp = ""
+	for c in name:
+		if c == "_":
+			c = "-"
+		tmp += c
+	return tmp
+
+#Check if the target is available
+if str(gdb.selected_thread()) == "None":
+	raise gdb.error("Please connect to Linux Kernel before use the script.")
+
+#Output the help
+print "Use GDB command \"set $mod_search_dir=dir\" to set an directory for search the modules."
+
+ignore_gtp_ko = gdb.parse_and_eval("$ignore_gtp_ko")
+if ignore_gtp_ko.type.code == gdb.TYPE_CODE_INT:
+	ignore_gtp_ko = int(ignore_gtp_ko)
+else:
+	ignore_gtp_ko = 1
+
+#Get the mod_search_dir
+mod_search_dir_list = []
+#Get dir from $mod_search_dir
+tmp_dir = gdb.parse_and_eval("$mod_search_dir")
+if tmp_dir.type.code == gdb.TYPE_CODE_ARRAY:
+	tmp_dir = str(tmp_dir)
+	tmp_dir = tmp_dir[1:len(tmp_dir)]
+	tmp_dir = tmp_dir[0:tmp_dir.index("\"")]
+	mod_search_dir_list.append(tmp_dir)
+#Get dir that same with current vmlinux
+tmp_dir = str(gdb.execute("info files", False, True))
+tmp_dir = tmp_dir[tmp_dir.index("Symbols from \"")+len("Symbols from \""):len(tmp_dir)]
+tmp_dir = tmp_dir[0:tmp_dir.index("\"")]
+tmp_dir = tmp_dir[0:tmp_dir.rindex("/")]
+mod_search_dir_list.append(tmp_dir)
+#Get the dir of current Kernel
+tmp_dir = "/lib/modules/" + str(os.uname()[2])
+if os.path.isdir(tmp_dir):
+	mod_search_dir_list.append(tmp_dir)
+#Let user choice dir
+mod_search_dir = ""
+while mod_search_dir == "":
+	for i in range(0, len(mod_search_dir_list)):
+		print str(i)+". "+mod_search_dir_list[i]
+	try:
+		s = input('Select a directory for search the modules [0]:')
+	except SyntaxError:
+		s = 0
+	except:
+		continue
+	if s < 0 or s >= len(mod_search_dir_list):
+		continue
+	mod_search_dir = mod_search_dir_list[s]
+
+mod_list_offset = long(gdb.parse_and_eval("((size_t) &(((struct module *)0)->list))"))
+mod_list = long(gdb.parse_and_eval("(&modules)"))
+mod_list_current = mod_list
+
+while 1:
+	mod_list_current = long(gdb.parse_and_eval("((struct list_head *) "+str(mod_list_current)+")->next"))
+
+	#check if need break the loop
+	if mod_list == mod_list_current:
+		break
+
+	mod = mod_list_current - mod_list_offset
+
+	#get mod_name
+	mod_name = str(gdb.parse_and_eval("((struct module *)"+str(mod)+")->name"))
+	mod_name = mod_name[mod_name.index("\"")+1:len(mod_name)]
+	mod_name = mod_name[0:mod_name.index("\"")]
+	mod_name += ".ko"
+	mod_name = format_file(mod_name)
+
+	#get mod_dir_name
+	mod_dir_name = ""
+	for root, dirs, files in os.walk(mod_search_dir):
+		for afile in files:
+			tmp_file = format_file(afile)
+			if tmp_file == mod_name:
+				mod_dir_name = os.path.join(root,afile)
+				break
+		if mod_dir_name != "":
+			break
+
+	command = " "
+
+	#Add module_core to command
+	tmp = str(gdb.parse_and_eval("((struct module *)"+str(mod)+")->module_core"))
+	if tmp.find('<') >= 0:
+		tmp = tmp[:tmp.index('<')]
+	command += tmp
+
+	#Add each sect_attrs->attrs to command
+	#get nsections
+	nsections = int(gdb.parse_and_eval("((struct module *)"+str(mod)+")->sect_attrs->nsections"))
+	sect_attrs = long(gdb.parse_and_eval("(u64)((struct module *)"+str(mod)+")->sect_attrs"))
+	for i in range(0, nsections):
+		command += " -s"
+		tmp = str(gdb.parse_and_eval("((struct module_sect_attrs *)"+str(sect_attrs)+")->attrs["+str(i)+"].name"))
+		tmp = tmp[tmp.index("\"")+1:len(tmp)]
+		tmp = tmp[0:tmp.index("\"")]
+		command += " "+tmp
+		tmp = str(gdb.parse_and_eval("((struct module_sect_attrs *)"+str(sect_attrs)+")->attrs["+str(i)+"].address"))
+		command += " "+tmp
+
+	if mod_dir_name == "":
+		print "Cannot find out",mod_name,"from directory."
+		print "Please use following command load the symbols from it:"
+		print "add-symbol-file some_dir/"+mod_name+command
+	else:
+		if ignore_gtp_ko and mod_name == "gtp.ko":
+			print "gtp.ko is ignored.  You can use command \"set $ignore_gtp_ko=0\" to close this ignore."
+			print "Or you can use following command load the symbols from it:"
+			print "add-symbol-file "+mod_dir_name+command
+		else:
+			#print "add-symbol-file "+mod_dir_name+command
+			gdb.execute("add-symbol-file "+mod_dir_name+command, False, False)
+
+gdb.execute("set pagination " + pagination, False, False)
